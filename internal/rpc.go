// Code generated by goxdr -B -p nfs4 nfs4/rpc.x; DO NOT EDIT.

package internal
import (
	"context"
	"fmt"
)

var _ = fmt.Sprintf
var _ context.Context

//
// Data types defined in XDR file
//

type Auth_flavor int32
const (
	AUTH_NONE Auth_flavor = 0
	AUTH_SYS Auth_flavor = 1
	AUTH_SHORT Auth_flavor = 2
	AUTH_DH Auth_flavor = 3
)

type Opaque_auth struct {
	Flavor Auth_flavor
	Body []byte // bound 400
}

type Msg_type int32
const (
	CALL Msg_type = 0
	REPLY Msg_type = 1
)

/* A reply to a call message can take on two forms: the message was
   either accepted or rejected. */
type Reply_stat int32
const (
	MSG_ACCEPTED Reply_stat = 0
	MSG_DENIED Reply_stat = 1
)

/* Given that a call message was accepted, the following is the status
   of an attempt to call a remote procedure. */
type Accept_stat int32
const (
	/* RPC executed successfully       */
	SUCCESS Accept_stat = 0
	/* remote hasn't exported program  */
	PROG_UNAVAIL Accept_stat = 1
	/* remote can't support version #  */
	PROG_MISMATCH Accept_stat = 2
	/* program can't support procedure */
	PROC_UNAVAIL Accept_stat = 3
	/* procedure can't decode params   */
	GARBAGE_ARGS Accept_stat = 4
	/* e.g. memory allocation failure  */
	SYSTEM_ERR Accept_stat = 5
)

/* Reasons why a call message was rejected: */
type Reject_stat int32
const (
	/* RPC version number != 2          */
	RPC_MISMATCH Reject_stat = 0
	/* remote can't authenticate caller */
	AUTH_ERROR Reject_stat = 1
)

/* Why authentication failed: */
type Auth_stat int32
const (
	/* success                        */
	AUTH_OK Auth_stat = 0
	/* bad credential (seal broken)   */
	AUTH_BADCRED Auth_stat = 1
	/* client must begin new session  */
	AUTH_REJECTEDCRED Auth_stat = 2
	/* bad verifier (seal broken)     */
	AUTH_BADVERF Auth_stat = 3
	/* verifier expired or replayed   */
	AUTH_REJECTEDVERF Auth_stat = 4
	/* rejected for security reasons  */
	AUTH_TOOWEAK Auth_stat = 5
	/* bogus response verifier        */
	AUTH_INVALIDRESP Auth_stat = 6
	/* reason unknown                 */
	AUTH_FAILED Auth_stat = 7
	/* kerberos generic error */
	AUTH_KERB_GENERIC Auth_stat = 8
	/* time of credential expired */
	AUTH_TIMEEXPIRE Auth_stat = 9
	/* problem with ticket file */
	AUTH_TKT_FILE Auth_stat = 10
	/* can't decode authenticator */
	AUTH_DECODE Auth_stat = 11
	/* wrong net address in ticket */
	AUTH_NET_ADDR Auth_stat = 12
	/* no credentials for user */
	RPCSEC_GSS_CREDPROBLEM Auth_stat = 13
	/* problem with context */
	RPCSEC_GSS_CTXPROBLEM Auth_stat = 14
)

/* Body of an RPC call: */
type Call_body struct {
	/* must be equal to two (2) */
	Rpcvers uint32
	Prog uint32
	Vers uint32
	Proc uint32
	Cred Opaque_auth
	Verf Opaque_auth
}

/* Reply to an RPC call that was accepted by the server: */
type Accepted_reply struct {
	Verf Opaque_auth
	Reply_data XdrAnon_Accepted_reply_Reply_data
}
type XdrAnon_Accepted_reply_Reply_data struct {
	// The union discriminant Stat selects among the following arms:
	//   SUCCESS:
	//      Results() *[0]byte
	//   PROG_MISMATCH:
	//      Mismatch_info() *XdrAnon_Accepted_reply_Reply_data_Mismatch_info
	//   default:
	//      void
	Stat Accept_stat
	U interface{}
}
type XdrAnon_Accepted_reply_Reply_data_Mismatch_info struct {
	Low uint32
	High uint32
}

/* Reply to an RPC call that was rejected by the server: */
type Rejected_reply struct {
	// The union discriminant Stat selects among the following arms:
	//   RPC_MISMATCH:
	//      Mismatch_info() *XdrAnon_Rejected_reply_Mismatch_info
	//   AUTH_ERROR:
	//      Rj_why() *Auth_stat
	Stat Reject_stat
	U interface{}
}
type XdrAnon_Rejected_reply_Mismatch_info struct {
	Low uint32
	High uint32
}

/* Body of a reply to an RPC call: */
type Reply_body struct {
	// The union discriminant Stat selects among the following arms:
	//   MSG_ACCEPTED:
	//      Areply() *Accepted_reply
	//   MSG_DENIED:
	//      Rreply() *Rejected_reply
	Stat Reply_stat
	U interface{}
}

/* The RPC message: */
type Rpc_msg struct {
	Xid uint32
	Body XdrAnon_Rpc_msg_Body
}
type XdrAnon_Rpc_msg_Body struct {
	// The union discriminant Mtype selects among the following arms:
	//   CALL:
	//      Cbody() *Call_body
	//   REPLY:
	//      Rbody() *Reply_body
	Mtype Msg_type
	U interface{}
}

//
// Helper types and generated marshaling functions
//

var _XdrNames_Auth_flavor = map[int32]string{
	int32(AUTH_NONE): "AUTH_NONE",
	int32(AUTH_SYS): "AUTH_SYS",
	int32(AUTH_SHORT): "AUTH_SHORT",
	int32(AUTH_DH): "AUTH_DH",
	int32(RPCSEC_GSS): "RPCSEC_GSS",
}
var _XdrValues_Auth_flavor = map[string]int32{
	"AUTH_NONE": int32(AUTH_NONE),
	"AUTH_SYS": int32(AUTH_SYS),
	"AUTH_SHORT": int32(AUTH_SHORT),
	"AUTH_DH": int32(AUTH_DH),
	"RPCSEC_GSS": int32(RPCSEC_GSS),
}
func (Auth_flavor) XdrEnumNames() map[int32]string {
	return _XdrNames_Auth_flavor
}
func (v Auth_flavor) String() string {
	if s, ok := _XdrNames_Auth_flavor[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Auth_flavor#%d", v)
}
func (v *Auth_flavor) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Auth_flavor[stok]; ok {
			*v = Auth_flavor(val)
			return nil
		} else if stok == "Auth_flavor" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Auth_flavor.", stok))
	}
}
func (v Auth_flavor) GetU32() uint32 { return uint32(v) }
func (v *Auth_flavor) SetU32(n uint32) { *v = Auth_flavor(n) }
func (v *Auth_flavor) XdrPointer() interface{} { return v }
func (Auth_flavor) XdrTypeName() string { return "Auth_flavor" }
func (v Auth_flavor) XdrValue() interface{} { return v }
func (v *Auth_flavor) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Auth_flavor = *Auth_flavor
func XDR_Auth_flavor(v *Auth_flavor) *Auth_flavor { return v }
type XdrType_Opaque_auth = *Opaque_auth
func (v *Opaque_auth) XdrPointer() interface{} { return v }
func (Opaque_auth) XdrTypeName() string { return "Opaque_auth" }
func (v Opaque_auth) XdrValue() interface{} { return v }
func (v *Opaque_auth) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Opaque_auth) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sflavor", name), XDR_Auth_flavor(&v.Flavor))
	x.Marshal(x.Sprintf("%sbody", name), XdrVecOpaque{&v.Body, 400})
}
func XDR_Opaque_auth(v *Opaque_auth) *Opaque_auth { return v }
var _XdrNames_Msg_type = map[int32]string{
	int32(CALL): "CALL",
	int32(REPLY): "REPLY",
}
var _XdrValues_Msg_type = map[string]int32{
	"CALL": int32(CALL),
	"REPLY": int32(REPLY),
}
func (Msg_type) XdrEnumNames() map[int32]string {
	return _XdrNames_Msg_type
}
func (v Msg_type) String() string {
	if s, ok := _XdrNames_Msg_type[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Msg_type#%d", v)
}
func (v *Msg_type) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Msg_type[stok]; ok {
			*v = Msg_type(val)
			return nil
		} else if stok == "Msg_type" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Msg_type.", stok))
	}
}
func (v Msg_type) GetU32() uint32 { return uint32(v) }
func (v *Msg_type) SetU32(n uint32) { *v = Msg_type(n) }
func (v *Msg_type) XdrPointer() interface{} { return v }
func (Msg_type) XdrTypeName() string { return "Msg_type" }
func (v Msg_type) XdrValue() interface{} { return v }
func (v *Msg_type) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Msg_type = *Msg_type
func XDR_Msg_type(v *Msg_type) *Msg_type { return v }
var _XdrNames_Reply_stat = map[int32]string{
	int32(MSG_ACCEPTED): "MSG_ACCEPTED",
	int32(MSG_DENIED): "MSG_DENIED",
}
var _XdrValues_Reply_stat = map[string]int32{
	"MSG_ACCEPTED": int32(MSG_ACCEPTED),
	"MSG_DENIED": int32(MSG_DENIED),
}
func (Reply_stat) XdrEnumNames() map[int32]string {
	return _XdrNames_Reply_stat
}
func (v Reply_stat) String() string {
	if s, ok := _XdrNames_Reply_stat[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Reply_stat#%d", v)
}
func (v *Reply_stat) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Reply_stat[stok]; ok {
			*v = Reply_stat(val)
			return nil
		} else if stok == "Reply_stat" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Reply_stat.", stok))
	}
}
func (v Reply_stat) GetU32() uint32 { return uint32(v) }
func (v *Reply_stat) SetU32(n uint32) { *v = Reply_stat(n) }
func (v *Reply_stat) XdrPointer() interface{} { return v }
func (Reply_stat) XdrTypeName() string { return "Reply_stat" }
func (v Reply_stat) XdrValue() interface{} { return v }
func (v *Reply_stat) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Reply_stat = *Reply_stat
func XDR_Reply_stat(v *Reply_stat) *Reply_stat { return v }
var _XdrNames_Accept_stat = map[int32]string{
	int32(SUCCESS): "SUCCESS",
	int32(PROG_UNAVAIL): "PROG_UNAVAIL",
	int32(PROG_MISMATCH): "PROG_MISMATCH",
	int32(PROC_UNAVAIL): "PROC_UNAVAIL",
	int32(GARBAGE_ARGS): "GARBAGE_ARGS",
	int32(SYSTEM_ERR): "SYSTEM_ERR",
}
var _XdrValues_Accept_stat = map[string]int32{
	"SUCCESS": int32(SUCCESS),
	"PROG_UNAVAIL": int32(PROG_UNAVAIL),
	"PROG_MISMATCH": int32(PROG_MISMATCH),
	"PROC_UNAVAIL": int32(PROC_UNAVAIL),
	"GARBAGE_ARGS": int32(GARBAGE_ARGS),
	"SYSTEM_ERR": int32(SYSTEM_ERR),
}
func (Accept_stat) XdrEnumNames() map[int32]string {
	return _XdrNames_Accept_stat
}
func (v Accept_stat) String() string {
	if s, ok := _XdrNames_Accept_stat[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Accept_stat#%d", v)
}
func (v *Accept_stat) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Accept_stat[stok]; ok {
			*v = Accept_stat(val)
			return nil
		} else if stok == "Accept_stat" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Accept_stat.", stok))
	}
}
func (v Accept_stat) GetU32() uint32 { return uint32(v) }
func (v *Accept_stat) SetU32(n uint32) { *v = Accept_stat(n) }
func (v *Accept_stat) XdrPointer() interface{} { return v }
func (Accept_stat) XdrTypeName() string { return "Accept_stat" }
func (v Accept_stat) XdrValue() interface{} { return v }
func (v *Accept_stat) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Accept_stat = *Accept_stat
func XDR_Accept_stat(v *Accept_stat) *Accept_stat { return v }
var _XdrNames_Reject_stat = map[int32]string{
	int32(RPC_MISMATCH): "RPC_MISMATCH",
	int32(AUTH_ERROR): "AUTH_ERROR",
}
var _XdrValues_Reject_stat = map[string]int32{
	"RPC_MISMATCH": int32(RPC_MISMATCH),
	"AUTH_ERROR": int32(AUTH_ERROR),
}
func (Reject_stat) XdrEnumNames() map[int32]string {
	return _XdrNames_Reject_stat
}
func (v Reject_stat) String() string {
	if s, ok := _XdrNames_Reject_stat[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Reject_stat#%d", v)
}
func (v *Reject_stat) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Reject_stat[stok]; ok {
			*v = Reject_stat(val)
			return nil
		} else if stok == "Reject_stat" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Reject_stat.", stok))
	}
}
func (v Reject_stat) GetU32() uint32 { return uint32(v) }
func (v *Reject_stat) SetU32(n uint32) { *v = Reject_stat(n) }
func (v *Reject_stat) XdrPointer() interface{} { return v }
func (Reject_stat) XdrTypeName() string { return "Reject_stat" }
func (v Reject_stat) XdrValue() interface{} { return v }
func (v *Reject_stat) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Reject_stat = *Reject_stat
func XDR_Reject_stat(v *Reject_stat) *Reject_stat { return v }
var _XdrNames_Auth_stat = map[int32]string{
	int32(AUTH_OK): "AUTH_OK",
	int32(AUTH_BADCRED): "AUTH_BADCRED",
	int32(AUTH_REJECTEDCRED): "AUTH_REJECTEDCRED",
	int32(AUTH_BADVERF): "AUTH_BADVERF",
	int32(AUTH_REJECTEDVERF): "AUTH_REJECTEDVERF",
	int32(AUTH_TOOWEAK): "AUTH_TOOWEAK",
	int32(AUTH_INVALIDRESP): "AUTH_INVALIDRESP",
	int32(AUTH_FAILED): "AUTH_FAILED",
	int32(AUTH_KERB_GENERIC): "AUTH_KERB_GENERIC",
	int32(AUTH_TIMEEXPIRE): "AUTH_TIMEEXPIRE",
	int32(AUTH_TKT_FILE): "AUTH_TKT_FILE",
	int32(AUTH_DECODE): "AUTH_DECODE",
	int32(AUTH_NET_ADDR): "AUTH_NET_ADDR",
	int32(RPCSEC_GSS_CREDPROBLEM): "RPCSEC_GSS_CREDPROBLEM",
	int32(RPCSEC_GSS_CTXPROBLEM): "RPCSEC_GSS_CTXPROBLEM",
}
var _XdrValues_Auth_stat = map[string]int32{
	"AUTH_OK": int32(AUTH_OK),
	"AUTH_BADCRED": int32(AUTH_BADCRED),
	"AUTH_REJECTEDCRED": int32(AUTH_REJECTEDCRED),
	"AUTH_BADVERF": int32(AUTH_BADVERF),
	"AUTH_REJECTEDVERF": int32(AUTH_REJECTEDVERF),
	"AUTH_TOOWEAK": int32(AUTH_TOOWEAK),
	"AUTH_INVALIDRESP": int32(AUTH_INVALIDRESP),
	"AUTH_FAILED": int32(AUTH_FAILED),
	"AUTH_KERB_GENERIC": int32(AUTH_KERB_GENERIC),
	"AUTH_TIMEEXPIRE": int32(AUTH_TIMEEXPIRE),
	"AUTH_TKT_FILE": int32(AUTH_TKT_FILE),
	"AUTH_DECODE": int32(AUTH_DECODE),
	"AUTH_NET_ADDR": int32(AUTH_NET_ADDR),
	"RPCSEC_GSS_CREDPROBLEM": int32(RPCSEC_GSS_CREDPROBLEM),
	"RPCSEC_GSS_CTXPROBLEM": int32(RPCSEC_GSS_CTXPROBLEM),
}
func (Auth_stat) XdrEnumNames() map[int32]string {
	return _XdrNames_Auth_stat
}
func (v Auth_stat) String() string {
	if s, ok := _XdrNames_Auth_stat[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Auth_stat#%d", v)
}
func (v *Auth_stat) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Auth_stat[stok]; ok {
			*v = Auth_stat(val)
			return nil
		} else if stok == "Auth_stat" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Auth_stat.", stok))
	}
}
func (v Auth_stat) GetU32() uint32 { return uint32(v) }
func (v *Auth_stat) SetU32(n uint32) { *v = Auth_stat(n) }
func (v *Auth_stat) XdrPointer() interface{} { return v }
func (Auth_stat) XdrTypeName() string { return "Auth_stat" }
func (v Auth_stat) XdrValue() interface{} { return v }
func (v *Auth_stat) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Auth_stat = *Auth_stat
func XDR_Auth_stat(v *Auth_stat) *Auth_stat { return v }
type XdrType_Call_body = *Call_body
func (v *Call_body) XdrPointer() interface{} { return v }
func (Call_body) XdrTypeName() string { return "Call_body" }
func (v Call_body) XdrValue() interface{} { return v }
func (v *Call_body) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Call_body) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%srpcvers", name), XDR_uint32(&v.Rpcvers))
	x.Marshal(x.Sprintf("%sprog", name), XDR_uint32(&v.Prog))
	x.Marshal(x.Sprintf("%svers", name), XDR_uint32(&v.Vers))
	x.Marshal(x.Sprintf("%sproc", name), XDR_uint32(&v.Proc))
	x.Marshal(x.Sprintf("%scred", name), XDR_Opaque_auth(&v.Cred))
	x.Marshal(x.Sprintf("%sverf", name), XDR_Opaque_auth(&v.Verf))
}
func XDR_Call_body(v *Call_body) *Call_body { return v }
type XdrType_XdrAnon_Accepted_reply_Reply_data_Mismatch_info = *XdrAnon_Accepted_reply_Reply_data_Mismatch_info
func (v *XdrAnon_Accepted_reply_Reply_data_Mismatch_info) XdrPointer() interface{} { return v }
func (XdrAnon_Accepted_reply_Reply_data_Mismatch_info) XdrTypeName() string { return "XdrAnon_Accepted_reply_Reply_data_Mismatch_info" }
func (v XdrAnon_Accepted_reply_Reply_data_Mismatch_info) XdrValue() interface{} { return v }
func (v *XdrAnon_Accepted_reply_Reply_data_Mismatch_info) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_Accepted_reply_Reply_data_Mismatch_info) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slow", name), XDR_uint32(&v.Low))
	x.Marshal(x.Sprintf("%shigh", name), XDR_uint32(&v.High))
}
func XDR_XdrAnon_Accepted_reply_Reply_data_Mismatch_info(v *XdrAnon_Accepted_reply_Reply_data_Mismatch_info) *XdrAnon_Accepted_reply_Reply_data_Mismatch_info { return v }
type _XdrArray_0_opaque [0]byte
func (v *_XdrArray_0_opaque) GetByteSlice() []byte { return v[:] }
func (v *_XdrArray_0_opaque) XdrTypeName() string { return "opaque[]" }
func (v *_XdrArray_0_opaque) XdrValue() interface{} { return v[:] }
func (v *_XdrArray_0_opaque) XdrPointer() interface{} { return (*[0]byte)(v) }
func (v *_XdrArray_0_opaque) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *_XdrArray_0_opaque) String() string { return fmt.Sprintf("%x", v[:]) }
func (v *_XdrArray_0_opaque) Scan(ss fmt.ScanState, c rune) error {
	return XdrArrayOpaqueScan(v[:], ss, c)
}
func (_XdrArray_0_opaque) XdrArraySize() uint32 {
	const bound uint32 = 0 // Force error if not const or doesn't fit
	return bound
}
func (u *XdrAnon_Accepted_reply_Reply_data) Results() *[0]byte {
	switch u.Stat {
	case SUCCESS:
		if v, ok := u.U.(*[0]byte); ok {
			return v
		} else {
			var zero [0]byte
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Accepted_reply_Reply_data.Results accessed when Stat == %v", u.Stat)
		return nil
	}
}
func (u *XdrAnon_Accepted_reply_Reply_data) Mismatch_info() *XdrAnon_Accepted_reply_Reply_data_Mismatch_info {
	switch u.Stat {
	case PROG_MISMATCH:
		if v, ok := u.U.(*XdrAnon_Accepted_reply_Reply_data_Mismatch_info); ok {
			return v
		} else {
			var zero XdrAnon_Accepted_reply_Reply_data_Mismatch_info
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Accepted_reply_Reply_data.Mismatch_info accessed when Stat == %v", u.Stat)
		return nil
	}
}
func (u XdrAnon_Accepted_reply_Reply_data) XdrValid() bool {
	return true
}
func (u *XdrAnon_Accepted_reply_Reply_data) XdrUnionTag() XdrNum32 {
	return XDR_Accept_stat(&u.Stat)
}
func (u *XdrAnon_Accepted_reply_Reply_data) XdrUnionTagName() string {
	return "Stat"
}
func (u *XdrAnon_Accepted_reply_Reply_data) XdrUnionBody() XdrType {
	switch u.Stat {
	case SUCCESS:
		return (*_XdrArray_0_opaque)(u.Results())
	case PROG_MISMATCH:
		return XDR_XdrAnon_Accepted_reply_Reply_data_Mismatch_info(u.Mismatch_info())
	default:
		return nil
	}
}
func (u *XdrAnon_Accepted_reply_Reply_data) XdrUnionBodyName() string {
	switch u.Stat {
	case SUCCESS:
		return "Results"
	case PROG_MISMATCH:
		return "Mismatch_info"
	default:
		return ""
	}
}
type XdrType_XdrAnon_Accepted_reply_Reply_data = *XdrAnon_Accepted_reply_Reply_data
func (v *XdrAnon_Accepted_reply_Reply_data) XdrPointer() interface{} { return v }
func (XdrAnon_Accepted_reply_Reply_data) XdrTypeName() string { return "XdrAnon_Accepted_reply_Reply_data" }
func (v XdrAnon_Accepted_reply_Reply_data) XdrValue() interface{} { return v }
func (v *XdrAnon_Accepted_reply_Reply_data) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_Accepted_reply_Reply_data) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Accept_stat(&u.Stat).XdrMarshal(x, x.Sprintf("%sstat", name))
	switch u.Stat {
	case SUCCESS:
		x.Marshal(x.Sprintf("%sresults", name), (*_XdrArray_0_opaque)(u.Results()))
		return
	case PROG_MISMATCH:
		x.Marshal(x.Sprintf("%smismatch_info", name), XDR_XdrAnon_Accepted_reply_Reply_data_Mismatch_info(u.Mismatch_info()))
		return
	default:
		return
	}
}
func XDR_XdrAnon_Accepted_reply_Reply_data(v *XdrAnon_Accepted_reply_Reply_data) *XdrAnon_Accepted_reply_Reply_data { return v}
type XdrType_Accepted_reply = *Accepted_reply
func (v *Accepted_reply) XdrPointer() interface{} { return v }
func (Accepted_reply) XdrTypeName() string { return "Accepted_reply" }
func (v Accepted_reply) XdrValue() interface{} { return v }
func (v *Accepted_reply) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Accepted_reply) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sverf", name), XDR_Opaque_auth(&v.Verf))
	x.Marshal(x.Sprintf("%sreply_data", name), XDR_XdrAnon_Accepted_reply_Reply_data(&v.Reply_data))
}
func XDR_Accepted_reply(v *Accepted_reply) *Accepted_reply { return v }
type XdrType_XdrAnon_Rejected_reply_Mismatch_info = *XdrAnon_Rejected_reply_Mismatch_info
func (v *XdrAnon_Rejected_reply_Mismatch_info) XdrPointer() interface{} { return v }
func (XdrAnon_Rejected_reply_Mismatch_info) XdrTypeName() string { return "XdrAnon_Rejected_reply_Mismatch_info" }
func (v XdrAnon_Rejected_reply_Mismatch_info) XdrValue() interface{} { return v }
func (v *XdrAnon_Rejected_reply_Mismatch_info) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *XdrAnon_Rejected_reply_Mismatch_info) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slow", name), XDR_uint32(&v.Low))
	x.Marshal(x.Sprintf("%shigh", name), XDR_uint32(&v.High))
}
func XDR_XdrAnon_Rejected_reply_Mismatch_info(v *XdrAnon_Rejected_reply_Mismatch_info) *XdrAnon_Rejected_reply_Mismatch_info { return v }
var _XdrTags_Rejected_reply = map[int32]bool{
	XdrToI32(RPC_MISMATCH): true,
	XdrToI32(AUTH_ERROR): true,
}
func (_ Rejected_reply) XdrValidTags() map[int32]bool {
	return _XdrTags_Rejected_reply
}
func (u *Rejected_reply) Mismatch_info() *XdrAnon_Rejected_reply_Mismatch_info {
	switch u.Stat {
	case RPC_MISMATCH:
		if v, ok := u.U.(*XdrAnon_Rejected_reply_Mismatch_info); ok {
			return v
		} else {
			var zero XdrAnon_Rejected_reply_Mismatch_info
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Rejected_reply.Mismatch_info accessed when Stat == %v", u.Stat)
		return nil
	}
}
func (u *Rejected_reply) Rj_why() *Auth_stat {
	switch u.Stat {
	case AUTH_ERROR:
		if v, ok := u.U.(*Auth_stat); ok {
			return v
		} else {
			var zero Auth_stat
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Rejected_reply.Rj_why accessed when Stat == %v", u.Stat)
		return nil
	}
}
func (u Rejected_reply) XdrValid() bool {
	switch u.Stat {
	case RPC_MISMATCH,AUTH_ERROR:
		return true
	}
	return false
}
func (u *Rejected_reply) XdrUnionTag() XdrNum32 {
	return XDR_Reject_stat(&u.Stat)
}
func (u *Rejected_reply) XdrUnionTagName() string {
	return "Stat"
}
func (u *Rejected_reply) XdrUnionBody() XdrType {
	switch u.Stat {
	case RPC_MISMATCH:
		return XDR_XdrAnon_Rejected_reply_Mismatch_info(u.Mismatch_info())
	case AUTH_ERROR:
		return XDR_Auth_stat(u.Rj_why())
	}
	return nil
}
func (u *Rejected_reply) XdrUnionBodyName() string {
	switch u.Stat {
	case RPC_MISMATCH:
		return "Mismatch_info"
	case AUTH_ERROR:
		return "Rj_why"
	}
	return ""
}
type XdrType_Rejected_reply = *Rejected_reply
func (v *Rejected_reply) XdrPointer() interface{} { return v }
func (Rejected_reply) XdrTypeName() string { return "Rejected_reply" }
func (v Rejected_reply) XdrValue() interface{} { return v }
func (v *Rejected_reply) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Rejected_reply) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Reject_stat(&u.Stat).XdrMarshal(x, x.Sprintf("%sstat", name))
	switch u.Stat {
	case RPC_MISMATCH:
		x.Marshal(x.Sprintf("%smismatch_info", name), XDR_XdrAnon_Rejected_reply_Mismatch_info(u.Mismatch_info()))
		return
	case AUTH_ERROR:
		x.Marshal(x.Sprintf("%srj_why", name), XDR_Auth_stat(u.Rj_why()))
		return
	}
	XdrPanic("invalid Stat (%v) in Rejected_reply", u.Stat)
}
func XDR_Rejected_reply(v *Rejected_reply) *Rejected_reply { return v}
var _XdrTags_Reply_body = map[int32]bool{
	XdrToI32(MSG_ACCEPTED): true,
	XdrToI32(MSG_DENIED): true,
}
func (_ Reply_body) XdrValidTags() map[int32]bool {
	return _XdrTags_Reply_body
}
func (u *Reply_body) Areply() *Accepted_reply {
	switch u.Stat {
	case MSG_ACCEPTED:
		if v, ok := u.U.(*Accepted_reply); ok {
			return v
		} else {
			var zero Accepted_reply
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Reply_body.Areply accessed when Stat == %v", u.Stat)
		return nil
	}
}
func (u *Reply_body) Rreply() *Rejected_reply {
	switch u.Stat {
	case MSG_DENIED:
		if v, ok := u.U.(*Rejected_reply); ok {
			return v
		} else {
			var zero Rejected_reply
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Reply_body.Rreply accessed when Stat == %v", u.Stat)
		return nil
	}
}
func (u Reply_body) XdrValid() bool {
	switch u.Stat {
	case MSG_ACCEPTED,MSG_DENIED:
		return true
	}
	return false
}
func (u *Reply_body) XdrUnionTag() XdrNum32 {
	return XDR_Reply_stat(&u.Stat)
}
func (u *Reply_body) XdrUnionTagName() string {
	return "Stat"
}
func (u *Reply_body) XdrUnionBody() XdrType {
	switch u.Stat {
	case MSG_ACCEPTED:
		return XDR_Accepted_reply(u.Areply())
	case MSG_DENIED:
		return XDR_Rejected_reply(u.Rreply())
	}
	return nil
}
func (u *Reply_body) XdrUnionBodyName() string {
	switch u.Stat {
	case MSG_ACCEPTED:
		return "Areply"
	case MSG_DENIED:
		return "Rreply"
	}
	return ""
}
type XdrType_Reply_body = *Reply_body
func (v *Reply_body) XdrPointer() interface{} { return v }
func (Reply_body) XdrTypeName() string { return "Reply_body" }
func (v Reply_body) XdrValue() interface{} { return v }
func (v *Reply_body) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Reply_body) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Reply_stat(&u.Stat).XdrMarshal(x, x.Sprintf("%sstat", name))
	switch u.Stat {
	case MSG_ACCEPTED:
		x.Marshal(x.Sprintf("%sareply", name), XDR_Accepted_reply(u.Areply()))
		return
	case MSG_DENIED:
		x.Marshal(x.Sprintf("%srreply", name), XDR_Rejected_reply(u.Rreply()))
		return
	}
	XdrPanic("invalid Stat (%v) in Reply_body", u.Stat)
}
func XDR_Reply_body(v *Reply_body) *Reply_body { return v}
var _XdrTags_XdrAnon_Rpc_msg_Body = map[int32]bool{
	XdrToI32(CALL): true,
	XdrToI32(REPLY): true,
}
func (_ XdrAnon_Rpc_msg_Body) XdrValidTags() map[int32]bool {
	return _XdrTags_XdrAnon_Rpc_msg_Body
}
func (u *XdrAnon_Rpc_msg_Body) Cbody() *Call_body {
	switch u.Mtype {
	case CALL:
		if v, ok := u.U.(*Call_body); ok {
			return v
		} else {
			var zero Call_body
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Rpc_msg_Body.Cbody accessed when Mtype == %v", u.Mtype)
		return nil
	}
}
func (u *XdrAnon_Rpc_msg_Body) Rbody() *Reply_body {
	switch u.Mtype {
	case REPLY:
		if v, ok := u.U.(*Reply_body); ok {
			return v
		} else {
			var zero Reply_body
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("XdrAnon_Rpc_msg_Body.Rbody accessed when Mtype == %v", u.Mtype)
		return nil
	}
}
func (u XdrAnon_Rpc_msg_Body) XdrValid() bool {
	switch u.Mtype {
	case CALL,REPLY:
		return true
	}
	return false
}
func (u *XdrAnon_Rpc_msg_Body) XdrUnionTag() XdrNum32 {
	return XDR_Msg_type(&u.Mtype)
}
func (u *XdrAnon_Rpc_msg_Body) XdrUnionTagName() string {
	return "Mtype"
}
func (u *XdrAnon_Rpc_msg_Body) XdrUnionBody() XdrType {
	switch u.Mtype {
	case CALL:
		return XDR_Call_body(u.Cbody())
	case REPLY:
		return XDR_Reply_body(u.Rbody())
	}
	return nil
}
func (u *XdrAnon_Rpc_msg_Body) XdrUnionBodyName() string {
	switch u.Mtype {
	case CALL:
		return "Cbody"
	case REPLY:
		return "Rbody"
	}
	return ""
}
type XdrType_XdrAnon_Rpc_msg_Body = *XdrAnon_Rpc_msg_Body
func (v *XdrAnon_Rpc_msg_Body) XdrPointer() interface{} { return v }
func (XdrAnon_Rpc_msg_Body) XdrTypeName() string { return "XdrAnon_Rpc_msg_Body" }
func (v XdrAnon_Rpc_msg_Body) XdrValue() interface{} { return v }
func (v *XdrAnon_Rpc_msg_Body) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *XdrAnon_Rpc_msg_Body) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Msg_type(&u.Mtype).XdrMarshal(x, x.Sprintf("%smtype", name))
	switch u.Mtype {
	case CALL:
		x.Marshal(x.Sprintf("%scbody", name), XDR_Call_body(u.Cbody()))
		return
	case REPLY:
		x.Marshal(x.Sprintf("%srbody", name), XDR_Reply_body(u.Rbody()))
		return
	}
	XdrPanic("invalid Mtype (%v) in XdrAnon_Rpc_msg_Body", u.Mtype)
}
func XDR_XdrAnon_Rpc_msg_Body(v *XdrAnon_Rpc_msg_Body) *XdrAnon_Rpc_msg_Body { return v}
type XdrType_Rpc_msg = *Rpc_msg
func (v *Rpc_msg) XdrPointer() interface{} { return v }
func (Rpc_msg) XdrTypeName() string { return "Rpc_msg" }
func (v Rpc_msg) XdrValue() interface{} { return v }
func (v *Rpc_msg) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Rpc_msg) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sxid", name), XDR_uint32(&v.Xid))
	x.Marshal(x.Sprintf("%sbody", name), XDR_XdrAnon_Rpc_msg_Body(&v.Body))
}
func XDR_Rpc_msg(v *Rpc_msg) *Rpc_msg { return v }
