// Code generated by goxdr -B -p nfs4 nfs4/nfs4.x; DO NOT EDIT.

package internal
import(
	"bytes"
	"context"
	"encoding/binary"
	"fmt"
	"io"
	"math"
	"strings"
)

var _ = fmt.Sprintf
var _ context.Context

//
// Data types defined in XDR file
//

/*
 * Sizes
 */
const NFS4_FHSIZE = 128

const NFS4_VERIFIER_SIZE = 8

const NFS4_OPAQUE_LIMIT = 1024

const NFS4_SESSIONID_SIZE = 16

/*
 * File types
 */
type Nfs_ftype4 int32
const (
	/* Regular File */
	NF4REG Nfs_ftype4 = 1
	/* Directory */
	NF4DIR Nfs_ftype4 = 2
	/* Special File - block device */
	NF4BLK Nfs_ftype4 = 3
	/* Special File - character device */
	NF4CHR Nfs_ftype4 = 4
	/* Symbolic Link */
	NF4LNK Nfs_ftype4 = 5
	/* Special File - socket */
	NF4SOCK Nfs_ftype4 = 6
	/* Special File - fifo */
	NF4FIFO Nfs_ftype4 = 7
	/* Attribute Directory */
	NF4ATTRDIR Nfs_ftype4 = 8
	/* Named Attribute */
	NF4NAMEDATTR Nfs_ftype4 = 9
)

/*
 * Error status
 */
type Nfsstat4 int32
const (
	/* everything is okay      */
	NFS4_OK Nfsstat4 = 0
	/* caller not privileged   */
	NFS4ERR_PERM Nfsstat4 = 1
	/* no such file/directory  */
	NFS4ERR_NOENT Nfsstat4 = 2
	/* hard I/O error          */
	NFS4ERR_IO Nfsstat4 = 5
	/* no such device          */
	NFS4ERR_NXIO Nfsstat4 = 6
	/* access denied           */
	NFS4ERR_ACCESS Nfsstat4 = 13
	/* file already exists     */
	NFS4ERR_EXIST Nfsstat4 = 17
	/* different filesystems   */
	NFS4ERR_XDEV Nfsstat4 = 18
	/* should be a directory   */
	NFS4ERR_NOTDIR Nfsstat4 = 20
	/* should not be directory */
	NFS4ERR_ISDIR Nfsstat4 = 21
	/* invalid argument        */
	NFS4ERR_INVAL Nfsstat4 = 22
	/* file exceeds server max */
	NFS4ERR_FBIG Nfsstat4 = 27
	/* no space on filesystem  */
	NFS4ERR_NOSPC Nfsstat4 = 28
	/* read-only filesystem    */
	NFS4ERR_ROFS Nfsstat4 = 30
	/* too many hard links     */
	NFS4ERR_MLINK Nfsstat4 = 31
	/* name exceeds server max */
	NFS4ERR_NAMETOOLONG Nfsstat4 = 63
	/* directory not empty     */
	NFS4ERR_NOTEMPTY Nfsstat4 = 66
	/* hard quota limit reached*/
	NFS4ERR_DQUOT Nfsstat4 = 69
	/* file no longer exists   */
	NFS4ERR_STALE Nfsstat4 = 70
	/* Illegal filehandle      */
	NFS4ERR_BADHANDLE Nfsstat4 = 10001
	/* READDIR cookie is stale */
	NFS4ERR_BAD_COOKIE Nfsstat4 = 10003
	/* operation not supported */
	NFS4ERR_NOTSUPP Nfsstat4 = 10004
	/* response limit exceeded */
	NFS4ERR_TOOSMALL Nfsstat4 = 10005
	/* undefined server error  */
	NFS4ERR_SERVERFAULT Nfsstat4 = 10006
	/* type invalid for CREATE */
	NFS4ERR_BADTYPE Nfsstat4 = 10007
	/* file "busy" - retry     */
	NFS4ERR_DELAY Nfsstat4 = 10008
	/* nverify says attrs same */
	NFS4ERR_SAME Nfsstat4 = 10009
	/* lock unavailable        */
	NFS4ERR_DENIED Nfsstat4 = 10010
	/* lock lease expired      */
	NFS4ERR_EXPIRED Nfsstat4 = 10011
	/* I/O failed due to lock  */
	NFS4ERR_LOCKED Nfsstat4 = 10012
	/* in grace period         */
	NFS4ERR_GRACE Nfsstat4 = 10013
	/* filehandle expired      */
	NFS4ERR_FHEXPIRED Nfsstat4 = 10014
	/* share reserve denied    */
	NFS4ERR_SHARE_DENIED Nfsstat4 = 10015
	/* wrong security flavor   */
	NFS4ERR_WRONGSEC Nfsstat4 = 10016
	/* clientid in use         */
	NFS4ERR_CLID_INUSE Nfsstat4 = 10017
	/* resource exhaustion     */
	NFS4ERR_RESOURCE Nfsstat4 = 10018
	/* filesystem relocated    */
	NFS4ERR_MOVED Nfsstat4 = 10019
	/* current FH is not set   */
	NFS4ERR_NOFILEHANDLE Nfsstat4 = 10020
	/* minor vers not supp */
	NFS4ERR_MINOR_VERS_MISMATCH Nfsstat4 = 10021
	/* server has rebooted     */
	NFS4ERR_STALE_CLIENTID Nfsstat4 = 10022
	/* server has rebooted     */
	NFS4ERR_STALE_STATEID Nfsstat4 = 10023
	/* state is out of sync    */
	NFS4ERR_OLD_STATEID Nfsstat4 = 10024
	/* incorrect stateid       */
	NFS4ERR_BAD_STATEID Nfsstat4 = 10025
	/* request is out of seq.  */
	NFS4ERR_BAD_SEQID Nfsstat4 = 10026
	/* verify - attrs not same */
	NFS4ERR_NOT_SAME Nfsstat4 = 10027
	/* lock range not supported*/
	NFS4ERR_LOCK_RANGE Nfsstat4 = 10028
	/* should be file/directory*/
	NFS4ERR_SYMLINK Nfsstat4 = 10029
	/* no saved filehandle     */
	NFS4ERR_RESTOREFH Nfsstat4 = 10030
	/* some filesystem moved   */
	NFS4ERR_LEASE_MOVED Nfsstat4 = 10031
	/* recommended attr not sup*/
	NFS4ERR_ATTRNOTSUPP Nfsstat4 = 10032
	/* reclaim outside of grace*/
	NFS4ERR_NO_GRACE Nfsstat4 = 10033
	/* reclaim error at server */
	NFS4ERR_RECLAIM_BAD Nfsstat4 = 10034
	/* conflict on reclaim    */
	NFS4ERR_RECLAIM_CONFLICT Nfsstat4 = 10035
	/* XDR decode failed       */
	NFS4ERR_BADXDR Nfsstat4 = 10036
	/* file locks held at CLOSE*/
	NFS4ERR_LOCKS_HELD Nfsstat4 = 10037
	/* conflict in OPEN and I/O*/
	NFS4ERR_OPENMODE Nfsstat4 = 10038
	/* owner translation bad   */
	NFS4ERR_BADOWNER Nfsstat4 = 10039
	/* utf-8 char not supported*/
	NFS4ERR_BADCHAR Nfsstat4 = 10040
	/* name not supported      */
	NFS4ERR_BADNAME Nfsstat4 = 10041
	/* lock range not supported*/
	NFS4ERR_BAD_RANGE Nfsstat4 = 10042
	/* no atomic up/downgrade  */
	NFS4ERR_LOCK_NOTSUPP Nfsstat4 = 10043
	/* undefined operation     */
	NFS4ERR_OP_ILLEGAL Nfsstat4 = 10044
	/* file locking deadlock   */
	NFS4ERR_DEADLOCK Nfsstat4 = 10045
	/* open file blocks op.    */
	NFS4ERR_FILE_OPEN Nfsstat4 = 10046
	/* lockowner state revoked */
	NFS4ERR_ADMIN_REVOKED Nfsstat4 = 10047
	/* callback path down      */
	NFS4ERR_CB_PATH_DOWN Nfsstat4 = 10048
	NFS4ERR_BADIOMODE Nfsstat4 = 10049
	NFS4ERR_BADLAYOUT Nfsstat4 = 10050
	NFS4ERR_BAD_SESSION_DIGEST Nfsstat4 = 10051
	NFS4ERR_BADSESSION Nfsstat4 = 10052
	NFS4ERR_BADSLOT Nfsstat4 = 10053
	NFS4ERR_COMPLETE_ALREADY Nfsstat4 = 10054
	NFS4ERR_CONN_NOT_BOUND_TO_SESSION Nfsstat4 = 10055
	NFS4ERR_DELEG_ALREADY_WANTED Nfsstat4 = 10056
	NFS4ERR_BACK_CHAN_BUSY Nfsstat4 = 10057
	NFS4ERR_LAYOUTTRYLATER Nfsstat4 = 10058
	NFS4ERR_LAYOUTUNAVAILABLE Nfsstat4 = 10059
	NFS4ERR_NOMATCHING_LAYOUT Nfsstat4 = 10060
	NFS4ERR_RECALLCONFLICT Nfsstat4 = 10061
)

/*
 * Basic data types
 */
type Bitmap4 = []Uint32_t

type Offset4 = Uint64_t

type Count4 = Uint32_t

type Length4 = Uint64_t

type Clientid4 = Uint64_t

type Sequenceid4 = Uint32_t

type Seqid4 = Uint32_t

type Slotid4 = Uint32_t

type Utf8string = []byte

type Utf8str_cis = Utf8string

type Utf8str_cs = Utf8string

type Utf8str_mixed = Utf8string

type Component4 = Utf8str_cs

type Pathname4 = []Component4

type Nfs_lockid4 = Uint64_t

type Nfs_cookie4 = Uint64_t

type Linktext4 = Utf8str_cs

type Sec_oid4 = []byte

type Qop4 = Uint32_t

type Mode4 = Uint32_t

type Changeid4 = Uint64_t

type Verifier4 = [NFS4_VERIFIER_SIZE]byte

type Sessionid4 = [NFS4_SESSIONID_SIZE]byte

/*
 * Authsys_parms
 */
type Authsys_parms struct {
	Stamp uint32
	Machinename string // bound 255
	Uid uint32
	Gid uint32
	Gids []uint32 // bound 16
}

const NFS4_DEVICEID4_SIZE = 16

type Deviceid4 = [NFS4_DEVICEID4_SIZE]byte

type Layouttype4 int32
const (
	LAYOUT4_NFSV4_1_FILES Layouttype4 = Layouttype4(0x1)
	LAYOUT4_OSD2_OBJECTS Layouttype4 = Layouttype4(0x2)
	LAYOUT4_BLOCK_VOLUME Layouttype4 = Layouttype4(0x3)
)

type Layoutupdate4 struct {
	Lou_type Layouttype4
	Lou_body []byte
}

type Device_addr4 struct {
	Da_layout_type Layouttype4
	Da_addr_body []byte
}

/*
 * Timeval
 */
type Nfstime4 struct {
	Seconds Int64_t
	Nseconds Uint32_t
}

type Time_how4 int32
const (
	SET_TO_SERVER_TIME4 Time_how4 = 0
	SET_TO_CLIENT_TIME4 Time_how4 = 1
)

type Layoutiomode4 int32
const (
	LAYOUTIOMODE4_READ Layoutiomode4 = 1
	LAYOUTIOMODE4_RW Layoutiomode4 = 2
	LAYOUTIOMODE4_ANY Layoutiomode4 = 3
)

type Layout_content4 struct {
	Loc_type Layouttype4
	Loc_body []byte
}

type Layout4 struct {
	Lo_offset Offset4
	Lo_length Length4
	Lo_iomode Layoutiomode4
	Lo_content Layout_content4
}

type Settime4 struct {
	// The union discriminant Set_it selects among the following arms:
	//   SET_TO_CLIENT_TIME4:
	//      Time() *Nfstime4
	//   default:
	//      void
	Set_it Time_how4
	U interface{}
}

/*
 * File access handle
 */
type Nfs_fh4 = []byte // bound NFS4_FHSIZE

/*
 * FSID structure for major/minor
 */
type Fsid4 struct {
	Major Uint64_t
	Minor Uint64_t
}

/*
 * Filesystem locations attribute for relocation/migration
 */
type Fs_location4 struct {
	Server []Utf8str_cis
	Rootpath Pathname4
}

type Fs_locations4 struct {
	Fs_root Pathname4
	Locations []Fs_location4
}

/*
 * Mask that indicates which Access Control Entries are supported.
 * Values for the fattr4_aclsupport attribute.
 */
const ACL4_SUPPORT_ALLOW_ACL = 0x00000001

const ACL4_SUPPORT_DENY_ACL = 0x00000002

const ACL4_SUPPORT_AUDIT_ACL = 0x00000004

const ACL4_SUPPORT_ALARM_ACL = 0x00000008

type Acetype4 = Uint32_t

/*
 * acetype4 values, others can be added as needed.
 */
const ACE4_ACCESS_ALLOWED_ACE_TYPE = 0x00000000

const ACE4_ACCESS_DENIED_ACE_TYPE = 0x00000001

const ACE4_SYSTEM_AUDIT_ACE_TYPE = 0x00000002

const ACE4_SYSTEM_ALARM_ACE_TYPE = 0x00000003

/*
 * ACE flag
 */
type Aceflag4 = Uint32_t

/*
 * ACE flag values
 */
const ACE4_FILE_INHERIT_ACE = 0x00000001

const ACE4_DIRECTORY_INHERIT_ACE = 0x00000002

const ACE4_NO_PROPAGATE_INHERIT_ACE = 0x00000004

const ACE4_INHERIT_ONLY_ACE = 0x00000008

const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG = 0x00000010

const ACE4_FAILED_ACCESS_ACE_FLAG = 0x00000020

const ACE4_IDENTIFIER_GROUP = 0x00000040

/*
 * ACE mask
 */
type Acemask4 = Uint32_t

/*
 * ACE mask values
 */
const ACE4_READ_DATA = 0x00000001

const ACE4_LIST_DIRECTORY = 0x00000001

const ACE4_WRITE_DATA = 0x00000002

const ACE4_ADD_FILE = 0x00000002

const ACE4_APPEND_DATA = 0x00000004

const ACE4_ADD_SUBDIRECTORY = 0x00000004

const ACE4_READ_NAMED_ATTRS = 0x00000008

const ACE4_WRITE_NAMED_ATTRS = 0x00000010

const ACE4_EXECUTE = 0x00000020

const ACE4_DELETE_CHILD = 0x00000040

const ACE4_READ_ATTRIBUTES = 0x00000080

const ACE4_WRITE_ATTRIBUTES = 0x00000100

const ACE4_DELETE = 0x00010000

const ACE4_READ_ACL = 0x00020000

const ACE4_WRITE_ACL = 0x00040000

const ACE4_WRITE_OWNER = 0x00080000

const ACE4_SYNCHRONIZE = 0x00100000

/*
 * ACE4_GENERIC_READ -- defined as combination of
 *      ACE4_READ_ACL |
 *      ACE4_READ_DATA |
 *      ACE4_READ_ATTRIBUTES |
 *      ACE4_SYNCHRONIZE
 */
const ACE4_GENERIC_READ = 0x00120081

/*
 * ACE4_GENERIC_WRITE -- defined as combination of
 *      ACE4_READ_ACL |
 *      ACE4_WRITE_DATA |
 *      ACE4_WRITE_ATTRIBUTES |
 *      ACE4_WRITE_ACL |
 *      ACE4_APPEND_DATA |
 *      ACE4_SYNCHRONIZE
 */
const ACE4_GENERIC_WRITE = 0x00160106

/*
 * ACE4_GENERIC_EXECUTE -- defined as combination of
 *      ACE4_READ_ACL
 *      ACE4_READ_ATTRIBUTES
 *      ACE4_EXECUTE
 *      ACE4_SYNCHRONIZE
 */
const ACE4_GENERIC_EXECUTE = 0x001200A0

/*
 * Access Control Entry definition
 */
type Nfsace4 struct {
	Type Acetype4
	Flag Aceflag4
	Access_mask Acemask4
	Who Utf8str_mixed
}

/*
 * Field definitions for the fattr4_mode attribute
 */
const MODE4_SUID = 0x800

/* set group id on execution */
const MODE4_SGID = 0x400

/* save text even after use */
const MODE4_SVTX = 0x200

/* read permission: owner */
const MODE4_RUSR = 0x100

/* write permission: owner */
const MODE4_WUSR = 0x080

/* execute permission: owner */
const MODE4_XUSR = 0x040

/* read permission: group */
const MODE4_RGRP = 0x020

/* write permission: group */
const MODE4_WGRP = 0x010

/* execute permission: group */
const MODE4_XGRP = 0x008

/* read permission: other */
const MODE4_ROTH = 0x004

/* write permission: other */
const MODE4_WOTH = 0x002

/* execute permission: other */
const MODE4_XOTH = 0x001

/*
 * Special data/attribute associated with
 * file types NF4BLK and NF4CHR.
 */
type Specdata4 struct {
	/* major device number */
	Specdata1 Uint32_t
	/* minor device number */
	Specdata2 Uint32_t
}

/*
 * Values for fattr4_fh_expire_type
 */
const FH4_PERSISTENT = 0x00000000

const FH4_NOEXPIRE_WITH_OPEN = 0x00000001

const FH4_VOLATILE_ANY = 0x00000002

const FH4_VOL_MIGRATION = 0x00000004

const FH4_VOL_RENAME = 0x00000008

type Fattr4_supported_attrs = Bitmap4

type Fattr4_type = Nfs_ftype4

type Fattr4_fh_expire_type = Uint32_t

type Fattr4_change = Changeid4

type Fattr4_size = Uint64_t

type Fattr4_link_support = bool

type Fattr4_symlink_support = bool

type Fattr4_named_attr = bool

type Fattr4_fsid = Fsid4

type Fattr4_unique_handles = bool

type Fattr4_lease_time = Uint32_t

type Fattr4_rdattr_error = Nfsstat4

type Fattr4_acl = []Nfsace4

type Fattr4_aclsupport = Uint32_t

type Fattr4_archive = bool

type Fattr4_cansettime = bool

type Fattr4_case_insensitive = bool

type Fattr4_case_preserving = bool

type Fattr4_chown_restricted = bool

type Fattr4_fileid = Uint64_t

type Fattr4_files_avail = Uint64_t

type Fattr4_filehandle = Nfs_fh4

type Fattr4_files_free = Uint64_t

type Fattr4_files_total = Uint64_t

type Fattr4_fs_locations = Fs_locations4

type Fattr4_hidden = bool

type Fattr4_homogeneous = bool

type Fattr4_maxfilesize = Uint64_t

type Fattr4_maxlink = Uint32_t

type Fattr4_maxname = Uint32_t

type Fattr4_maxread = Uint64_t

type Fattr4_maxwrite = Uint64_t

type Fattr4_mimetype = Utf8str_cs

type Fattr4_mode = Mode4

type Fattr4_mounted_on_fileid = Uint64_t

type Fattr4_no_trunc = bool

type Fattr4_numlinks = Uint32_t

type Fattr4_owner = Utf8str_mixed

type Fattr4_owner_group = Utf8str_mixed

type Fattr4_quota_avail_hard = Uint64_t

type Fattr4_quota_avail_soft = Uint64_t

type Fattr4_quota_used = Uint64_t

type Fattr4_rawdev = Specdata4

type Fattr4_space_avail = Uint64_t

type Fattr4_space_free = Uint64_t

type Fattr4_space_total = Uint64_t

type Fattr4_space_used = Uint64_t

type Fattr4_system = bool

type Fattr4_time_access = Nfstime4

type Fattr4_time_access_set = Settime4

type Fattr4_time_backup = Nfstime4

type Fattr4_time_create = Nfstime4

type Fattr4_time_delta = Nfstime4

type Fattr4_time_metadata = Nfstime4

type Fattr4_time_modify = Nfstime4

type Fattr4_time_modify_set = Settime4

/*
 * Mandatory Attributes
 */
const FATTR4_SUPPORTED_ATTRS = 0

const FATTR4_TYPE = 1

const FATTR4_FH_EXPIRE_TYPE = 2

const FATTR4_CHANGE = 3

const FATTR4_SIZE = 4

const FATTR4_LINK_SUPPORT = 5

const FATTR4_SYMLINK_SUPPORT = 6

const FATTR4_NAMED_ATTR = 7

const FATTR4_FSID = 8

const FATTR4_UNIQUE_HANDLES = 9

const FATTR4_LEASE_TIME = 10

const FATTR4_RDATTR_ERROR = 11

const FATTR4_FILEHANDLE = 19

/*
 * Recommended Attributes
 */
const FATTR4_ACL = 12

const FATTR4_ACLSUPPORT = 13

const FATTR4_ARCHIVE = 14

const FATTR4_CANSETTIME = 15

const FATTR4_CASE_INSENSITIVE = 16

const FATTR4_CASE_PRESERVING = 17

const FATTR4_CHOWN_RESTRICTED = 18

const FATTR4_FILEID = 20

const FATTR4_FILES_AVAIL = 21

const FATTR4_FILES_FREE = 22

const FATTR4_FILES_TOTAL = 23

const FATTR4_FS_LOCATIONS = 24

const FATTR4_HIDDEN = 25

const FATTR4_HOMOGENEOUS = 26

const FATTR4_MAXFILESIZE = 27

const FATTR4_MAXLINK = 28

const FATTR4_MAXNAME = 29

const FATTR4_MAXREAD = 30

const FATTR4_MAXWRITE = 31

const FATTR4_MIMETYPE = 32

const FATTR4_MODE = 33

const FATTR4_NO_TRUNC = 34

const FATTR4_NUMLINKS = 35

const FATTR4_OWNER = 36

const FATTR4_OWNER_GROUP = 37

const FATTR4_QUOTA_AVAIL_HARD = 38

const FATTR4_QUOTA_AVAIL_SOFT = 39

const FATTR4_QUOTA_USED = 40

const FATTR4_RAWDEV = 41

const FATTR4_SPACE_AVAIL = 42

const FATTR4_SPACE_FREE = 43

const FATTR4_SPACE_TOTAL = 44

const FATTR4_SPACE_USED = 45

const FATTR4_SYSTEM = 46

const FATTR4_TIME_ACCESS = 47

const FATTR4_TIME_ACCESS_SET = 48

const FATTR4_TIME_BACKUP = 49

const FATTR4_TIME_CREATE = 50

const FATTR4_TIME_DELTA = 51

const FATTR4_TIME_METADATA = 52

const FATTR4_TIME_MODIFY = 53

const FATTR4_TIME_MODIFY_SET = 54

const FATTR4_MOUNTED_ON_FILEID = 55

type Attrlist4 = []byte

/*
 * File attribute container
 */
type Fattr4 struct {
	Attrmask Bitmap4
	Attr_vals Attrlist4
}

/*
 * Change info for the client
 */
type Change_info4 struct {
	Atomic bool
	Before Changeid4
	After Changeid4
}

type Clientaddr4 struct {
	/* see struct rpcb in RFC 1833 */
	R_netid string
	/* universal address */
	R_addr string
}

/*
 * Callback program info as provided by the client
 */
type Cb_client4 struct {
	Cb_program Uint32_t
	Cb_location Clientaddr4
}

/*
 * Stateid
 */
type Stateid4 struct {
	Seqid Uint32_t
	Other [12]byte
}

/*
 * Client ID
 */
type Nfs_client_id4 struct {
	Verifier Verifier4
	Id []byte // bound NFS4_OPAQUE_LIMIT
}

type Open_owner4 struct {
	Clientid Clientid4
	Owner []byte // bound NFS4_OPAQUE_LIMIT
}

type Lock_owner4 struct {
	Clientid Clientid4
	Owner []byte // bound NFS4_OPAQUE_LIMIT
}

type Nfs_lock_type4 int32
const (
	READ_LT Nfs_lock_type4 = 1
	WRITE_LT Nfs_lock_type4 = 2
	/* blocking read */
	READW_LT Nfs_lock_type4 = 3
	/* blocking write */
	WRITEW_LT Nfs_lock_type4 = 4
)

/*
 * ACCESS: Check access permission
 */
const ACCESS4_READ = 0x00000001

const ACCESS4_LOOKUP = 0x00000002

const ACCESS4_MODIFY = 0x00000004

const ACCESS4_EXTEND = 0x00000008

const ACCESS4_DELETE = 0x00000010

const ACCESS4_EXECUTE = 0x00000020

type ACCESS4args struct {
	/* CURRENT_FH: object */
	Access Uint32_t
}

type ACCESS4resok struct {
	Supported Uint32_t
	Access Uint32_t
}

type ACCESS4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *ACCESS4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * CLOSE: Close a file and release share reservations
 */
type CLOSE4args struct {
	/* CURRENT_FH: object */
	Seqid Seqid4
	Open_stateid Stateid4
}

type CLOSE4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Open_stateid() *Stateid4
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * COMMIT: Commit cached data on server to stable storage
 */
type COMMIT4args struct {
	/* CURRENT_FH: file */
	Offset Offset4
	Count Count4
}

type COMMIT4resok struct {
	Writeverf Verifier4
}

type COMMIT4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *COMMIT4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * CREATE: Create a non-regular file
 */
type Createtype4 struct {
	// The union discriminant Type selects among the following arms:
	//   NF4LNK:
	//      Linkdata() *Linktext4
	//   NF4BLK, NF4CHR:
	//      Devdata() *Specdata4
	//   NF4SOCK, NF4FIFO, NF4DIR:
	//      void
	//   default:
	//      void
	Type Nfs_ftype4
	U interface{}
}

type CREATE4args struct {
	/* CURRENT_FH: directory for creation */
	Objtype Createtype4
	Objname Component4
	Createattrs Fattr4
}

type CREATE4resok struct {
	Cinfo Change_info4
	/* attributes set */
	Attrset Bitmap4
}

type CREATE4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *CREATE4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * DELEGPURGE: Purge Delegations Awaiting Recovery
 */
type DELEGPURGE4args struct {
	Clientid Clientid4
}

type DELEGPURGE4res struct {
	Status Nfsstat4
}

/*
 * DELEGRETURN: Return a delegation
 */
type DELEGRETURN4args struct {
	/* CURRENT_FH: delegated file */
	Deleg_stateid Stateid4
}

type DELEGRETURN4res struct {
	Status Nfsstat4
}

/*
 * GETATTR: Get file attributes
 */
type GETATTR4args struct {
	/* CURRENT_FH: directory or file */
	Attr_request Bitmap4
}

type GETATTR4resok struct {
	Obj_attributes Fattr4
}

type GETATTR4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *GETATTR4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * GETFH: Get current filehandle
 */
type GETFH4resok struct {
	Object Nfs_fh4
}

type GETFH4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *GETFH4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * LINK: Create link to an object
 */
type LINK4args struct {
	/* CURRENT_FH: target directory */
	Newname Component4
}

type LINK4resok struct {
	Cinfo Change_info4
}

type LINK4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *LINK4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * For LOCK, transition from open_owner to new lock_owner
 */
type Open_to_lock_owner4 struct {
	Open_seqid Seqid4
	Open_stateid Stateid4
	Lock_seqid Seqid4
	Lock_owner Lock_owner4
}

/*
 * For LOCK, existing lock_owner continues to request file locks
 */
type Exist_lock_owner4 struct {
	Lock_stateid Stateid4
	Lock_seqid Seqid4
}

type Locker4 struct {
	// The union discriminant New_lock_owner selects among the following arms:
	//   true:
	//      Open_owner() *Open_to_lock_owner4
	//   false:
	//      Lock_owner() *Exist_lock_owner4
	New_lock_owner bool
	U interface{}
}

/*
 * LOCK/LOCKT/LOCKU: Record lock management
 */
type LOCK4args struct {
	/* CURRENT_FH: file */
	Locktype Nfs_lock_type4
	Reclaim bool
	Offset Offset4
	Length Length4
	Locker Locker4
}

type LOCK4denied struct {
	Offset Offset4
	Length Length4
	Locktype Nfs_lock_type4
	Owner Lock_owner4
}

type LOCK4resok struct {
	Lock_stateid Stateid4
}

type LOCK4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *LOCK4resok
	//   NFS4ERR_DENIED:
	//      Denied() *LOCK4denied
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

type LOCKT4args struct {
	/* CURRENT_FH: file */
	Locktype Nfs_lock_type4
	Offset Offset4
	Length Length4
	Owner Lock_owner4
}

type LOCKT4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4ERR_DENIED:
	//      Denied() *LOCK4denied
	//   NFS4_OK:
	//      void
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

type LOCKU4args struct {
	/* CURRENT_FH: file */
	Locktype Nfs_lock_type4
	Seqid Seqid4
	Lock_stateid Stateid4
	Offset Offset4
	Length Length4
}

type LOCKU4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Lock_stateid() *Stateid4
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * LOOKUP: Lookup filename
 */
type LOOKUP4args struct {
	/* CURRENT_FH: directory */
	Objname Component4
}

type LOOKUP4res struct {
	/* CURRENT_FH: object */
	Status Nfsstat4
}

/*
 * LOOKUPP: Lookup parent directory
 */
type LOOKUPP4res struct {
	/* CURRENT_FH: directory */
	Status Nfsstat4
}

/*
 * NVERIFY: Verify attributes different
 */
type NVERIFY4args struct {
	/* CURRENT_FH: object */
	Obj_attributes Fattr4
}

type NVERIFY4res struct {
	Status Nfsstat4
}

/*
 * Various definitions for OPEN
 */
type Createmode4 int32
const (
	UNCHECKED4 Createmode4 = 0
	GUARDED4 Createmode4 = 1
	EXCLUSIVE4 Createmode4 = 2
)

type Createhow4 struct {
	// The union discriminant Mode selects among the following arms:
	//   UNCHECKED4, GUARDED4:
	//      Createattrs() *Fattr4
	//   EXCLUSIVE4:
	//      Createverf() *Verifier4
	Mode Createmode4
	U interface{}
}

type Opentype4 int32
const (
	OPEN4_NOCREATE Opentype4 = 0
	OPEN4_CREATE Opentype4 = 1
)

type Openflag4 struct {
	// The union discriminant Opentype selects among the following arms:
	//   OPEN4_CREATE:
	//      How() *Createhow4
	//   default:
	//      void
	Opentype Opentype4
	U interface{}
}

/* Next definitions used for OPEN delegation */
type Limit_by4 int32
const (
	NFS_LIMIT_SIZE Limit_by4 = 1
	NFS_LIMIT_BLOCKS Limit_by4 = 2
)

type Nfs_modified_limit4 struct {
	Num_blocks Uint32_t
	Bytes_per_block Uint32_t
}

type Nfs_space_limit4 struct {
	// The union discriminant Limitby selects among the following arms:
	//   NFS_LIMIT_SIZE:
	//      Filesize() *Uint64_t
	//   NFS_LIMIT_BLOCKS:
	//      Mod_blocks() *Nfs_modified_limit4
	Limitby Limit_by4
	U interface{}
}

/*
 * Share Access and Deny constants for open argument
 */
const OPEN4_SHARE_ACCESS_READ = 0x00000001

const OPEN4_SHARE_ACCESS_WRITE = 0x00000002

const OPEN4_SHARE_ACCESS_BOTH = 0x00000003

const OPEN4_SHARE_DENY_NONE = 0x00000000

const OPEN4_SHARE_DENY_READ = 0x00000001

const OPEN4_SHARE_DENY_WRITE = 0x00000002

const OPEN4_SHARE_DENY_BOTH = 0x00000003

type Open_delegation_type4 int32
const (
	OPEN_DELEGATE_NONE Open_delegation_type4 = 0
	OPEN_DELEGATE_READ Open_delegation_type4 = 1
	OPEN_DELEGATE_WRITE Open_delegation_type4 = 2
)

type Open_claim_type4 int32
const (
	CLAIM_NULL Open_claim_type4 = 0
	CLAIM_PREVIOUS Open_claim_type4 = 1
	CLAIM_DELEGATE_CUR Open_claim_type4 = 2
	CLAIM_DELEGATE_PREV Open_claim_type4 = 3
	/* new to v4.1 */
	CLAIM_FH Open_claim_type4 = 4
	/* new to v4.1 */
	CLAIM_DELEG_CUR_FH Open_claim_type4 = 5
	/* new to v4.1 */
	CLAIM_DELEG_PREV_FH Open_claim_type4 = 6
)

type Open_claim_delegate_cur4 struct {
	Delegate_stateid Stateid4
	File Component4
}

type Open_claim4 struct {
	// The union discriminant Claim selects among the following arms:
	//   CLAIM_NULL:
	//      File() *Component4
	//   CLAIM_PREVIOUS:
	//      Delegate_type() *Open_delegation_type4
	//   CLAIM_DELEGATE_CUR:
	//      Delegate_cur_info() *Open_claim_delegate_cur4
	//   CLAIM_DELEGATE_PREV:
	//      File_delegate_prev() *Component4
	Claim Open_claim_type4
	U interface{}
}

/*
 * OPEN: Open a file, potentially receiving an open delegation
 */
type OPEN4args struct {
	Seqid Seqid4
	Share_access Uint32_t
	Share_deny Uint32_t
	Owner Open_owner4
	Openhow Openflag4
	Claim Open_claim4
}

type Open_read_delegation4 struct {
	/* Stateid for delegation*/
	Stateid Stateid4
	Recall bool
	Permissions Nfsace4
}

type Open_write_delegation4 struct {
	/* Stateid for delegation */
	Stateid Stateid4
	Recall bool
	Space_limit Nfs_space_limit4
	Permissions Nfsace4
}

type Open_delegation4 struct {
	// The union discriminant Delegation_type selects among the following arms:
	//   OPEN_DELEGATE_NONE:
	//      void
	//   OPEN_DELEGATE_READ:
	//      Read() *Open_read_delegation4
	//   OPEN_DELEGATE_WRITE:
	//      Write() *Open_write_delegation4
	Delegation_type Open_delegation_type4
	U interface{}
}

/* Client must confirm open */
const OPEN4_RESULT_CONFIRM = 0x00000002

/* Type of file locking behavior at the server */
const OPEN4_RESULT_LOCKTYPE_POSIX = 0x00000004

type OPEN4resok struct {
	/* Stateid for open */
	Stateid Stateid4
	/* Directory Change Info */
	Cinfo Change_info4
	/* Result flags */
	Rflags Uint32_t
	/* attribute set for create*/
	Attrset Bitmap4
	Delegation Open_delegation4
}

type OPEN4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *OPEN4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * OPENATTR: open named attributes directory
 */
type OPENATTR4args struct {
	/* CURRENT_FH: object */
	Createdir bool
}

type OPENATTR4res struct {
	/* CURRENT_FH: named attr directory */
	Status Nfsstat4
}

/*
 * OPEN_CONFIRM: confirm the open
 */
type OPEN_CONFIRM4args struct {
	/* CURRENT_FH: opened file */
	Open_stateid Stateid4
	Seqid Seqid4
}

type OPEN_CONFIRM4resok struct {
	Open_stateid Stateid4
}

type OPEN_CONFIRM4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *OPEN_CONFIRM4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * OPEN_DOWNGRADE: downgrade the access/deny for a file
 */
type OPEN_DOWNGRADE4args struct {
	/* CURRENT_FH: opened file */
	Open_stateid Stateid4
	Seqid Seqid4
	Share_access Uint32_t
	Share_deny Uint32_t
}

type OPEN_DOWNGRADE4resok struct {
	Open_stateid Stateid4
}

type OPEN_DOWNGRADE4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *OPEN_DOWNGRADE4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * PUTFH: Set current filehandle
 */
type PUTFH4args struct {
	Object Nfs_fh4
}

type PUTFH4res struct {
	/* CURRENT_FH: */
	Status Nfsstat4
}

/*
 * PUTPUBFH: Set public filehandle
 */
type PUTPUBFH4res struct {
	/* CURRENT_FH: public fh */
	Status Nfsstat4
}

/*
 * PUTROOTFH: Set root filehandle
 */
type PUTROOTFH4res struct {
	/* CURRENT_FH: root fh */
	Status Nfsstat4
}

/*
 * READ: Read from file
 */
type READ4args struct {
	/* CURRENT_FH: file */
	Stateid Stateid4
	Offset Offset4
	Count Count4
}

type READ4resok struct {
	Eof bool
	Data []byte
}

type READ4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *READ4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * READDIR: Read directory
 */
type READDIR4args struct {
	/* CURRENT_FH: directory */
	Cookie Nfs_cookie4
	Cookieverf Verifier4
	Dircount Count4
	Maxcount Count4
	Attr_request Bitmap4
}

type Entry4 struct {
	Cookie Nfs_cookie4
	Name Component4
	Attrs Fattr4
	Nextentry *Entry4
}

type Dirlist4 struct {
	Entries *Entry4
	Eof bool
}

type READDIR4resok struct {
	Cookieverf Verifier4
	Reply Dirlist4
}

type READDIR4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *READDIR4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * READLINK: Read symbolic link
 */
type READLINK4resok struct {
	Link Linktext4
}

type READLINK4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *READLINK4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * REMOVE: Remove filesystem object
 */
type REMOVE4args struct {
	/* CURRENT_FH: directory */
	Target Component4
}

type REMOVE4resok struct {
	Cinfo Change_info4
}

type REMOVE4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *REMOVE4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * RENAME: Rename directory entry
 */
type RENAME4args struct {
	/* SAVED_FH: source directory */
	Oldname Component4
	Newname Component4
}

type RENAME4resok struct {
	Source_cinfo Change_info4
	Target_cinfo Change_info4
}

type RENAME4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *RENAME4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * RENEW: Renew a Lease
 */
type RENEW4args struct {
	Clientid Clientid4
}

type RENEW4res struct {
	Status Nfsstat4
}

type RESTOREFH4res struct {
	/* CURRENT_FH: value of saved fh */
	Status Nfsstat4
}

/*
 * SAVEFH: Save current filehandle
 */
type SAVEFH4res struct {
	/* SAVED_FH: value of current fh */
	Status Nfsstat4
}

/*
 * SECINFO: Obtain Available Security Mechanisms
 */
type SECINFO4args struct {
	Name Component4
}

type Rpc_gss_svc_t int32
const (
	RPC_GSS_SVC_NONE Rpc_gss_svc_t = 1
	RPC_GSS_SVC_INTEGRITY Rpc_gss_svc_t = 2
	RPC_GSS_SVC_PRIVACY Rpc_gss_svc_t = 3
)

type Rpcsec_gss_info struct {
	Oid Sec_oid4
	Qop Qop4
	Service Rpc_gss_svc_t
}

const RPCSEC_GSS = 6

type Secinfo4 struct {
	// The union discriminant Flavor selects among the following arms:
	//   RPCSEC_GSS:
	//      Flavor_info() *Rpcsec_gss_info
	//   default:
	//      void
	Flavor Uint32_t
	U interface{}
}

type SECINFO4resok = []Secinfo4

type SECINFO4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *SECINFO4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * SETATTR: Set attributes
 */
type SETATTR4args struct {
	/* CURRENT_FH: target object */
	Stateid Stateid4
	Obj_attributes Fattr4
}

type SETATTR4res struct {
	Status Nfsstat4
	Attrsset Bitmap4
}

/*
 * SETCLIENTID
 */
type SETCLIENTID4args struct {
	Client Nfs_client_id4
	Callback Cb_client4
	Callback_ident Uint32_t
}

type SETCLIENTID4resok struct {
	Clientid Clientid4
	Setclientid_confirm Verifier4
}

type SETCLIENTID4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *SETCLIENTID4resok
	//   NFS4ERR_CLID_INUSE:
	//      Client_using() *Clientaddr4
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

type SETCLIENTID_CONFIRM4args struct {
	Clientid Clientid4
	Setclientid_confirm Verifier4
}

type SETCLIENTID_CONFIRM4res struct {
	Status Nfsstat4
}

/*
 * VERIFY: Verify attributes same
 */
type VERIFY4args struct {
	/* CURRENT_FH: object */
	Obj_attributes Fattr4
}

type VERIFY4res struct {
	Status Nfsstat4
}

/*
 * WRITE: Write to file
 */
type Stable_how4 int32
const (
	UNSTABLE4 Stable_how4 = 0
	DATA_SYNC4 Stable_how4 = 1
	FILE_SYNC4 Stable_how4 = 2
)

type WRITE4args struct {
	/* CURRENT_FH: file */
	Stateid Stateid4
	Offset Offset4
	Stable Stable_how4
	Data []byte
}

type WRITE4resok struct {
	Count Count4
	Committed Stable_how4
	Writeverf Verifier4
}

type WRITE4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *WRITE4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * RELEASE_LOCKOWNER: Notify server to release lockowner
 */
type RELEASE_LOCKOWNER4args struct {
	Lock_owner Lock_owner4
}

type RELEASE_LOCKOWNER4res struct {
	Status Nfsstat4
}

type Callback_sec_parms4 struct {
	// The union discriminant Cb_secflavor selects among the following arms:
	//   AUTH_NONE:
	//      void
	//   AUTH_SYS:
	//      Cbsp_sys_cred() *Authsys_parms
	Cb_secflavor Uint32_t
	U interface{}
}

/*
 * CREATE_SESSION
 */
type Channel_attrs4 struct {
	Ca_headerpadsize Count4
	Ca_maxrequestsize Count4
	Ca_maxresponsesize Count4
	Ca_maxresponsesize_cached Count4
	Ca_maxoperations Count4
	Ca_maxrequests Count4
	Ca_rdma_ird []Uint32_t // bound 1
}

const CREATE_SESSION4_FLAG_PERSIST = 0x00000001

const CREATE_SESSION4_FLAG_CONN_BACK_CHAN = 0x00000002

const CREATE_SESSION4_FLAG_CONN_RDMA = 0x00000004

type CREATE_SESSION4args struct {
	Csa_clientid Clientid4
	Csa_sequence Sequenceid4
	Csa_flags Uint32_t
	Csa_fore_chan_attrs Channel_attrs4
	Csa_back_chan_attrs Channel_attrs4
	Csa_cb_program Uint32_t
	Csa_sec_parms []Callback_sec_parms4
}

type CREATE_SESSION4resok struct {
	Csr_sessionid Sessionid4
	Csr_sequence Sequenceid4
	Csr_flags Uint32_t
	Csr_fore_chan_attrs Channel_attrs4
	Csr_back_chan_attrs Channel_attrs4
}

type CREATE_SESSION4res struct {
	// The union discriminant Csr_status selects among the following arms:
	//   NFS4_OK:
	//      Csr_resok4() *CREATE_SESSION4resok
	//   default:
	//      void
	Csr_status Nfsstat4
	U interface{}
}

/*
 * DESTROY_SESSION
 */
type DESTROY_SESSION4args struct {
	Dsa_sessionid Sessionid4
}

type DESTROY_SESSION4res struct {
	Dsr_status Nfsstat4
}

/*
 * FREE_STATEID
 */
type FREE_STATEID4args struct {
	Fsa_stateid Stateid4
}

type FREE_STATEID4res struct {
	Fsr_status Nfsstat4
}

/*
 * GET_DIR_DELEGATION
 */
type Attr_notice4 = Nfstime4

type GET_DIR_DELEGATION4args struct {
	Gdda_signal_deleg_avail bool
	Gdda_notification_types Bitmap4
	Gdda_child_attr_delay Attr_notice4
	Gdda_dir_attr_delay Attr_notice4
	Gdda_child_attributes Bitmap4
	Gdda_dir_attributes Bitmap4
}

type GET_DIR_DELEGATION4resok struct {
	Gddr_cookieverf Verifier4
	Gddr_stateid Stateid4
	Gddr_notification Bitmap4
	Gddr_child_attributes Bitmap4
	Gddr_dir_attributes Bitmap4
}

type Gddrnf4_status int32
const (
	GDD4_OK Gddrnf4_status = 0
	GDD4_UNAVAIL Gddrnf4_status = 1
)

type GET_DIR_DELEGATION4res_non_fatal struct {
	// The union discriminant Gddrnf_status selects among the following arms:
	//   GDD4_OK:
	//      Gddrnf_resok4() *GET_DIR_DELEGATION4resok
	//   GDD4_UNAVAIL:
	//      Gddrnf_will_signal_deleg_avail() *bool
	Gddrnf_status Gddrnf4_status
	U interface{}
}

type GET_DIR_DELEGATION4res struct {
	// The union discriminant Gddr_status selects among the following arms:
	//   NFS4_OK:
	//      Gddr_res_non_fatal4() *GET_DIR_DELEGATION4res_non_fatal
	//   default:
	//      void
	Gddr_status Nfsstat4
	U interface{}
}

/*
 * GETDEVICEINFO
 */
type GETDEVICEINFO4args struct {
	Gdia_device_id Deviceid4
	Gdia_layout_type Layouttype4
	Gdia_maxcount Count4
	Gdia_notify_types Bitmap4
}

type GETDEVICEINFO4resok struct {
	Gdir_device_addr Device_addr4
	Gdir_notification Bitmap4
}

type GETDEVICEINFO4res struct {
	// The union discriminant Gdir_status selects among the following arms:
	//   NFS4_OK:
	//      Gdir_resok4() *GETDEVICEINFO4resok
	//   NFS4ERR_TOOSMALL:
	//      Gdir_mincount() *Count4
	//   default:
	//      void
	Gdir_status Nfsstat4
	U interface{}
}

/*
 * GETDEVICELIST
 */
type GETDEVICELIST4args struct {
	Gdla_layout_type Layouttype4
	Gdla_maxdevices Count4
	Gdla_cookie Nfs_cookie4
	Gdla_cookieverf Verifier4
}

type GETDEVICELIST4resok struct {
	Gdlr_cookie Nfs_cookie4
	Gdlr_cookieverf Verifier4
	Gdlr_deviceid_list []Deviceid4
	Gdlr_eof bool
}

type GETDEVICELIST4res struct {
	// The union discriminant Gdlr_status selects among the following arms:
	//   NFS4_OK:
	//      Gdlr_resok4() *GETDEVICELIST4resok
	//   default:
	//      void
	Gdlr_status Nfsstat4
	U interface{}
}

/*
 * LAYOUTCOMMIT
 */
type Newtime4 struct {
	// The union discriminant Nt_timechanged selects among the following arms:
	//   true:
	//      Nt_time() *Nfstime4
	//   false:
	//      void
	Nt_timechanged bool
	U interface{}
}

type Newoffset4 struct {
	// The union discriminant No_newoffset selects among the following arms:
	//   true:
	//      No_offset() *Offset4
	//   false:
	//      void
	No_newoffset bool
	U interface{}
}

type LAYOUTCOMMIT4args struct {
	Loca_offset Offset4
	Loca_length Length4
	Loca_reclaim bool
	Loca_stateid Stateid4
	Loca_last_write_offset Newoffset4
	Loca_time_modify Newtime4
	Loca_layoutupdate Layoutupdate4
}

type Newsize4 struct {
	// The union discriminant Ns_sizechanged selects among the following arms:
	//   true:
	//      Ns_size() *Length4
	//   false:
	//      void
	Ns_sizechanged bool
	U interface{}
}

type LAYOUTCOMMIT4resok struct {
	Locr_newsize Newsize4
}

type LAYOUTCOMMIT4res struct {
	// The union discriminant Locr_status selects among the following arms:
	//   NFS4_OK:
	//      Locr_resok4() *LAYOUTCOMMIT4resok
	//   default:
	//      void
	Locr_status Nfsstat4
	U interface{}
}

/*
 * LAYOUTGET
 */
type LAYOUTGET4args struct {
	Loga_signal_layout_avail bool
	Loga_layout_type Layouttype4
	Loga_iomode Layoutiomode4
	Loga_offset Offset4
	Loga_length Length4
	Loga_minlength Length4
	Loga_stateid Stateid4
	Loga_maxcount Count4
}

type LAYOUTGET4resok struct {
	Logr_return_on_close bool
	Logr_stateid Stateid4
	Logr_layout []Layout4
}

type LAYOUTGET4res struct {
	// The union discriminant Logr_status selects among the following arms:
	//   NFS4_OK:
	//      Logr_resok4() *LAYOUTGET4resok
	//   NFS4ERR_LAYOUTTRYLATER:
	//      Logr_will_signal_layout_avail() *bool
	//   default:
	//      void
	Logr_status Nfsstat4
	U interface{}
}

/*
 * LAYOUTRETURN
 */
const LAYOUT4_RET_REC_FILE = 1

const LAYOUT4_RET_REC_FSID = 2

const LAYOUT4_RET_REC_ALL = 3

type Layoutreturn_type4 int32
const (
	LAYOUTRETURN4_FILE Layoutreturn_type4 = Layoutreturn_type4(LAYOUT4_RET_REC_FILE)
	LAYOUTRETURN4_FSID Layoutreturn_type4 = Layoutreturn_type4(LAYOUT4_RET_REC_FSID)
	LAYOUTRETURN4_ALL Layoutreturn_type4 = Layoutreturn_type4(LAYOUT4_RET_REC_ALL)
)

type Layoutreturn_file4 struct {
	Lrf_offset Offset4
	Lrf_length Length4
	Lrf_stateid Stateid4
	Lrf_body []byte
}

type Layoutreturn4 struct {
	// The union discriminant Lr_returntype selects among the following arms:
	//   LAYOUTRETURN4_FILE:
	//      Lr_layout() *Layoutreturn_file4
	//   default:
	//      void
	Lr_returntype Layoutreturn_type4
	U interface{}
}

type LAYOUTRETURN4args struct {
	Lora_reclaim bool
	Lora_layout_type Layouttype4
	Lora_iomode Layoutiomode4
	Lora_layoutreturn Layoutreturn4
}

type Layoutreturn_stateid struct {
	// The union discriminant Lrs_present selects among the following arms:
	//   true:
	//      Lrs_stateid() *Stateid4
	//   false:
	//      void
	Lrs_present bool
	U interface{}
}

type LAYOUTRETURN4res struct {
	// The union discriminant Lorr_status selects among the following arms:
	//   NFS4_OK:
	//      Lorr_stateid() *Layoutreturn_stateid
	//   default:
	//      void
	Lorr_status Nfsstat4
	U interface{}
}

/*
 * SECINFO_NO_NAME
 */
type Secinfo_style4 int32
const (
	SECINFO_STYLE4_CURRENT_FH Secinfo_style4 = 0
	SECINFO_STYLE4_PARENT Secinfo_style4 = 1
)

type SECINFO_NO_NAME4args = Secinfo_style4

type SECINFO_NO_NAME4res = SECINFO4res

/*
 * SEQUENCE
 */
type SEQUENCE4args struct {
	Sa_sessionid Sessionid4
	Sa_sequenceid Sequenceid4
	Sa_slotid Slotid4
	Sa_highest_slotid Slotid4
	Sa_cachethis bool
}

const SEQ4_STATUS_CB_PATH_DOWN = 0x00000001

const SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRING = 0x00000002

const SEQ4_STATUS_CB_GSS_CONTEXTS_EXPIRED = 0x00000004

const SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED = 0x00000008

const SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED = 0x00000010

const SEQ4_STATUS_ADMIN_STATE_REVOKED = 0x00000020

const SEQ4_STATUS_RECALLABLE_STATE_REVOKED = 0x00000040

const SEQ4_STATUS_LEASE_MOVED = 0x00000080

const SEQ4_STATUS_RESTART_RECLAIM_NEEDED = 0x00000100

const SEQ4_STATUS_CB_PATH_DOWN_SESSION = 0x00000200

const SEQ4_STATUS_BACKCHANNEL_FAULT = 0x00000400

const SEQ4_STATUS_DEVID_CHANGED = 0x00000800

const SEQ4_STATUS_DEVID_DELETED = 0x00001000

type SEQUENCE4resok struct {
	Sr_sessionid Sessionid4
	Sr_sequenceid Sequenceid4
	Sr_slotid Slotid4
	Sr_highest_slotid Slotid4
	Sr_target_highest_slotid Slotid4
	Sr_status_flags Uint32_t
}

type SEQUENCE4res struct {
	// The union discriminant Sr_status selects among the following arms:
	//   NFS4_OK:
	//      Sr_resok4() *SEQUENCE4resok
	//   default:
	//      void
	Sr_status Nfsstat4
	U interface{}
}

/*
 * SET_SSV
 */
type Ssa_digest_input4 struct {
	Sdi_seqargs SEQUENCE4args
}

type SET_SSV4args struct {
	Ssa_ssv []byte
	Ssa_digest []byte
}

type Ssr_digest_input4 struct {
	Sdi_seqres SEQUENCE4res
}

type SET_SSV4resok struct {
	Ssr_digest []byte
}

type SET_SSV4res struct {
	// The union discriminant Ssr_status selects among the following arms:
	//   NFS4_OK:
	//      Ssr_resok4() *SET_SSV4resok
	//   default:
	//      void
	Ssr_status Nfsstat4
	U interface{}
}

/*
 * TEST_STATEID
 */
type TEST_STATEID4args struct {
	Ts_stateids []Stateid4
}

type TEST_STATEID4resok struct {
	Tsr_status_codes []Nfsstat4
}

type TEST_STATEID4res struct {
	// The union discriminant Tsr_status selects among the following arms:
	//   NFS4_OK:
	//      Tsr_resok4() *TEST_STATEID4resok
	//   default:
	//      void
	Tsr_status Nfsstat4
	U interface{}
}

/*
 * WANT_DELEGATION
 */
type Deleg_claim4 struct {
	// The union discriminant Dc_claim selects among the following arms:
	//   CLAIM_FH:
	//      void
	//   CLAIM_DELEG_PREV_FH:
	//      void
	//   CLAIM_PREVIOUS:
	//      Dc_delegate_type() *Open_delegation_type4
	Dc_claim Open_claim_type4
	U interface{}
}

type WANT_DELEGATION4args struct {
	Wda_want Uint32_t
	Wda_claim Deleg_claim4
}

type WANT_DELEGATION4res struct {
	// The union discriminant Wdr_status selects among the following arms:
	//   NFS4_OK:
	//      Wdr_resok4() *Open_delegation4
	//   default:
	//      void
	Wdr_status Nfsstat4
	U interface{}
}

/*
 * DESTROY_CLIENTID
 */
type DESTROY_CLIENTID4args struct {
	Dca_clientid Clientid4
}

type DESTROY_CLIENTID4res struct {
	Dcr_status Nfsstat4
}

/*
 * RECLAIM_COMPLETE
 */
type RECLAIM_COMPLETE4args struct {
	Rca_one_fs bool
}

type RECLAIM_COMPLETE4res struct {
	Rcr_status Nfsstat4
}

/*
 * ILLEGAL: Response for illegal operation numbers
 */
type ILLEGAL4res struct {
	Status Nfsstat4
}

type Nfs_opnum4 int32
const (
	OP_ACCESS Nfs_opnum4 = 3
	OP_CLOSE Nfs_opnum4 = 4
	OP_COMMIT Nfs_opnum4 = 5
	OP_CREATE Nfs_opnum4 = 6
	OP_DELEGPURGE Nfs_opnum4 = 7
	OP_DELEGRETURN Nfs_opnum4 = 8
	OP_GETATTR Nfs_opnum4 = 9
	OP_GETFH Nfs_opnum4 = 10
	OP_LINK Nfs_opnum4 = 11
	OP_LOCK Nfs_opnum4 = 12
	OP_LOCKT Nfs_opnum4 = 13
	OP_LOCKU Nfs_opnum4 = 14
	OP_LOOKUP Nfs_opnum4 = 15
	OP_LOOKUPP Nfs_opnum4 = 16
	OP_NVERIFY Nfs_opnum4 = 17
	OP_OPEN Nfs_opnum4 = 18
	OP_OPENATTR Nfs_opnum4 = 19
	OP_OPEN_CONFIRM Nfs_opnum4 = 20
	OP_OPEN_DOWNGRADE Nfs_opnum4 = 21
	OP_PUTFH Nfs_opnum4 = 22
	OP_PUTPUBFH Nfs_opnum4 = 23
	OP_PUTROOTFH Nfs_opnum4 = 24
	OP_READ Nfs_opnum4 = 25
	OP_READDIR Nfs_opnum4 = 26
	OP_READLINK Nfs_opnum4 = 27
	OP_REMOVE Nfs_opnum4 = 28
	OP_RENAME Nfs_opnum4 = 29
	OP_RENEW Nfs_opnum4 = 30
	OP_RESTOREFH Nfs_opnum4 = 31
	OP_SAVEFH Nfs_opnum4 = 32
	OP_SECINFO Nfs_opnum4 = 33
	OP_SETATTR Nfs_opnum4 = 34
	OP_SETCLIENTID Nfs_opnum4 = 35
	OP_SETCLIENTID_CONFIRM Nfs_opnum4 = 36
	OP_VERIFY Nfs_opnum4 = 37
	OP_WRITE Nfs_opnum4 = 38
	OP_RELEASE_LOCKOWNER Nfs_opnum4 = 39
	OP_CREATE_SESSION Nfs_opnum4 = 43
	OP_DESTROY_SESSION Nfs_opnum4 = 44
	OP_FREE_STATEID Nfs_opnum4 = 45
	OP_GET_DIR_DELEGATION Nfs_opnum4 = 46
	OP_GETDEVICEINFO Nfs_opnum4 = 47
	OP_GETDEVICELIST Nfs_opnum4 = 48
	OP_LAYOUTCOMMIT Nfs_opnum4 = 49
	OP_LAYOUTGET Nfs_opnum4 = 50
	OP_LAYOUTRETURN Nfs_opnum4 = 51
	OP_SECINFO_NO_NAME Nfs_opnum4 = 52
	OP_SEQUENCE Nfs_opnum4 = 53
	OP_SET_SSV Nfs_opnum4 = 54
	OP_TEST_STATEID Nfs_opnum4 = 55
	OP_WANT_DELEGATION Nfs_opnum4 = 56
	OP_DESTROY_CLIENTID Nfs_opnum4 = 57
	OP_RECLAIM_COMPLETE Nfs_opnum4 = 58
	OP_ILLEGAL Nfs_opnum4 = 10044
)

type Nfs_argop4 struct {
	// The union discriminant Argop selects among the following arms:
	//   OP_ACCESS:
	//      Opaccess() *ACCESS4args
	//   OP_CLOSE:
	//      Opclose() *CLOSE4args
	//   OP_COMMIT:
	//      Opcommit() *COMMIT4args
	//   OP_CREATE:
	//      Opcreate() *CREATE4args
	//   OP_DELEGPURGE:
	//      Opdelegpurge() *DELEGPURGE4args
	//   OP_DELEGRETURN:
	//      Opdelegreturn() *DELEGRETURN4args
	//   OP_GETATTR:
	//      Opgetattr() *GETATTR4args
	//   OP_GETFH:
	//      void
	//   OP_LINK:
	//      Oplink() *LINK4args
	//   OP_LOCK:
	//      Oplock() *LOCK4args
	//   OP_LOCKT:
	//      Oplockt() *LOCKT4args
	//   OP_LOCKU:
	//      Oplocku() *LOCKU4args
	//   OP_LOOKUP:
	//      Oplookup() *LOOKUP4args
	//   OP_LOOKUPP:
	//      void
	//   OP_NVERIFY:
	//      Opnverify() *NVERIFY4args
	//   OP_OPEN:
	//      Opopen() *OPEN4args
	//   OP_OPENATTR:
	//      Opopenattr() *OPENATTR4args
	//   OP_OPEN_CONFIRM:
	//      Opopen_confirm() *OPEN_CONFIRM4args
	//   OP_OPEN_DOWNGRADE:
	//      Opopen_downgrade() *OPEN_DOWNGRADE4args
	//   OP_PUTFH:
	//      Opputfh() *PUTFH4args
	//   OP_PUTPUBFH:
	//      void
	//   OP_PUTROOTFH:
	//      void
	//   OP_READ:
	//      Opread() *READ4args
	//   OP_READDIR:
	//      Opreaddir() *READDIR4args
	//   OP_READLINK:
	//      void
	//   OP_REMOVE:
	//      Opremove() *REMOVE4args
	//   OP_RENAME:
	//      Oprename() *RENAME4args
	//   OP_RENEW:
	//      Oprenew() *RENEW4args
	//   OP_RESTOREFH:
	//      void
	//   OP_SAVEFH:
	//      void
	//   OP_SECINFO:
	//      Opsecinfo() *SECINFO4args
	//   OP_SETATTR:
	//      Opsetattr() *SETATTR4args
	//   OP_SETCLIENTID:
	//      Opsetclientid() *SETCLIENTID4args
	//   OP_SETCLIENTID_CONFIRM:
	//      Opsetclientid_confirm() *SETCLIENTID_CONFIRM4args
	//   OP_VERIFY:
	//      Opverify() *VERIFY4args
	//   OP_WRITE:
	//      Opwrite() *WRITE4args
	//   OP_RELEASE_LOCKOWNER:
	//      Oprelease_lockowner() *RELEASE_LOCKOWNER4args
	//   OP_CREATE_SESSION:
	//      Opcreatesession() *CREATE_SESSION4args
	//   OP_DESTROY_SESSION:
	//      Opdestroysession() *DESTROY_SESSION4args
	//   OP_FREE_STATEID:
	//      Opfreestateid() *FREE_STATEID4args
	//   OP_GET_DIR_DELEGATION:
	//      Opgetdirdelegation() *GET_DIR_DELEGATION4args
	//   OP_GETDEVICEINFO:
	//      Opgetdeviceinfo() *GETDEVICEINFO4args
	//   OP_GETDEVICELIST:
	//      Opgetdevicelist() *GETDEVICELIST4args
	//   OP_LAYOUTCOMMIT:
	//      Oplayoutcommit() *LAYOUTCOMMIT4args
	//   OP_LAYOUTGET:
	//      Oplayoutget() *LAYOUTGET4args
	//   OP_LAYOUTRETURN:
	//      Oplayoutreturn() *LAYOUTRETURN4args
	//   OP_SECINFO_NO_NAME:
	//      Opsecinfononame() *SECINFO_NO_NAME4args
	//   OP_SEQUENCE:
	//      Opsequence() *SEQUENCE4args
	//   OP_SET_SSV:
	//      Opsetssv() *SET_SSV4args
	//   OP_TEST_STATEID:
	//      Opteststateid() *TEST_STATEID4args
	//   OP_WANT_DELEGATION:
	//      Opwantdelegation() *WANT_DELEGATION4args
	//   OP_DESTROY_CLIENTID:
	//      Opdestroyclientid() *DESTROY_CLIENTID4args
	//   OP_RECLAIM_COMPLETE:
	//      Opreclaimcomplete() *RECLAIM_COMPLETE4args
	//   OP_ILLEGAL:
	//      void
	Argop Nfs_opnum4
	U interface{}
}

type Nfs_resop4 struct {
	// The union discriminant Resop selects among the following arms:
	//   OP_ACCESS:
	//      Opaccess() *ACCESS4res
	//   OP_CLOSE:
	//      Opclose() *CLOSE4res
	//   OP_COMMIT:
	//      Opcommit() *COMMIT4res
	//   OP_CREATE:
	//      Opcreate() *CREATE4res
	//   OP_DELEGPURGE:
	//      Opdelegpurge() *DELEGPURGE4res
	//   OP_DELEGRETURN:
	//      Opdelegreturn() *DELEGRETURN4res
	//   OP_GETATTR:
	//      Opgetattr() *GETATTR4res
	//   OP_GETFH:
	//      Opgetfh() *GETFH4res
	//   OP_LINK:
	//      Oplink() *LINK4res
	//   OP_LOCK:
	//      Oplock() *LOCK4res
	//   OP_LOCKT:
	//      Oplockt() *LOCKT4res
	//   OP_LOCKU:
	//      Oplocku() *LOCKU4res
	//   OP_LOOKUP:
	//      Oplookup() *LOOKUP4res
	//   OP_LOOKUPP:
	//      Oplookupp() *LOOKUPP4res
	//   OP_NVERIFY:
	//      Opnverify() *NVERIFY4res
	//   OP_OPEN:
	//      Opopen() *OPEN4res
	//   OP_OPENATTR:
	//      Opopenattr() *OPENATTR4res
	//   OP_OPEN_CONFIRM:
	//      Opopen_confirm() *OPEN_CONFIRM4res
	//   OP_OPEN_DOWNGRADE:
	//      Opopen_downgrade() *OPEN_DOWNGRADE4res
	//   OP_PUTFH:
	//      Opputfh() *PUTFH4res
	//   OP_PUTPUBFH:
	//      Opputpubfh() *PUTPUBFH4res
	//   OP_PUTROOTFH:
	//      Opputrootfh() *PUTROOTFH4res
	//   OP_READ:
	//      Opread() *READ4res
	//   OP_READDIR:
	//      Opreaddir() *READDIR4res
	//   OP_READLINK:
	//      Opreadlink() *READLINK4res
	//   OP_REMOVE:
	//      Opremove() *REMOVE4res
	//   OP_RENAME:
	//      Oprename() *RENAME4res
	//   OP_RENEW:
	//      Oprenew() *RENEW4res
	//   OP_RESTOREFH:
	//      Oprestorefh() *RESTOREFH4res
	//   OP_SAVEFH:
	//      Opsavefh() *SAVEFH4res
	//   OP_SECINFO:
	//      Opsecinfo() *SECINFO4res
	//   OP_SETATTR:
	//      Opsetattr() *SETATTR4res
	//   OP_SETCLIENTID:
	//      Opsetclientid() *SETCLIENTID4res
	//   OP_SETCLIENTID_CONFIRM:
	//      Opsetclientid_confirm() *SETCLIENTID_CONFIRM4res
	//   OP_VERIFY:
	//      Opverify() *VERIFY4res
	//   OP_WRITE:
	//      Opwrite() *WRITE4res
	//   OP_RELEASE_LOCKOWNER:
	//      Oprelease_lockowner() *RELEASE_LOCKOWNER4res
	//   OP_CREATE_SESSION:
	//      Opcreatesession() *CREATE_SESSION4res
	//   OP_DESTROY_SESSION:
	//      Opdestroysession() *DESTROY_SESSION4res
	//   OP_FREE_STATEID:
	//      Opfreestateid() *FREE_STATEID4res
	//   OP_GET_DIR_DELEGATION:
	//      Opgetdirdelegation() *GET_DIR_DELEGATION4res
	//   OP_GETDEVICEINFO:
	//      Opgetdeviceinfo() *GETDEVICEINFO4res
	//   OP_GETDEVICELIST:
	//      Opgetdevicelist() *GETDEVICELIST4res
	//   OP_LAYOUTCOMMIT:
	//      Oplayoutcommit() *LAYOUTCOMMIT4res
	//   OP_LAYOUTGET:
	//      Oplayoutget() *LAYOUTGET4res
	//   OP_LAYOUTRETURN:
	//      Oplayoutreturn() *LAYOUTRETURN4res
	//   OP_SECINFO_NO_NAME:
	//      Opsecinfononame() *SECINFO_NO_NAME4res
	//   OP_SEQUENCE:
	//      Opsequence() *SEQUENCE4res
	//   OP_SET_SSV:
	//      Opsetssv() *SET_SSV4res
	//   OP_TEST_STATEID:
	//      Opteststateid() *TEST_STATEID4res
	//   OP_WANT_DELEGATION:
	//      Opwantdelegation() *WANT_DELEGATION4res
	//   OP_DESTROY_CLIENTID:
	//      Opdestroyclientid() *DESTROY_CLIENTID4res
	//   OP_RECLAIM_COMPLETE:
	//      Opreclaimcomplete() *RECLAIM_COMPLETE4res
	//   OP_ILLEGAL:
	//      Opillegal() *ILLEGAL4res
	Resop Nfs_opnum4
	U interface{}
}

type COMPOUND4args struct {
	Tag Utf8str_cs
	Minorversion Uint32_t
	Argarray []Nfs_argop4
}

type COMPOUND4res struct {
	Status Nfsstat4
	Tag Utf8str_cs
	Resarray []Nfs_resop4
}

type NFS_V4 interface {
	NFSPROC4_NULL()
	NFSPROC4_COMPOUND(COMPOUND4args) COMPOUND4res
}

/*
 * CB_GETATTR: Get Current Attributes
 */
type CB_GETATTR4args struct {
	Fh Nfs_fh4
	Attr_request Bitmap4
}

type CB_GETATTR4resok struct {
	Obj_attributes Fattr4
}

type CB_GETATTR4res struct {
	// The union discriminant Status selects among the following arms:
	//   NFS4_OK:
	//      Resok4() *CB_GETATTR4resok
	//   default:
	//      void
	Status Nfsstat4
	U interface{}
}

/*
 * CB_RECALL: Recall an Open Delegation
 */
type CB_RECALL4args struct {
	Stateid Stateid4
	Truncate bool
	Fh Nfs_fh4
}

type CB_RECALL4res struct {
	Status Nfsstat4
}

/*
 * CB_ILLEGAL: Response for illegal operation numbers
 */
type CB_ILLEGAL4res struct {
	Status Nfsstat4
}

/*
 * Various definitions for CB_COMPOUND
 */
type Nfs_cb_opnum4 int32
const (
	OP_CB_GETATTR Nfs_cb_opnum4 = 3
	OP_CB_RECALL Nfs_cb_opnum4 = 4
	OP_CB_ILLEGAL Nfs_cb_opnum4 = 10044
)

type Nfs_cb_argop4 struct {
	// The union discriminant Argop selects among the following arms:
	//   OP_CB_GETATTR:
	//      Opcbgetattr() *CB_GETATTR4args
	//   OP_CB_RECALL:
	//      Opcbrecall() *CB_RECALL4args
	//   OP_CB_ILLEGAL:
	//      void
	Argop uint32
	U interface{}
}

type Nfs_cb_resop4 struct {
	// The union discriminant Resop selects among the following arms:
	//   OP_CB_GETATTR:
	//      Opcbgetattr() *CB_GETATTR4res
	//   OP_CB_RECALL:
	//      Opcbrecall() *CB_RECALL4res
	//   OP_CB_ILLEGAL:
	//      Opcbillegal() *CB_ILLEGAL4res
	Resop uint32
	U interface{}
}

type CB_COMPOUND4args struct {
	Tag Utf8str_cs
	Minorversion Uint32_t
	Callback_ident Uint32_t
	Argarray []Nfs_cb_argop4
}

type CB_COMPOUND4res struct {
	Status Nfsstat4
	Tag Utf8str_cs
	Resarray []Nfs_cb_resop4
}

type NFS_CB interface {
	CB_NULL()
	CB_COMPOUND(CB_COMPOUND4args) CB_COMPOUND4res
}

//
// Helper types and generated marshaling functions
//

var _XdrNames_Nfs_ftype4 = map[int32]string{
	int32(NF4REG): "NF4REG",
	int32(NF4DIR): "NF4DIR",
	int32(NF4BLK): "NF4BLK",
	int32(NF4CHR): "NF4CHR",
	int32(NF4LNK): "NF4LNK",
	int32(NF4SOCK): "NF4SOCK",
	int32(NF4FIFO): "NF4FIFO",
	int32(NF4ATTRDIR): "NF4ATTRDIR",
	int32(NF4NAMEDATTR): "NF4NAMEDATTR",
}
var _XdrValues_Nfs_ftype4 = map[string]int32{
	"NF4REG": int32(NF4REG),
	"NF4DIR": int32(NF4DIR),
	"NF4BLK": int32(NF4BLK),
	"NF4CHR": int32(NF4CHR),
	"NF4LNK": int32(NF4LNK),
	"NF4SOCK": int32(NF4SOCK),
	"NF4FIFO": int32(NF4FIFO),
	"NF4ATTRDIR": int32(NF4ATTRDIR),
	"NF4NAMEDATTR": int32(NF4NAMEDATTR),
}
func (Nfs_ftype4) XdrEnumNames() map[int32]string {
	return _XdrNames_Nfs_ftype4
}
func (v Nfs_ftype4) String() string {
	if s, ok := _XdrNames_Nfs_ftype4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Nfs_ftype4#%d", v)
}
func (v *Nfs_ftype4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Nfs_ftype4[stok]; ok {
			*v = Nfs_ftype4(val)
			return nil
		} else if stok == "Nfs_ftype4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Nfs_ftype4.", stok))
	}
}
func (v Nfs_ftype4) GetU32() uint32 { return uint32(v) }
func (v *Nfs_ftype4) SetU32(n uint32) { *v = Nfs_ftype4(n) }
func (v *Nfs_ftype4) XdrPointer() interface{} { return v }
func (Nfs_ftype4) XdrTypeName() string { return "Nfs_ftype4" }
func (v Nfs_ftype4) XdrValue() interface{} { return v }
func (v *Nfs_ftype4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Nfs_ftype4 = *Nfs_ftype4
func XDR_Nfs_ftype4(v *Nfs_ftype4) *Nfs_ftype4 { return v }
func (v *Nfs_ftype4) XdrInitialize() {
	switch Nfs_ftype4(0) {
	case NF4REG, NF4DIR, NF4BLK, NF4CHR, NF4LNK, NF4SOCK, NF4FIFO, NF4ATTRDIR, NF4NAMEDATTR:
	default:
		if *v == Nfs_ftype4(0) { *v = NF4REG }
	}
}
var _XdrNames_Nfsstat4 = map[int32]string{
	int32(NFS4_OK): "NFS4_OK",
	int32(NFS4ERR_PERM): "NFS4ERR_PERM",
	int32(NFS4ERR_NOENT): "NFS4ERR_NOENT",
	int32(NFS4ERR_IO): "NFS4ERR_IO",
	int32(NFS4ERR_NXIO): "NFS4ERR_NXIO",
	int32(NFS4ERR_ACCESS): "NFS4ERR_ACCESS",
	int32(NFS4ERR_EXIST): "NFS4ERR_EXIST",
	int32(NFS4ERR_XDEV): "NFS4ERR_XDEV",
	int32(NFS4ERR_NOTDIR): "NFS4ERR_NOTDIR",
	int32(NFS4ERR_ISDIR): "NFS4ERR_ISDIR",
	int32(NFS4ERR_INVAL): "NFS4ERR_INVAL",
	int32(NFS4ERR_FBIG): "NFS4ERR_FBIG",
	int32(NFS4ERR_NOSPC): "NFS4ERR_NOSPC",
	int32(NFS4ERR_ROFS): "NFS4ERR_ROFS",
	int32(NFS4ERR_MLINK): "NFS4ERR_MLINK",
	int32(NFS4ERR_NAMETOOLONG): "NFS4ERR_NAMETOOLONG",
	int32(NFS4ERR_NOTEMPTY): "NFS4ERR_NOTEMPTY",
	int32(NFS4ERR_DQUOT): "NFS4ERR_DQUOT",
	int32(NFS4ERR_STALE): "NFS4ERR_STALE",
	int32(NFS4ERR_BADHANDLE): "NFS4ERR_BADHANDLE",
	int32(NFS4ERR_BAD_COOKIE): "NFS4ERR_BAD_COOKIE",
	int32(NFS4ERR_NOTSUPP): "NFS4ERR_NOTSUPP",
	int32(NFS4ERR_TOOSMALL): "NFS4ERR_TOOSMALL",
	int32(NFS4ERR_SERVERFAULT): "NFS4ERR_SERVERFAULT",
	int32(NFS4ERR_BADTYPE): "NFS4ERR_BADTYPE",
	int32(NFS4ERR_DELAY): "NFS4ERR_DELAY",
	int32(NFS4ERR_SAME): "NFS4ERR_SAME",
	int32(NFS4ERR_DENIED): "NFS4ERR_DENIED",
	int32(NFS4ERR_EXPIRED): "NFS4ERR_EXPIRED",
	int32(NFS4ERR_LOCKED): "NFS4ERR_LOCKED",
	int32(NFS4ERR_GRACE): "NFS4ERR_GRACE",
	int32(NFS4ERR_FHEXPIRED): "NFS4ERR_FHEXPIRED",
	int32(NFS4ERR_SHARE_DENIED): "NFS4ERR_SHARE_DENIED",
	int32(NFS4ERR_WRONGSEC): "NFS4ERR_WRONGSEC",
	int32(NFS4ERR_CLID_INUSE): "NFS4ERR_CLID_INUSE",
	int32(NFS4ERR_RESOURCE): "NFS4ERR_RESOURCE",
	int32(NFS4ERR_MOVED): "NFS4ERR_MOVED",
	int32(NFS4ERR_NOFILEHANDLE): "NFS4ERR_NOFILEHANDLE",
	int32(NFS4ERR_MINOR_VERS_MISMATCH): "NFS4ERR_MINOR_VERS_MISMATCH",
	int32(NFS4ERR_STALE_CLIENTID): "NFS4ERR_STALE_CLIENTID",
	int32(NFS4ERR_STALE_STATEID): "NFS4ERR_STALE_STATEID",
	int32(NFS4ERR_OLD_STATEID): "NFS4ERR_OLD_STATEID",
	int32(NFS4ERR_BAD_STATEID): "NFS4ERR_BAD_STATEID",
	int32(NFS4ERR_BAD_SEQID): "NFS4ERR_BAD_SEQID",
	int32(NFS4ERR_NOT_SAME): "NFS4ERR_NOT_SAME",
	int32(NFS4ERR_LOCK_RANGE): "NFS4ERR_LOCK_RANGE",
	int32(NFS4ERR_SYMLINK): "NFS4ERR_SYMLINK",
	int32(NFS4ERR_RESTOREFH): "NFS4ERR_RESTOREFH",
	int32(NFS4ERR_LEASE_MOVED): "NFS4ERR_LEASE_MOVED",
	int32(NFS4ERR_ATTRNOTSUPP): "NFS4ERR_ATTRNOTSUPP",
	int32(NFS4ERR_NO_GRACE): "NFS4ERR_NO_GRACE",
	int32(NFS4ERR_RECLAIM_BAD): "NFS4ERR_RECLAIM_BAD",
	int32(NFS4ERR_RECLAIM_CONFLICT): "NFS4ERR_RECLAIM_CONFLICT",
	int32(NFS4ERR_BADXDR): "NFS4ERR_BADXDR",
	int32(NFS4ERR_LOCKS_HELD): "NFS4ERR_LOCKS_HELD",
	int32(NFS4ERR_OPENMODE): "NFS4ERR_OPENMODE",
	int32(NFS4ERR_BADOWNER): "NFS4ERR_BADOWNER",
	int32(NFS4ERR_BADCHAR): "NFS4ERR_BADCHAR",
	int32(NFS4ERR_BADNAME): "NFS4ERR_BADNAME",
	int32(NFS4ERR_BAD_RANGE): "NFS4ERR_BAD_RANGE",
	int32(NFS4ERR_LOCK_NOTSUPP): "NFS4ERR_LOCK_NOTSUPP",
	int32(NFS4ERR_OP_ILLEGAL): "NFS4ERR_OP_ILLEGAL",
	int32(NFS4ERR_DEADLOCK): "NFS4ERR_DEADLOCK",
	int32(NFS4ERR_FILE_OPEN): "NFS4ERR_FILE_OPEN",
	int32(NFS4ERR_ADMIN_REVOKED): "NFS4ERR_ADMIN_REVOKED",
	int32(NFS4ERR_CB_PATH_DOWN): "NFS4ERR_CB_PATH_DOWN",
	int32(NFS4ERR_BADIOMODE): "NFS4ERR_BADIOMODE",
	int32(NFS4ERR_BADLAYOUT): "NFS4ERR_BADLAYOUT",
	int32(NFS4ERR_BAD_SESSION_DIGEST): "NFS4ERR_BAD_SESSION_DIGEST",
	int32(NFS4ERR_BADSESSION): "NFS4ERR_BADSESSION",
	int32(NFS4ERR_BADSLOT): "NFS4ERR_BADSLOT",
	int32(NFS4ERR_COMPLETE_ALREADY): "NFS4ERR_COMPLETE_ALREADY",
	int32(NFS4ERR_CONN_NOT_BOUND_TO_SESSION): "NFS4ERR_CONN_NOT_BOUND_TO_SESSION",
	int32(NFS4ERR_DELEG_ALREADY_WANTED): "NFS4ERR_DELEG_ALREADY_WANTED",
	int32(NFS4ERR_BACK_CHAN_BUSY): "NFS4ERR_BACK_CHAN_BUSY",
	int32(NFS4ERR_LAYOUTTRYLATER): "NFS4ERR_LAYOUTTRYLATER",
	int32(NFS4ERR_LAYOUTUNAVAILABLE): "NFS4ERR_LAYOUTUNAVAILABLE",
	int32(NFS4ERR_NOMATCHING_LAYOUT): "NFS4ERR_NOMATCHING_LAYOUT",
	int32(NFS4ERR_RECALLCONFLICT): "NFS4ERR_RECALLCONFLICT",
}
var _XdrValues_Nfsstat4 = map[string]int32{
	"NFS4_OK": int32(NFS4_OK),
	"NFS4ERR_PERM": int32(NFS4ERR_PERM),
	"NFS4ERR_NOENT": int32(NFS4ERR_NOENT),
	"NFS4ERR_IO": int32(NFS4ERR_IO),
	"NFS4ERR_NXIO": int32(NFS4ERR_NXIO),
	"NFS4ERR_ACCESS": int32(NFS4ERR_ACCESS),
	"NFS4ERR_EXIST": int32(NFS4ERR_EXIST),
	"NFS4ERR_XDEV": int32(NFS4ERR_XDEV),
	"NFS4ERR_NOTDIR": int32(NFS4ERR_NOTDIR),
	"NFS4ERR_ISDIR": int32(NFS4ERR_ISDIR),
	"NFS4ERR_INVAL": int32(NFS4ERR_INVAL),
	"NFS4ERR_FBIG": int32(NFS4ERR_FBIG),
	"NFS4ERR_NOSPC": int32(NFS4ERR_NOSPC),
	"NFS4ERR_ROFS": int32(NFS4ERR_ROFS),
	"NFS4ERR_MLINK": int32(NFS4ERR_MLINK),
	"NFS4ERR_NAMETOOLONG": int32(NFS4ERR_NAMETOOLONG),
	"NFS4ERR_NOTEMPTY": int32(NFS4ERR_NOTEMPTY),
	"NFS4ERR_DQUOT": int32(NFS4ERR_DQUOT),
	"NFS4ERR_STALE": int32(NFS4ERR_STALE),
	"NFS4ERR_BADHANDLE": int32(NFS4ERR_BADHANDLE),
	"NFS4ERR_BAD_COOKIE": int32(NFS4ERR_BAD_COOKIE),
	"NFS4ERR_NOTSUPP": int32(NFS4ERR_NOTSUPP),
	"NFS4ERR_TOOSMALL": int32(NFS4ERR_TOOSMALL),
	"NFS4ERR_SERVERFAULT": int32(NFS4ERR_SERVERFAULT),
	"NFS4ERR_BADTYPE": int32(NFS4ERR_BADTYPE),
	"NFS4ERR_DELAY": int32(NFS4ERR_DELAY),
	"NFS4ERR_SAME": int32(NFS4ERR_SAME),
	"NFS4ERR_DENIED": int32(NFS4ERR_DENIED),
	"NFS4ERR_EXPIRED": int32(NFS4ERR_EXPIRED),
	"NFS4ERR_LOCKED": int32(NFS4ERR_LOCKED),
	"NFS4ERR_GRACE": int32(NFS4ERR_GRACE),
	"NFS4ERR_FHEXPIRED": int32(NFS4ERR_FHEXPIRED),
	"NFS4ERR_SHARE_DENIED": int32(NFS4ERR_SHARE_DENIED),
	"NFS4ERR_WRONGSEC": int32(NFS4ERR_WRONGSEC),
	"NFS4ERR_CLID_INUSE": int32(NFS4ERR_CLID_INUSE),
	"NFS4ERR_RESOURCE": int32(NFS4ERR_RESOURCE),
	"NFS4ERR_MOVED": int32(NFS4ERR_MOVED),
	"NFS4ERR_NOFILEHANDLE": int32(NFS4ERR_NOFILEHANDLE),
	"NFS4ERR_MINOR_VERS_MISMATCH": int32(NFS4ERR_MINOR_VERS_MISMATCH),
	"NFS4ERR_STALE_CLIENTID": int32(NFS4ERR_STALE_CLIENTID),
	"NFS4ERR_STALE_STATEID": int32(NFS4ERR_STALE_STATEID),
	"NFS4ERR_OLD_STATEID": int32(NFS4ERR_OLD_STATEID),
	"NFS4ERR_BAD_STATEID": int32(NFS4ERR_BAD_STATEID),
	"NFS4ERR_BAD_SEQID": int32(NFS4ERR_BAD_SEQID),
	"NFS4ERR_NOT_SAME": int32(NFS4ERR_NOT_SAME),
	"NFS4ERR_LOCK_RANGE": int32(NFS4ERR_LOCK_RANGE),
	"NFS4ERR_SYMLINK": int32(NFS4ERR_SYMLINK),
	"NFS4ERR_RESTOREFH": int32(NFS4ERR_RESTOREFH),
	"NFS4ERR_LEASE_MOVED": int32(NFS4ERR_LEASE_MOVED),
	"NFS4ERR_ATTRNOTSUPP": int32(NFS4ERR_ATTRNOTSUPP),
	"NFS4ERR_NO_GRACE": int32(NFS4ERR_NO_GRACE),
	"NFS4ERR_RECLAIM_BAD": int32(NFS4ERR_RECLAIM_BAD),
	"NFS4ERR_RECLAIM_CONFLICT": int32(NFS4ERR_RECLAIM_CONFLICT),
	"NFS4ERR_BADXDR": int32(NFS4ERR_BADXDR),
	"NFS4ERR_LOCKS_HELD": int32(NFS4ERR_LOCKS_HELD),
	"NFS4ERR_OPENMODE": int32(NFS4ERR_OPENMODE),
	"NFS4ERR_BADOWNER": int32(NFS4ERR_BADOWNER),
	"NFS4ERR_BADCHAR": int32(NFS4ERR_BADCHAR),
	"NFS4ERR_BADNAME": int32(NFS4ERR_BADNAME),
	"NFS4ERR_BAD_RANGE": int32(NFS4ERR_BAD_RANGE),
	"NFS4ERR_LOCK_NOTSUPP": int32(NFS4ERR_LOCK_NOTSUPP),
	"NFS4ERR_OP_ILLEGAL": int32(NFS4ERR_OP_ILLEGAL),
	"NFS4ERR_DEADLOCK": int32(NFS4ERR_DEADLOCK),
	"NFS4ERR_FILE_OPEN": int32(NFS4ERR_FILE_OPEN),
	"NFS4ERR_ADMIN_REVOKED": int32(NFS4ERR_ADMIN_REVOKED),
	"NFS4ERR_CB_PATH_DOWN": int32(NFS4ERR_CB_PATH_DOWN),
	"NFS4ERR_BADIOMODE": int32(NFS4ERR_BADIOMODE),
	"NFS4ERR_BADLAYOUT": int32(NFS4ERR_BADLAYOUT),
	"NFS4ERR_BAD_SESSION_DIGEST": int32(NFS4ERR_BAD_SESSION_DIGEST),
	"NFS4ERR_BADSESSION": int32(NFS4ERR_BADSESSION),
	"NFS4ERR_BADSLOT": int32(NFS4ERR_BADSLOT),
	"NFS4ERR_COMPLETE_ALREADY": int32(NFS4ERR_COMPLETE_ALREADY),
	"NFS4ERR_CONN_NOT_BOUND_TO_SESSION": int32(NFS4ERR_CONN_NOT_BOUND_TO_SESSION),
	"NFS4ERR_DELEG_ALREADY_WANTED": int32(NFS4ERR_DELEG_ALREADY_WANTED),
	"NFS4ERR_BACK_CHAN_BUSY": int32(NFS4ERR_BACK_CHAN_BUSY),
	"NFS4ERR_LAYOUTTRYLATER": int32(NFS4ERR_LAYOUTTRYLATER),
	"NFS4ERR_LAYOUTUNAVAILABLE": int32(NFS4ERR_LAYOUTUNAVAILABLE),
	"NFS4ERR_NOMATCHING_LAYOUT": int32(NFS4ERR_NOMATCHING_LAYOUT),
	"NFS4ERR_RECALLCONFLICT": int32(NFS4ERR_RECALLCONFLICT),
}
func (Nfsstat4) XdrEnumNames() map[int32]string {
	return _XdrNames_Nfsstat4
}
func (v Nfsstat4) String() string {
	if s, ok := _XdrNames_Nfsstat4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Nfsstat4#%d", v)
}
func (v *Nfsstat4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Nfsstat4[stok]; ok {
			*v = Nfsstat4(val)
			return nil
		} else if stok == "Nfsstat4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Nfsstat4.", stok))
	}
}
func (v Nfsstat4) GetU32() uint32 { return uint32(v) }
func (v *Nfsstat4) SetU32(n uint32) { *v = Nfsstat4(n) }
func (v *Nfsstat4) XdrPointer() interface{} { return v }
func (Nfsstat4) XdrTypeName() string { return "Nfsstat4" }
func (v Nfsstat4) XdrValue() interface{} { return v }
func (v *Nfsstat4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Nfsstat4 = *Nfsstat4
func XDR_Nfsstat4(v *Nfsstat4) *Nfsstat4 { return v }
type _XdrVec_unbounded_Uint32_t []Uint32_t
func (_XdrVec_unbounded_Uint32_t) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Uint32_t) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Uint32_t length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Uint32_t length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Uint32_t) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Uint32_t) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Uint32_t, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Uint32_t) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Uint32_t(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Uint32_t) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Uint32_t) XdrTypeName() string { return "Uint32_t<>" }
func (v *_XdrVec_unbounded_Uint32_t) XdrPointer() interface{} { return (*[]Uint32_t)(v) }
func (v _XdrVec_unbounded_Uint32_t) XdrValue() interface{} { return ([]Uint32_t)(v) }
func (v *_XdrVec_unbounded_Uint32_t) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Bitmap4 struct {
	*_XdrVec_unbounded_Uint32_t
}
func XDR_Bitmap4(v *Bitmap4) XdrType_Bitmap4 {
	return XdrType_Bitmap4{(*_XdrVec_unbounded_Uint32_t)(v)}
}
func (XdrType_Bitmap4) XdrTypeName() string { return "Bitmap4" }
func (v XdrType_Bitmap4) XdrUnwrap() XdrType { return v._XdrVec_unbounded_Uint32_t }
type XdrType_Offset4 struct {
	XdrType_Uint64_t
}
func XDR_Offset4(v *Offset4) *XdrType_Offset4 {
	return &XdrType_Offset4{XDR_Uint64_t(v)}
}
func (XdrType_Offset4) XdrTypeName() string { return "Offset4" }
func (v XdrType_Offset4) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Count4 struct {
	XdrType_Uint32_t
}
func XDR_Count4(v *Count4) *XdrType_Count4 {
	return &XdrType_Count4{XDR_Uint32_t(v)}
}
func (XdrType_Count4) XdrTypeName() string { return "Count4" }
func (v XdrType_Count4) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Length4 struct {
	XdrType_Uint64_t
}
func XDR_Length4(v *Length4) *XdrType_Length4 {
	return &XdrType_Length4{XDR_Uint64_t(v)}
}
func (XdrType_Length4) XdrTypeName() string { return "Length4" }
func (v XdrType_Length4) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Clientid4 struct {
	XdrType_Uint64_t
}
func XDR_Clientid4(v *Clientid4) *XdrType_Clientid4 {
	return &XdrType_Clientid4{XDR_Uint64_t(v)}
}
func (XdrType_Clientid4) XdrTypeName() string { return "Clientid4" }
func (v XdrType_Clientid4) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Sequenceid4 struct {
	XdrType_Uint32_t
}
func XDR_Sequenceid4(v *Sequenceid4) *XdrType_Sequenceid4 {
	return &XdrType_Sequenceid4{XDR_Uint32_t(v)}
}
func (XdrType_Sequenceid4) XdrTypeName() string { return "Sequenceid4" }
func (v XdrType_Sequenceid4) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Seqid4 struct {
	XdrType_Uint32_t
}
func XDR_Seqid4(v *Seqid4) *XdrType_Seqid4 {
	return &XdrType_Seqid4{XDR_Uint32_t(v)}
}
func (XdrType_Seqid4) XdrTypeName() string { return "Seqid4" }
func (v XdrType_Seqid4) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Slotid4 struct {
	XdrType_Uint32_t
}
func XDR_Slotid4(v *Slotid4) *XdrType_Slotid4 {
	return &XdrType_Slotid4{XDR_Uint32_t(v)}
}
func (XdrType_Slotid4) XdrTypeName() string { return "Slotid4" }
func (v XdrType_Slotid4) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Utf8string struct {
	XdrVecOpaque
}
func XDR_Utf8string(v *Utf8string) XdrType_Utf8string {
	return XdrType_Utf8string{XdrVecOpaque{v, 0xffffffff}}
}
func (XdrType_Utf8string) XdrTypeName() string { return "Utf8string" }
func (v XdrType_Utf8string) XdrUnwrap() XdrType { return v.XdrVecOpaque }
type XdrType_Utf8str_cis struct {
	XdrType_Utf8string
}
func XDR_Utf8str_cis(v *Utf8str_cis) XdrType_Utf8str_cis {
	return XdrType_Utf8str_cis{XDR_Utf8string(v)}
}
func (XdrType_Utf8str_cis) XdrTypeName() string { return "Utf8str_cis" }
func (v XdrType_Utf8str_cis) XdrUnwrap() XdrType { return v.XdrType_Utf8string }
type XdrType_Utf8str_cs struct {
	XdrType_Utf8string
}
func XDR_Utf8str_cs(v *Utf8str_cs) XdrType_Utf8str_cs {
	return XdrType_Utf8str_cs{XDR_Utf8string(v)}
}
func (XdrType_Utf8str_cs) XdrTypeName() string { return "Utf8str_cs" }
func (v XdrType_Utf8str_cs) XdrUnwrap() XdrType { return v.XdrType_Utf8string }
type XdrType_Utf8str_mixed struct {
	XdrType_Utf8string
}
func XDR_Utf8str_mixed(v *Utf8str_mixed) XdrType_Utf8str_mixed {
	return XdrType_Utf8str_mixed{XDR_Utf8string(v)}
}
func (XdrType_Utf8str_mixed) XdrTypeName() string { return "Utf8str_mixed" }
func (v XdrType_Utf8str_mixed) XdrUnwrap() XdrType { return v.XdrType_Utf8string }
type XdrType_Component4 struct {
	XdrType_Utf8str_cs
}
func XDR_Component4(v *Component4) XdrType_Component4 {
	return XdrType_Component4{XDR_Utf8str_cs(v)}
}
func (XdrType_Component4) XdrTypeName() string { return "Component4" }
func (v XdrType_Component4) XdrUnwrap() XdrType { return v.XdrType_Utf8str_cs }
type _XdrVec_unbounded_Component4 []Component4
func (_XdrVec_unbounded_Component4) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Component4) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Component4 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Component4 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Component4) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Component4) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Component4, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Component4) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Component4(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Component4) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Component4) XdrTypeName() string { return "Component4<>" }
func (v *_XdrVec_unbounded_Component4) XdrPointer() interface{} { return (*[]Component4)(v) }
func (v _XdrVec_unbounded_Component4) XdrValue() interface{} { return ([]Component4)(v) }
func (v *_XdrVec_unbounded_Component4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Pathname4 struct {
	*_XdrVec_unbounded_Component4
}
func XDR_Pathname4(v *Pathname4) XdrType_Pathname4 {
	return XdrType_Pathname4{(*_XdrVec_unbounded_Component4)(v)}
}
func (XdrType_Pathname4) XdrTypeName() string { return "Pathname4" }
func (v XdrType_Pathname4) XdrUnwrap() XdrType { return v._XdrVec_unbounded_Component4 }
type XdrType_Nfs_lockid4 struct {
	XdrType_Uint64_t
}
func XDR_Nfs_lockid4(v *Nfs_lockid4) XdrType_Nfs_lockid4 {
	return XdrType_Nfs_lockid4{XDR_Uint64_t(v)}
}
func (XdrType_Nfs_lockid4) XdrTypeName() string { return "Nfs_lockid4" }
func (v XdrType_Nfs_lockid4) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Nfs_cookie4 struct {
	XdrType_Uint64_t
}
func XDR_Nfs_cookie4(v *Nfs_cookie4) *XdrType_Nfs_cookie4 {
	return &XdrType_Nfs_cookie4{XDR_Uint64_t(v)}
}
func (XdrType_Nfs_cookie4) XdrTypeName() string { return "Nfs_cookie4" }
func (v XdrType_Nfs_cookie4) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Linktext4 struct {
	XdrType_Utf8str_cs
}
func XDR_Linktext4(v *Linktext4) XdrType_Linktext4 {
	return XdrType_Linktext4{XDR_Utf8str_cs(v)}
}
func (XdrType_Linktext4) XdrTypeName() string { return "Linktext4" }
func (v XdrType_Linktext4) XdrUnwrap() XdrType { return v.XdrType_Utf8str_cs }
type XdrType_Sec_oid4 struct {
	XdrVecOpaque
}
func XDR_Sec_oid4(v *Sec_oid4) XdrType_Sec_oid4 {
	return XdrType_Sec_oid4{XdrVecOpaque{v, 0xffffffff}}
}
func (XdrType_Sec_oid4) XdrTypeName() string { return "Sec_oid4" }
func (v XdrType_Sec_oid4) XdrUnwrap() XdrType { return v.XdrVecOpaque }
type XdrType_Qop4 struct {
	XdrType_Uint32_t
}
func XDR_Qop4(v *Qop4) *XdrType_Qop4 {
	return &XdrType_Qop4{XDR_Uint32_t(v)}
}
func (XdrType_Qop4) XdrTypeName() string { return "Qop4" }
func (v XdrType_Qop4) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Mode4 struct {
	XdrType_Uint32_t
}
func XDR_Mode4(v *Mode4) XdrType_Mode4 {
	return XdrType_Mode4{XDR_Uint32_t(v)}
}
func (XdrType_Mode4) XdrTypeName() string { return "Mode4" }
func (v XdrType_Mode4) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Changeid4 struct {
	XdrType_Uint64_t
}
func XDR_Changeid4(v *Changeid4) *XdrType_Changeid4 {
	return &XdrType_Changeid4{XDR_Uint64_t(v)}
}
func (XdrType_Changeid4) XdrTypeName() string { return "Changeid4" }
func (v XdrType_Changeid4) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type _XdrArray_8_opaque [8]byte
func (v *_XdrArray_8_opaque) GetByteSlice() []byte { return v[:] }
func (v *_XdrArray_8_opaque) XdrTypeName() string { return "opaque[]" }
func (v *_XdrArray_8_opaque) XdrValue() interface{} { return v[:] }
func (v *_XdrArray_8_opaque) XdrPointer() interface{} { return (*[8]byte)(v) }
func (v *_XdrArray_8_opaque) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *_XdrArray_8_opaque) String() string { return fmt.Sprintf("%x", v[:]) }
func (v *_XdrArray_8_opaque) Scan(ss fmt.ScanState, c rune) error {
	return XdrArrayOpaqueScan(v[:], ss, c)
}
func (_XdrArray_8_opaque) XdrArraySize() uint32 {
	const bound uint32 = 8 // Force error if not const or doesn't fit
	return bound
}
type XdrType_Verifier4 struct {
	*_XdrArray_8_opaque
}
func XDR_Verifier4(v *Verifier4) XdrType_Verifier4 {
	return XdrType_Verifier4{(*_XdrArray_8_opaque)(v)}
}
func (XdrType_Verifier4) XdrTypeName() string { return "Verifier4" }
func (v XdrType_Verifier4) XdrUnwrap() XdrType { return v._XdrArray_8_opaque }
type _XdrArray_16_opaque [16]byte
func (v *_XdrArray_16_opaque) GetByteSlice() []byte { return v[:] }
func (v *_XdrArray_16_opaque) XdrTypeName() string { return "opaque[]" }
func (v *_XdrArray_16_opaque) XdrValue() interface{} { return v[:] }
func (v *_XdrArray_16_opaque) XdrPointer() interface{} { return (*[16]byte)(v) }
func (v *_XdrArray_16_opaque) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *_XdrArray_16_opaque) String() string { return fmt.Sprintf("%x", v[:]) }
func (v *_XdrArray_16_opaque) Scan(ss fmt.ScanState, c rune) error {
	return XdrArrayOpaqueScan(v[:], ss, c)
}
func (_XdrArray_16_opaque) XdrArraySize() uint32 {
	const bound uint32 = 16 // Force error if not const or doesn't fit
	return bound
}
type XdrType_Sessionid4 struct {
	*_XdrArray_16_opaque
}
func XDR_Sessionid4(v *Sessionid4) XdrType_Sessionid4 {
	return XdrType_Sessionid4{(*_XdrArray_16_opaque)(v)}
}
func (XdrType_Sessionid4) XdrTypeName() string { return "Sessionid4" }
func (v XdrType_Sessionid4) XdrUnwrap() XdrType { return v._XdrArray_16_opaque }
type _XdrVec_16_uint32 []uint32
func (_XdrVec_16_uint32) XdrBound() uint32 {
	const bound uint32 = 16 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_16_uint32) XdrCheckLen(length uint32) {
	if length > uint32(16) {
		XdrPanic("_XdrVec_16_uint32 length %d exceeds bound 16", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_16_uint32 length %d exceeds max int", length)
	}
}
func (v _XdrVec_16_uint32) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_16_uint32) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(16); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]uint32, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_16_uint32) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_uint32(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_16_uint32) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 16 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_16_uint32) XdrTypeName() string { return "uint32<>" }
func (v *_XdrVec_16_uint32) XdrPointer() interface{} { return (*[]uint32)(v) }
func (v _XdrVec_16_uint32) XdrValue() interface{} { return ([]uint32)(v) }
func (v *_XdrVec_16_uint32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Authsys_parms = *Authsys_parms
func (v *Authsys_parms) XdrPointer() interface{} { return v }
func (Authsys_parms) XdrTypeName() string { return "Authsys_parms" }
func (v Authsys_parms) XdrValue() interface{} { return v }
func (v *Authsys_parms) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Authsys_parms) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstamp", name), XDR_uint32(&v.Stamp))
	x.Marshal(x.Sprintf("%smachinename", name), XdrString{&v.Machinename, 255})
	x.Marshal(x.Sprintf("%suid", name), XDR_uint32(&v.Uid))
	x.Marshal(x.Sprintf("%sgid", name), XDR_uint32(&v.Gid))
	x.Marshal(x.Sprintf("%sgids", name), (*_XdrVec_16_uint32)(&v.Gids))
}
func XDR_Authsys_parms(v *Authsys_parms) *Authsys_parms { return v }
type XdrType_Deviceid4 struct {
	*_XdrArray_16_opaque
}
func XDR_Deviceid4(v *Deviceid4) *XdrType_Deviceid4 {
	return &XdrType_Deviceid4{(*_XdrArray_16_opaque)(v)}
}
func (XdrType_Deviceid4) XdrTypeName() string { return "Deviceid4" }
func (v XdrType_Deviceid4) XdrUnwrap() XdrType { return v._XdrArray_16_opaque }
var _XdrNames_Layouttype4 = map[int32]string{
	int32(LAYOUT4_NFSV4_1_FILES): "LAYOUT4_NFSV4_1_FILES",
	int32(LAYOUT4_OSD2_OBJECTS): "LAYOUT4_OSD2_OBJECTS",
	int32(LAYOUT4_BLOCK_VOLUME): "LAYOUT4_BLOCK_VOLUME",
}
var _XdrValues_Layouttype4 = map[string]int32{
	"LAYOUT4_NFSV4_1_FILES": int32(LAYOUT4_NFSV4_1_FILES),
	"LAYOUT4_OSD2_OBJECTS": int32(LAYOUT4_OSD2_OBJECTS),
	"LAYOUT4_BLOCK_VOLUME": int32(LAYOUT4_BLOCK_VOLUME),
}
func (Layouttype4) XdrEnumNames() map[int32]string {
	return _XdrNames_Layouttype4
}
func (v Layouttype4) String() string {
	if s, ok := _XdrNames_Layouttype4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Layouttype4#%d", v)
}
func (v *Layouttype4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Layouttype4[stok]; ok {
			*v = Layouttype4(val)
			return nil
		} else if stok == "Layouttype4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Layouttype4.", stok))
	}
}
func (v Layouttype4) GetU32() uint32 { return uint32(v) }
func (v *Layouttype4) SetU32(n uint32) { *v = Layouttype4(n) }
func (v *Layouttype4) XdrPointer() interface{} { return v }
func (Layouttype4) XdrTypeName() string { return "Layouttype4" }
func (v Layouttype4) XdrValue() interface{} { return v }
func (v *Layouttype4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Layouttype4 = *Layouttype4
func XDR_Layouttype4(v *Layouttype4) *Layouttype4 { return v }
func (v *Layouttype4) XdrInitialize() {
	switch Layouttype4(0) {
	case LAYOUT4_NFSV4_1_FILES, LAYOUT4_OSD2_OBJECTS, LAYOUT4_BLOCK_VOLUME:
	default:
		if *v == Layouttype4(0) { *v = LAYOUT4_NFSV4_1_FILES }
	}
}
type XdrType_Layoutupdate4 = *Layoutupdate4
func (v *Layoutupdate4) XdrPointer() interface{} { return v }
func (Layoutupdate4) XdrTypeName() string { return "Layoutupdate4" }
func (v Layoutupdate4) XdrValue() interface{} { return v }
func (v *Layoutupdate4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Layoutupdate4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slou_type", name), XDR_Layouttype4(&v.Lou_type))
	x.Marshal(x.Sprintf("%slou_body", name), XdrVecOpaque{&v.Lou_body, 0xffffffff})
}
func XDR_Layoutupdate4(v *Layoutupdate4) *Layoutupdate4 { return v }
type XdrType_Device_addr4 = *Device_addr4
func (v *Device_addr4) XdrPointer() interface{} { return v }
func (Device_addr4) XdrTypeName() string { return "Device_addr4" }
func (v Device_addr4) XdrValue() interface{} { return v }
func (v *Device_addr4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Device_addr4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sda_layout_type", name), XDR_Layouttype4(&v.Da_layout_type))
	x.Marshal(x.Sprintf("%sda_addr_body", name), XdrVecOpaque{&v.Da_addr_body, 0xffffffff})
}
func XDR_Device_addr4(v *Device_addr4) *Device_addr4 { return v }
type XdrType_Nfstime4 = *Nfstime4
func (v *Nfstime4) XdrPointer() interface{} { return v }
func (Nfstime4) XdrTypeName() string { return "Nfstime4" }
func (v Nfstime4) XdrValue() interface{} { return v }
func (v *Nfstime4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Nfstime4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sseconds", name), XDR_Int64_t(&v.Seconds))
	x.Marshal(x.Sprintf("%snseconds", name), XDR_Uint32_t(&v.Nseconds))
}
func XDR_Nfstime4(v *Nfstime4) *Nfstime4 { return v }
var _XdrNames_Time_how4 = map[int32]string{
	int32(SET_TO_SERVER_TIME4): "SET_TO_SERVER_TIME4",
	int32(SET_TO_CLIENT_TIME4): "SET_TO_CLIENT_TIME4",
}
var _XdrValues_Time_how4 = map[string]int32{
	"SET_TO_SERVER_TIME4": int32(SET_TO_SERVER_TIME4),
	"SET_TO_CLIENT_TIME4": int32(SET_TO_CLIENT_TIME4),
}
func (Time_how4) XdrEnumNames() map[int32]string {
	return _XdrNames_Time_how4
}
func (v Time_how4) String() string {
	if s, ok := _XdrNames_Time_how4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Time_how4#%d", v)
}
func (v *Time_how4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Time_how4[stok]; ok {
			*v = Time_how4(val)
			return nil
		} else if stok == "Time_how4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Time_how4.", stok))
	}
}
func (v Time_how4) GetU32() uint32 { return uint32(v) }
func (v *Time_how4) SetU32(n uint32) { *v = Time_how4(n) }
func (v *Time_how4) XdrPointer() interface{} { return v }
func (Time_how4) XdrTypeName() string { return "Time_how4" }
func (v Time_how4) XdrValue() interface{} { return v }
func (v *Time_how4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Time_how4 = *Time_how4
func XDR_Time_how4(v *Time_how4) *Time_how4 { return v }
var _XdrNames_Layoutiomode4 = map[int32]string{
	int32(LAYOUTIOMODE4_READ): "LAYOUTIOMODE4_READ",
	int32(LAYOUTIOMODE4_RW): "LAYOUTIOMODE4_RW",
	int32(LAYOUTIOMODE4_ANY): "LAYOUTIOMODE4_ANY",
}
var _XdrValues_Layoutiomode4 = map[string]int32{
	"LAYOUTIOMODE4_READ": int32(LAYOUTIOMODE4_READ),
	"LAYOUTIOMODE4_RW": int32(LAYOUTIOMODE4_RW),
	"LAYOUTIOMODE4_ANY": int32(LAYOUTIOMODE4_ANY),
}
func (Layoutiomode4) XdrEnumNames() map[int32]string {
	return _XdrNames_Layoutiomode4
}
func (v Layoutiomode4) String() string {
	if s, ok := _XdrNames_Layoutiomode4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Layoutiomode4#%d", v)
}
func (v *Layoutiomode4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Layoutiomode4[stok]; ok {
			*v = Layoutiomode4(val)
			return nil
		} else if stok == "Layoutiomode4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Layoutiomode4.", stok))
	}
}
func (v Layoutiomode4) GetU32() uint32 { return uint32(v) }
func (v *Layoutiomode4) SetU32(n uint32) { *v = Layoutiomode4(n) }
func (v *Layoutiomode4) XdrPointer() interface{} { return v }
func (Layoutiomode4) XdrTypeName() string { return "Layoutiomode4" }
func (v Layoutiomode4) XdrValue() interface{} { return v }
func (v *Layoutiomode4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Layoutiomode4 = *Layoutiomode4
func XDR_Layoutiomode4(v *Layoutiomode4) *Layoutiomode4 { return v }
func (v *Layoutiomode4) XdrInitialize() {
	switch Layoutiomode4(0) {
	case LAYOUTIOMODE4_READ, LAYOUTIOMODE4_RW, LAYOUTIOMODE4_ANY:
	default:
		if *v == Layoutiomode4(0) { *v = LAYOUTIOMODE4_READ }
	}
}
type XdrType_Layout_content4 = *Layout_content4
func (v *Layout_content4) XdrPointer() interface{} { return v }
func (Layout_content4) XdrTypeName() string { return "Layout_content4" }
func (v Layout_content4) XdrValue() interface{} { return v }
func (v *Layout_content4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Layout_content4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sloc_type", name), XDR_Layouttype4(&v.Loc_type))
	x.Marshal(x.Sprintf("%sloc_body", name), XdrVecOpaque{&v.Loc_body, 0xffffffff})
}
func XDR_Layout_content4(v *Layout_content4) *Layout_content4 { return v }
type XdrType_Layout4 = *Layout4
func (v *Layout4) XdrPointer() interface{} { return v }
func (Layout4) XdrTypeName() string { return "Layout4" }
func (v Layout4) XdrValue() interface{} { return v }
func (v *Layout4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Layout4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slo_offset", name), XDR_Offset4(&v.Lo_offset))
	x.Marshal(x.Sprintf("%slo_length", name), XDR_Length4(&v.Lo_length))
	x.Marshal(x.Sprintf("%slo_iomode", name), XDR_Layoutiomode4(&v.Lo_iomode))
	x.Marshal(x.Sprintf("%slo_content", name), XDR_Layout_content4(&v.Lo_content))
}
func XDR_Layout4(v *Layout4) *Layout4 { return v }
func (u *Settime4) Time() *Nfstime4 {
	switch u.Set_it {
	case SET_TO_CLIENT_TIME4:
		if v, ok := u.U.(*Nfstime4); ok {
			return v
		} else {
			var zero Nfstime4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Settime4.Time accessed when Set_it == %v", u.Set_it)
		return nil
	}
}
func (u Settime4) XdrValid() bool {
	return true
}
func (u *Settime4) XdrUnionTag() XdrNum32 {
	return XDR_Time_how4(&u.Set_it)
}
func (u *Settime4) XdrUnionTagName() string {
	return "Set_it"
}
func (u *Settime4) XdrUnionBody() XdrType {
	switch u.Set_it {
	case SET_TO_CLIENT_TIME4:
		return XDR_Nfstime4(u.Time())
	default:
		return nil
	}
}
func (u *Settime4) XdrUnionBodyName() string {
	switch u.Set_it {
	case SET_TO_CLIENT_TIME4:
		return "Time"
	default:
		return ""
	}
}
type XdrType_Settime4 = *Settime4
func (v *Settime4) XdrPointer() interface{} { return v }
func (Settime4) XdrTypeName() string { return "Settime4" }
func (v Settime4) XdrValue() interface{} { return v }
func (v *Settime4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Settime4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Time_how4(&u.Set_it).XdrMarshal(x, x.Sprintf("%sset_it", name))
	switch u.Set_it {
	case SET_TO_CLIENT_TIME4:
		x.Marshal(x.Sprintf("%stime", name), XDR_Nfstime4(u.Time()))
		return
	default:
		return
	}
}
func XDR_Settime4(v *Settime4) *Settime4 { return v}
type XdrType_Nfs_fh4 struct {
	XdrVecOpaque
}
func XDR_Nfs_fh4(v *Nfs_fh4) XdrType_Nfs_fh4 {
	return XdrType_Nfs_fh4{XdrVecOpaque{v, NFS4_FHSIZE}}
}
func (XdrType_Nfs_fh4) XdrTypeName() string { return "Nfs_fh4" }
func (v XdrType_Nfs_fh4) XdrUnwrap() XdrType { return v.XdrVecOpaque }
type XdrType_Fsid4 = *Fsid4
func (v *Fsid4) XdrPointer() interface{} { return v }
func (Fsid4) XdrTypeName() string { return "Fsid4" }
func (v Fsid4) XdrValue() interface{} { return v }
func (v *Fsid4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Fsid4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%smajor", name), XDR_Uint64_t(&v.Major))
	x.Marshal(x.Sprintf("%sminor", name), XDR_Uint64_t(&v.Minor))
}
func XDR_Fsid4(v *Fsid4) *Fsid4 { return v }
type _XdrVec_unbounded_Utf8str_cis []Utf8str_cis
func (_XdrVec_unbounded_Utf8str_cis) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Utf8str_cis) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Utf8str_cis length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Utf8str_cis length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Utf8str_cis) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Utf8str_cis) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Utf8str_cis, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Utf8str_cis) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Utf8str_cis(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Utf8str_cis) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Utf8str_cis) XdrTypeName() string { return "Utf8str_cis<>" }
func (v *_XdrVec_unbounded_Utf8str_cis) XdrPointer() interface{} { return (*[]Utf8str_cis)(v) }
func (v _XdrVec_unbounded_Utf8str_cis) XdrValue() interface{} { return ([]Utf8str_cis)(v) }
func (v *_XdrVec_unbounded_Utf8str_cis) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Fs_location4 = *Fs_location4
func (v *Fs_location4) XdrPointer() interface{} { return v }
func (Fs_location4) XdrTypeName() string { return "Fs_location4" }
func (v Fs_location4) XdrValue() interface{} { return v }
func (v *Fs_location4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Fs_location4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sserver", name), (*_XdrVec_unbounded_Utf8str_cis)(&v.Server))
	x.Marshal(x.Sprintf("%srootpath", name), XDR_Pathname4(&v.Rootpath))
}
func XDR_Fs_location4(v *Fs_location4) *Fs_location4 { return v }
type _XdrVec_unbounded_Fs_location4 []Fs_location4
func (_XdrVec_unbounded_Fs_location4) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Fs_location4) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Fs_location4 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Fs_location4 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Fs_location4) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Fs_location4) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Fs_location4, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Fs_location4) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Fs_location4(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Fs_location4) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Fs_location4) XdrTypeName() string { return "Fs_location4<>" }
func (v *_XdrVec_unbounded_Fs_location4) XdrPointer() interface{} { return (*[]Fs_location4)(v) }
func (v _XdrVec_unbounded_Fs_location4) XdrValue() interface{} { return ([]Fs_location4)(v) }
func (v *_XdrVec_unbounded_Fs_location4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Fs_locations4 = *Fs_locations4
func (v *Fs_locations4) XdrPointer() interface{} { return v }
func (Fs_locations4) XdrTypeName() string { return "Fs_locations4" }
func (v Fs_locations4) XdrValue() interface{} { return v }
func (v *Fs_locations4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Fs_locations4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfs_root", name), XDR_Pathname4(&v.Fs_root))
	x.Marshal(x.Sprintf("%slocations", name), (*_XdrVec_unbounded_Fs_location4)(&v.Locations))
}
func XDR_Fs_locations4(v *Fs_locations4) *Fs_locations4 { return v }
type XdrType_Acetype4 struct {
	XdrType_Uint32_t
}
func XDR_Acetype4(v *Acetype4) *XdrType_Acetype4 {
	return &XdrType_Acetype4{XDR_Uint32_t(v)}
}
func (XdrType_Acetype4) XdrTypeName() string { return "Acetype4" }
func (v XdrType_Acetype4) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Aceflag4 struct {
	XdrType_Uint32_t
}
func XDR_Aceflag4(v *Aceflag4) *XdrType_Aceflag4 {
	return &XdrType_Aceflag4{XDR_Uint32_t(v)}
}
func (XdrType_Aceflag4) XdrTypeName() string { return "Aceflag4" }
func (v XdrType_Aceflag4) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Acemask4 struct {
	XdrType_Uint32_t
}
func XDR_Acemask4(v *Acemask4) *XdrType_Acemask4 {
	return &XdrType_Acemask4{XDR_Uint32_t(v)}
}
func (XdrType_Acemask4) XdrTypeName() string { return "Acemask4" }
func (v XdrType_Acemask4) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Nfsace4 = *Nfsace4
func (v *Nfsace4) XdrPointer() interface{} { return v }
func (Nfsace4) XdrTypeName() string { return "Nfsace4" }
func (v Nfsace4) XdrValue() interface{} { return v }
func (v *Nfsace4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Nfsace4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stype", name), XDR_Acetype4(&v.Type))
	x.Marshal(x.Sprintf("%sflag", name), XDR_Aceflag4(&v.Flag))
	x.Marshal(x.Sprintf("%saccess_mask", name), XDR_Acemask4(&v.Access_mask))
	x.Marshal(x.Sprintf("%swho", name), XDR_Utf8str_mixed(&v.Who))
}
func XDR_Nfsace4(v *Nfsace4) *Nfsace4 { return v }
type XdrType_Specdata4 = *Specdata4
func (v *Specdata4) XdrPointer() interface{} { return v }
func (Specdata4) XdrTypeName() string { return "Specdata4" }
func (v Specdata4) XdrValue() interface{} { return v }
func (v *Specdata4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Specdata4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sspecdata1", name), XDR_Uint32_t(&v.Specdata1))
	x.Marshal(x.Sprintf("%sspecdata2", name), XDR_Uint32_t(&v.Specdata2))
}
func XDR_Specdata4(v *Specdata4) *Specdata4 { return v }
type XdrType_Fattr4_supported_attrs struct {
	XdrType_Bitmap4
}
func XDR_Fattr4_supported_attrs(v *Fattr4_supported_attrs) XdrType_Fattr4_supported_attrs {
	return XdrType_Fattr4_supported_attrs{XDR_Bitmap4(v)}
}
func (XdrType_Fattr4_supported_attrs) XdrTypeName() string { return "Fattr4_supported_attrs" }
func (v XdrType_Fattr4_supported_attrs) XdrUnwrap() XdrType { return v.XdrType_Bitmap4 }
type XdrType_Fattr4_type struct {
	XdrType_Nfs_ftype4
}
func XDR_Fattr4_type(v *Fattr4_type) XdrType_Fattr4_type {
	return XdrType_Fattr4_type{XDR_Nfs_ftype4(v)}
}
func (XdrType_Fattr4_type) XdrTypeName() string { return "Fattr4_type" }
func (v XdrType_Fattr4_type) XdrUnwrap() XdrType { return v.XdrType_Nfs_ftype4 }
type XdrType_Fattr4_fh_expire_type struct {
	XdrType_Uint32_t
}
func XDR_Fattr4_fh_expire_type(v *Fattr4_fh_expire_type) XdrType_Fattr4_fh_expire_type {
	return XdrType_Fattr4_fh_expire_type{XDR_Uint32_t(v)}
}
func (XdrType_Fattr4_fh_expire_type) XdrTypeName() string { return "Fattr4_fh_expire_type" }
func (v XdrType_Fattr4_fh_expire_type) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Fattr4_change struct {
	XdrType_Changeid4
}
func XDR_Fattr4_change(v *Fattr4_change) *XdrType_Fattr4_change {
	return &XdrType_Fattr4_change{*XDR_Changeid4(v)}
}
func (XdrType_Fattr4_change) XdrTypeName() string { return "Fattr4_change" }
func (v XdrType_Fattr4_change) XdrUnwrap() XdrType { return &v.XdrType_Changeid4 }
type XdrType_Fattr4_size struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_size(v *Fattr4_size) XdrType_Fattr4_size {
	return XdrType_Fattr4_size{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_size) XdrTypeName() string { return "Fattr4_size" }
func (v XdrType_Fattr4_size) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_link_support struct {
	XdrType_bool
}
func XDR_Fattr4_link_support(v *Fattr4_link_support) XdrType_Fattr4_link_support {
	return XdrType_Fattr4_link_support{XDR_bool(v)}
}
func (XdrType_Fattr4_link_support) XdrTypeName() string { return "Fattr4_link_support" }
func (v XdrType_Fattr4_link_support) XdrUnwrap() XdrType { return v.XdrType_bool }
type XdrType_Fattr4_symlink_support struct {
	XdrType_bool
}
func XDR_Fattr4_symlink_support(v *Fattr4_symlink_support) XdrType_Fattr4_symlink_support {
	return XdrType_Fattr4_symlink_support{XDR_bool(v)}
}
func (XdrType_Fattr4_symlink_support) XdrTypeName() string { return "Fattr4_symlink_support" }
func (v XdrType_Fattr4_symlink_support) XdrUnwrap() XdrType { return v.XdrType_bool }
type XdrType_Fattr4_named_attr struct {
	XdrType_bool
}
func XDR_Fattr4_named_attr(v *Fattr4_named_attr) XdrType_Fattr4_named_attr {
	return XdrType_Fattr4_named_attr{XDR_bool(v)}
}
func (XdrType_Fattr4_named_attr) XdrTypeName() string { return "Fattr4_named_attr" }
func (v XdrType_Fattr4_named_attr) XdrUnwrap() XdrType { return v.XdrType_bool }
type XdrType_Fattr4_fsid struct {
	XdrType_Fsid4
}
func XDR_Fattr4_fsid(v *Fattr4_fsid) XdrType_Fattr4_fsid {
	return XdrType_Fattr4_fsid{XDR_Fsid4(v)}
}
func (XdrType_Fattr4_fsid) XdrTypeName() string { return "Fattr4_fsid" }
func (v XdrType_Fattr4_fsid) XdrUnwrap() XdrType { return v.XdrType_Fsid4 }
type XdrType_Fattr4_unique_handles struct {
	XdrType_bool
}
func XDR_Fattr4_unique_handles(v *Fattr4_unique_handles) XdrType_Fattr4_unique_handles {
	return XdrType_Fattr4_unique_handles{XDR_bool(v)}
}
func (XdrType_Fattr4_unique_handles) XdrTypeName() string { return "Fattr4_unique_handles" }
func (v XdrType_Fattr4_unique_handles) XdrUnwrap() XdrType { return v.XdrType_bool }
type XdrType_Fattr4_lease_time struct {
	XdrType_Uint32_t
}
func XDR_Fattr4_lease_time(v *Fattr4_lease_time) XdrType_Fattr4_lease_time {
	return XdrType_Fattr4_lease_time{XDR_Uint32_t(v)}
}
func (XdrType_Fattr4_lease_time) XdrTypeName() string { return "Fattr4_lease_time" }
func (v XdrType_Fattr4_lease_time) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Fattr4_rdattr_error struct {
	XdrType_Nfsstat4
}
func XDR_Fattr4_rdattr_error(v *Fattr4_rdattr_error) XdrType_Fattr4_rdattr_error {
	return XdrType_Fattr4_rdattr_error{XDR_Nfsstat4(v)}
}
func (XdrType_Fattr4_rdattr_error) XdrTypeName() string { return "Fattr4_rdattr_error" }
func (v XdrType_Fattr4_rdattr_error) XdrUnwrap() XdrType { return v.XdrType_Nfsstat4 }
type _XdrVec_unbounded_Nfsace4 []Nfsace4
func (_XdrVec_unbounded_Nfsace4) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Nfsace4) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Nfsace4 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Nfsace4 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Nfsace4) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Nfsace4) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Nfsace4, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Nfsace4) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Nfsace4(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Nfsace4) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Nfsace4) XdrTypeName() string { return "Nfsace4<>" }
func (v *_XdrVec_unbounded_Nfsace4) XdrPointer() interface{} { return (*[]Nfsace4)(v) }
func (v _XdrVec_unbounded_Nfsace4) XdrValue() interface{} { return ([]Nfsace4)(v) }
func (v *_XdrVec_unbounded_Nfsace4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Fattr4_acl struct {
	*_XdrVec_unbounded_Nfsace4
}
func XDR_Fattr4_acl(v *Fattr4_acl) XdrType_Fattr4_acl {
	return XdrType_Fattr4_acl{(*_XdrVec_unbounded_Nfsace4)(v)}
}
func (XdrType_Fattr4_acl) XdrTypeName() string { return "Fattr4_acl" }
func (v XdrType_Fattr4_acl) XdrUnwrap() XdrType { return v._XdrVec_unbounded_Nfsace4 }
type XdrType_Fattr4_aclsupport struct {
	XdrType_Uint32_t
}
func XDR_Fattr4_aclsupport(v *Fattr4_aclsupport) XdrType_Fattr4_aclsupport {
	return XdrType_Fattr4_aclsupport{XDR_Uint32_t(v)}
}
func (XdrType_Fattr4_aclsupport) XdrTypeName() string { return "Fattr4_aclsupport" }
func (v XdrType_Fattr4_aclsupport) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Fattr4_archive struct {
	XdrType_bool
}
func XDR_Fattr4_archive(v *Fattr4_archive) XdrType_Fattr4_archive {
	return XdrType_Fattr4_archive{XDR_bool(v)}
}
func (XdrType_Fattr4_archive) XdrTypeName() string { return "Fattr4_archive" }
func (v XdrType_Fattr4_archive) XdrUnwrap() XdrType { return v.XdrType_bool }
type XdrType_Fattr4_cansettime struct {
	XdrType_bool
}
func XDR_Fattr4_cansettime(v *Fattr4_cansettime) XdrType_Fattr4_cansettime {
	return XdrType_Fattr4_cansettime{XDR_bool(v)}
}
func (XdrType_Fattr4_cansettime) XdrTypeName() string { return "Fattr4_cansettime" }
func (v XdrType_Fattr4_cansettime) XdrUnwrap() XdrType { return v.XdrType_bool }
type XdrType_Fattr4_case_insensitive struct {
	XdrType_bool
}
func XDR_Fattr4_case_insensitive(v *Fattr4_case_insensitive) XdrType_Fattr4_case_insensitive {
	return XdrType_Fattr4_case_insensitive{XDR_bool(v)}
}
func (XdrType_Fattr4_case_insensitive) XdrTypeName() string { return "Fattr4_case_insensitive" }
func (v XdrType_Fattr4_case_insensitive) XdrUnwrap() XdrType { return v.XdrType_bool }
type XdrType_Fattr4_case_preserving struct {
	XdrType_bool
}
func XDR_Fattr4_case_preserving(v *Fattr4_case_preserving) XdrType_Fattr4_case_preserving {
	return XdrType_Fattr4_case_preserving{XDR_bool(v)}
}
func (XdrType_Fattr4_case_preserving) XdrTypeName() string { return "Fattr4_case_preserving" }
func (v XdrType_Fattr4_case_preserving) XdrUnwrap() XdrType { return v.XdrType_bool }
type XdrType_Fattr4_chown_restricted struct {
	XdrType_bool
}
func XDR_Fattr4_chown_restricted(v *Fattr4_chown_restricted) XdrType_Fattr4_chown_restricted {
	return XdrType_Fattr4_chown_restricted{XDR_bool(v)}
}
func (XdrType_Fattr4_chown_restricted) XdrTypeName() string { return "Fattr4_chown_restricted" }
func (v XdrType_Fattr4_chown_restricted) XdrUnwrap() XdrType { return v.XdrType_bool }
type XdrType_Fattr4_fileid struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_fileid(v *Fattr4_fileid) XdrType_Fattr4_fileid {
	return XdrType_Fattr4_fileid{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_fileid) XdrTypeName() string { return "Fattr4_fileid" }
func (v XdrType_Fattr4_fileid) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_files_avail struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_files_avail(v *Fattr4_files_avail) XdrType_Fattr4_files_avail {
	return XdrType_Fattr4_files_avail{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_files_avail) XdrTypeName() string { return "Fattr4_files_avail" }
func (v XdrType_Fattr4_files_avail) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_filehandle struct {
	XdrType_Nfs_fh4
}
func XDR_Fattr4_filehandle(v *Fattr4_filehandle) XdrType_Fattr4_filehandle {
	return XdrType_Fattr4_filehandle{XDR_Nfs_fh4(v)}
}
func (XdrType_Fattr4_filehandle) XdrTypeName() string { return "Fattr4_filehandle" }
func (v XdrType_Fattr4_filehandle) XdrUnwrap() XdrType { return v.XdrType_Nfs_fh4 }
type XdrType_Fattr4_files_free struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_files_free(v *Fattr4_files_free) XdrType_Fattr4_files_free {
	return XdrType_Fattr4_files_free{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_files_free) XdrTypeName() string { return "Fattr4_files_free" }
func (v XdrType_Fattr4_files_free) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_files_total struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_files_total(v *Fattr4_files_total) XdrType_Fattr4_files_total {
	return XdrType_Fattr4_files_total{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_files_total) XdrTypeName() string { return "Fattr4_files_total" }
func (v XdrType_Fattr4_files_total) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_fs_locations struct {
	XdrType_Fs_locations4
}
func XDR_Fattr4_fs_locations(v *Fattr4_fs_locations) XdrType_Fattr4_fs_locations {
	return XdrType_Fattr4_fs_locations{XDR_Fs_locations4(v)}
}
func (XdrType_Fattr4_fs_locations) XdrTypeName() string { return "Fattr4_fs_locations" }
func (v XdrType_Fattr4_fs_locations) XdrUnwrap() XdrType { return v.XdrType_Fs_locations4 }
type XdrType_Fattr4_hidden struct {
	XdrType_bool
}
func XDR_Fattr4_hidden(v *Fattr4_hidden) XdrType_Fattr4_hidden {
	return XdrType_Fattr4_hidden{XDR_bool(v)}
}
func (XdrType_Fattr4_hidden) XdrTypeName() string { return "Fattr4_hidden" }
func (v XdrType_Fattr4_hidden) XdrUnwrap() XdrType { return v.XdrType_bool }
type XdrType_Fattr4_homogeneous struct {
	XdrType_bool
}
func XDR_Fattr4_homogeneous(v *Fattr4_homogeneous) XdrType_Fattr4_homogeneous {
	return XdrType_Fattr4_homogeneous{XDR_bool(v)}
}
func (XdrType_Fattr4_homogeneous) XdrTypeName() string { return "Fattr4_homogeneous" }
func (v XdrType_Fattr4_homogeneous) XdrUnwrap() XdrType { return v.XdrType_bool }
type XdrType_Fattr4_maxfilesize struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_maxfilesize(v *Fattr4_maxfilesize) XdrType_Fattr4_maxfilesize {
	return XdrType_Fattr4_maxfilesize{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_maxfilesize) XdrTypeName() string { return "Fattr4_maxfilesize" }
func (v XdrType_Fattr4_maxfilesize) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_maxlink struct {
	XdrType_Uint32_t
}
func XDR_Fattr4_maxlink(v *Fattr4_maxlink) XdrType_Fattr4_maxlink {
	return XdrType_Fattr4_maxlink{XDR_Uint32_t(v)}
}
func (XdrType_Fattr4_maxlink) XdrTypeName() string { return "Fattr4_maxlink" }
func (v XdrType_Fattr4_maxlink) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Fattr4_maxname struct {
	XdrType_Uint32_t
}
func XDR_Fattr4_maxname(v *Fattr4_maxname) XdrType_Fattr4_maxname {
	return XdrType_Fattr4_maxname{XDR_Uint32_t(v)}
}
func (XdrType_Fattr4_maxname) XdrTypeName() string { return "Fattr4_maxname" }
func (v XdrType_Fattr4_maxname) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Fattr4_maxread struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_maxread(v *Fattr4_maxread) XdrType_Fattr4_maxread {
	return XdrType_Fattr4_maxread{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_maxread) XdrTypeName() string { return "Fattr4_maxread" }
func (v XdrType_Fattr4_maxread) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_maxwrite struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_maxwrite(v *Fattr4_maxwrite) XdrType_Fattr4_maxwrite {
	return XdrType_Fattr4_maxwrite{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_maxwrite) XdrTypeName() string { return "Fattr4_maxwrite" }
func (v XdrType_Fattr4_maxwrite) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_mimetype struct {
	XdrType_Utf8str_cs
}
func XDR_Fattr4_mimetype(v *Fattr4_mimetype) XdrType_Fattr4_mimetype {
	return XdrType_Fattr4_mimetype{XDR_Utf8str_cs(v)}
}
func (XdrType_Fattr4_mimetype) XdrTypeName() string { return "Fattr4_mimetype" }
func (v XdrType_Fattr4_mimetype) XdrUnwrap() XdrType { return v.XdrType_Utf8str_cs }
type XdrType_Fattr4_mode struct {
	XdrType_Mode4
}
func XDR_Fattr4_mode(v *Fattr4_mode) XdrType_Fattr4_mode {
	return XdrType_Fattr4_mode{XDR_Mode4(v)}
}
func (XdrType_Fattr4_mode) XdrTypeName() string { return "Fattr4_mode" }
func (v XdrType_Fattr4_mode) XdrUnwrap() XdrType { return &v.XdrType_Mode4 }
type XdrType_Fattr4_mounted_on_fileid struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_mounted_on_fileid(v *Fattr4_mounted_on_fileid) XdrType_Fattr4_mounted_on_fileid {
	return XdrType_Fattr4_mounted_on_fileid{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_mounted_on_fileid) XdrTypeName() string { return "Fattr4_mounted_on_fileid" }
func (v XdrType_Fattr4_mounted_on_fileid) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_no_trunc struct {
	XdrType_bool
}
func XDR_Fattr4_no_trunc(v *Fattr4_no_trunc) XdrType_Fattr4_no_trunc {
	return XdrType_Fattr4_no_trunc{XDR_bool(v)}
}
func (XdrType_Fattr4_no_trunc) XdrTypeName() string { return "Fattr4_no_trunc" }
func (v XdrType_Fattr4_no_trunc) XdrUnwrap() XdrType { return v.XdrType_bool }
type XdrType_Fattr4_numlinks struct {
	XdrType_Uint32_t
}
func XDR_Fattr4_numlinks(v *Fattr4_numlinks) XdrType_Fattr4_numlinks {
	return XdrType_Fattr4_numlinks{XDR_Uint32_t(v)}
}
func (XdrType_Fattr4_numlinks) XdrTypeName() string { return "Fattr4_numlinks" }
func (v XdrType_Fattr4_numlinks) XdrUnwrap() XdrType { return v.XdrType_Uint32_t }
type XdrType_Fattr4_owner struct {
	XdrType_Utf8str_mixed
}
func XDR_Fattr4_owner(v *Fattr4_owner) XdrType_Fattr4_owner {
	return XdrType_Fattr4_owner{XDR_Utf8str_mixed(v)}
}
func (XdrType_Fattr4_owner) XdrTypeName() string { return "Fattr4_owner" }
func (v XdrType_Fattr4_owner) XdrUnwrap() XdrType { return v.XdrType_Utf8str_mixed }
type XdrType_Fattr4_owner_group struct {
	XdrType_Utf8str_mixed
}
func XDR_Fattr4_owner_group(v *Fattr4_owner_group) XdrType_Fattr4_owner_group {
	return XdrType_Fattr4_owner_group{XDR_Utf8str_mixed(v)}
}
func (XdrType_Fattr4_owner_group) XdrTypeName() string { return "Fattr4_owner_group" }
func (v XdrType_Fattr4_owner_group) XdrUnwrap() XdrType { return v.XdrType_Utf8str_mixed }
type XdrType_Fattr4_quota_avail_hard struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_quota_avail_hard(v *Fattr4_quota_avail_hard) XdrType_Fattr4_quota_avail_hard {
	return XdrType_Fattr4_quota_avail_hard{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_quota_avail_hard) XdrTypeName() string { return "Fattr4_quota_avail_hard" }
func (v XdrType_Fattr4_quota_avail_hard) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_quota_avail_soft struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_quota_avail_soft(v *Fattr4_quota_avail_soft) XdrType_Fattr4_quota_avail_soft {
	return XdrType_Fattr4_quota_avail_soft{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_quota_avail_soft) XdrTypeName() string { return "Fattr4_quota_avail_soft" }
func (v XdrType_Fattr4_quota_avail_soft) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_quota_used struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_quota_used(v *Fattr4_quota_used) XdrType_Fattr4_quota_used {
	return XdrType_Fattr4_quota_used{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_quota_used) XdrTypeName() string { return "Fattr4_quota_used" }
func (v XdrType_Fattr4_quota_used) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_rawdev struct {
	XdrType_Specdata4
}
func XDR_Fattr4_rawdev(v *Fattr4_rawdev) XdrType_Fattr4_rawdev {
	return XdrType_Fattr4_rawdev{XDR_Specdata4(v)}
}
func (XdrType_Fattr4_rawdev) XdrTypeName() string { return "Fattr4_rawdev" }
func (v XdrType_Fattr4_rawdev) XdrUnwrap() XdrType { return v.XdrType_Specdata4 }
type XdrType_Fattr4_space_avail struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_space_avail(v *Fattr4_space_avail) XdrType_Fattr4_space_avail {
	return XdrType_Fattr4_space_avail{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_space_avail) XdrTypeName() string { return "Fattr4_space_avail" }
func (v XdrType_Fattr4_space_avail) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_space_free struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_space_free(v *Fattr4_space_free) XdrType_Fattr4_space_free {
	return XdrType_Fattr4_space_free{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_space_free) XdrTypeName() string { return "Fattr4_space_free" }
func (v XdrType_Fattr4_space_free) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_space_total struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_space_total(v *Fattr4_space_total) XdrType_Fattr4_space_total {
	return XdrType_Fattr4_space_total{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_space_total) XdrTypeName() string { return "Fattr4_space_total" }
func (v XdrType_Fattr4_space_total) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_space_used struct {
	XdrType_Uint64_t
}
func XDR_Fattr4_space_used(v *Fattr4_space_used) XdrType_Fattr4_space_used {
	return XdrType_Fattr4_space_used{XDR_Uint64_t(v)}
}
func (XdrType_Fattr4_space_used) XdrTypeName() string { return "Fattr4_space_used" }
func (v XdrType_Fattr4_space_used) XdrUnwrap() XdrType { return v.XdrType_Uint64_t }
type XdrType_Fattr4_system struct {
	XdrType_bool
}
func XDR_Fattr4_system(v *Fattr4_system) XdrType_Fattr4_system {
	return XdrType_Fattr4_system{XDR_bool(v)}
}
func (XdrType_Fattr4_system) XdrTypeName() string { return "Fattr4_system" }
func (v XdrType_Fattr4_system) XdrUnwrap() XdrType { return v.XdrType_bool }
type XdrType_Fattr4_time_access struct {
	XdrType_Nfstime4
}
func XDR_Fattr4_time_access(v *Fattr4_time_access) XdrType_Fattr4_time_access {
	return XdrType_Fattr4_time_access{XDR_Nfstime4(v)}
}
func (XdrType_Fattr4_time_access) XdrTypeName() string { return "Fattr4_time_access" }
func (v XdrType_Fattr4_time_access) XdrUnwrap() XdrType { return v.XdrType_Nfstime4 }
type XdrType_Fattr4_time_access_set struct {
	XdrType_Settime4
}
func XDR_Fattr4_time_access_set(v *Fattr4_time_access_set) XdrType_Fattr4_time_access_set {
	return XdrType_Fattr4_time_access_set{XDR_Settime4(v)}
}
func (XdrType_Fattr4_time_access_set) XdrTypeName() string { return "Fattr4_time_access_set" }
func (v XdrType_Fattr4_time_access_set) XdrUnwrap() XdrType { return v.XdrType_Settime4 }
type XdrType_Fattr4_time_backup struct {
	XdrType_Nfstime4
}
func XDR_Fattr4_time_backup(v *Fattr4_time_backup) XdrType_Fattr4_time_backup {
	return XdrType_Fattr4_time_backup{XDR_Nfstime4(v)}
}
func (XdrType_Fattr4_time_backup) XdrTypeName() string { return "Fattr4_time_backup" }
func (v XdrType_Fattr4_time_backup) XdrUnwrap() XdrType { return v.XdrType_Nfstime4 }
type XdrType_Fattr4_time_create struct {
	XdrType_Nfstime4
}
func XDR_Fattr4_time_create(v *Fattr4_time_create) XdrType_Fattr4_time_create {
	return XdrType_Fattr4_time_create{XDR_Nfstime4(v)}
}
func (XdrType_Fattr4_time_create) XdrTypeName() string { return "Fattr4_time_create" }
func (v XdrType_Fattr4_time_create) XdrUnwrap() XdrType { return v.XdrType_Nfstime4 }
type XdrType_Fattr4_time_delta struct {
	XdrType_Nfstime4
}
func XDR_Fattr4_time_delta(v *Fattr4_time_delta) XdrType_Fattr4_time_delta {
	return XdrType_Fattr4_time_delta{XDR_Nfstime4(v)}
}
func (XdrType_Fattr4_time_delta) XdrTypeName() string { return "Fattr4_time_delta" }
func (v XdrType_Fattr4_time_delta) XdrUnwrap() XdrType { return v.XdrType_Nfstime4 }
type XdrType_Fattr4_time_metadata struct {
	XdrType_Nfstime4
}
func XDR_Fattr4_time_metadata(v *Fattr4_time_metadata) XdrType_Fattr4_time_metadata {
	return XdrType_Fattr4_time_metadata{XDR_Nfstime4(v)}
}
func (XdrType_Fattr4_time_metadata) XdrTypeName() string { return "Fattr4_time_metadata" }
func (v XdrType_Fattr4_time_metadata) XdrUnwrap() XdrType { return v.XdrType_Nfstime4 }
type XdrType_Fattr4_time_modify struct {
	XdrType_Nfstime4
}
func XDR_Fattr4_time_modify(v *Fattr4_time_modify) XdrType_Fattr4_time_modify {
	return XdrType_Fattr4_time_modify{XDR_Nfstime4(v)}
}
func (XdrType_Fattr4_time_modify) XdrTypeName() string { return "Fattr4_time_modify" }
func (v XdrType_Fattr4_time_modify) XdrUnwrap() XdrType { return v.XdrType_Nfstime4 }
type XdrType_Fattr4_time_modify_set struct {
	XdrType_Settime4
}
func XDR_Fattr4_time_modify_set(v *Fattr4_time_modify_set) XdrType_Fattr4_time_modify_set {
	return XdrType_Fattr4_time_modify_set{XDR_Settime4(v)}
}
func (XdrType_Fattr4_time_modify_set) XdrTypeName() string { return "Fattr4_time_modify_set" }
func (v XdrType_Fattr4_time_modify_set) XdrUnwrap() XdrType { return v.XdrType_Settime4 }
type XdrType_Attrlist4 struct {
	XdrVecOpaque
}
func XDR_Attrlist4(v *Attrlist4) XdrType_Attrlist4 {
	return XdrType_Attrlist4{XdrVecOpaque{v, 0xffffffff}}
}
func (XdrType_Attrlist4) XdrTypeName() string { return "Attrlist4" }
func (v XdrType_Attrlist4) XdrUnwrap() XdrType { return v.XdrVecOpaque }
type XdrType_Fattr4 = *Fattr4
func (v *Fattr4) XdrPointer() interface{} { return v }
func (Fattr4) XdrTypeName() string { return "Fattr4" }
func (v Fattr4) XdrValue() interface{} { return v }
func (v *Fattr4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Fattr4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sattrmask", name), XDR_Bitmap4(&v.Attrmask))
	x.Marshal(x.Sprintf("%sattr_vals", name), XDR_Attrlist4(&v.Attr_vals))
}
func XDR_Fattr4(v *Fattr4) *Fattr4 { return v }
type XdrType_Change_info4 = *Change_info4
func (v *Change_info4) XdrPointer() interface{} { return v }
func (Change_info4) XdrTypeName() string { return "Change_info4" }
func (v Change_info4) XdrValue() interface{} { return v }
func (v *Change_info4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Change_info4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%satomic", name), XDR_bool(&v.Atomic))
	x.Marshal(x.Sprintf("%sbefore", name), XDR_Changeid4(&v.Before))
	x.Marshal(x.Sprintf("%safter", name), XDR_Changeid4(&v.After))
}
func XDR_Change_info4(v *Change_info4) *Change_info4 { return v }
type XdrType_Clientaddr4 = *Clientaddr4
func (v *Clientaddr4) XdrPointer() interface{} { return v }
func (Clientaddr4) XdrTypeName() string { return "Clientaddr4" }
func (v Clientaddr4) XdrValue() interface{} { return v }
func (v *Clientaddr4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Clientaddr4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sr_netid", name), XdrString{&v.R_netid, 0xffffffff})
	x.Marshal(x.Sprintf("%sr_addr", name), XdrString{&v.R_addr, 0xffffffff})
}
func XDR_Clientaddr4(v *Clientaddr4) *Clientaddr4 { return v }
type XdrType_Cb_client4 = *Cb_client4
func (v *Cb_client4) XdrPointer() interface{} { return v }
func (Cb_client4) XdrTypeName() string { return "Cb_client4" }
func (v Cb_client4) XdrValue() interface{} { return v }
func (v *Cb_client4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Cb_client4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scb_program", name), XDR_Uint32_t(&v.Cb_program))
	x.Marshal(x.Sprintf("%scb_location", name), XDR_Clientaddr4(&v.Cb_location))
}
func XDR_Cb_client4(v *Cb_client4) *Cb_client4 { return v }
type _XdrArray_12_opaque [12]byte
func (v *_XdrArray_12_opaque) GetByteSlice() []byte { return v[:] }
func (v *_XdrArray_12_opaque) XdrTypeName() string { return "opaque[]" }
func (v *_XdrArray_12_opaque) XdrValue() interface{} { return v[:] }
func (v *_XdrArray_12_opaque) XdrPointer() interface{} { return (*[12]byte)(v) }
func (v *_XdrArray_12_opaque) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *_XdrArray_12_opaque) String() string { return fmt.Sprintf("%x", v[:]) }
func (v *_XdrArray_12_opaque) Scan(ss fmt.ScanState, c rune) error {
	return XdrArrayOpaqueScan(v[:], ss, c)
}
func (_XdrArray_12_opaque) XdrArraySize() uint32 {
	const bound uint32 = 12 // Force error if not const or doesn't fit
	return bound
}
type XdrType_Stateid4 = *Stateid4
func (v *Stateid4) XdrPointer() interface{} { return v }
func (Stateid4) XdrTypeName() string { return "Stateid4" }
func (v Stateid4) XdrValue() interface{} { return v }
func (v *Stateid4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Stateid4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sseqid", name), XDR_Uint32_t(&v.Seqid))
	x.Marshal(x.Sprintf("%sother", name), (*_XdrArray_12_opaque)(&v.Other))
}
func XDR_Stateid4(v *Stateid4) *Stateid4 { return v }
type XdrType_Nfs_client_id4 = *Nfs_client_id4
func (v *Nfs_client_id4) XdrPointer() interface{} { return v }
func (Nfs_client_id4) XdrTypeName() string { return "Nfs_client_id4" }
func (v Nfs_client_id4) XdrValue() interface{} { return v }
func (v *Nfs_client_id4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Nfs_client_id4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sverifier", name), XDR_Verifier4(&v.Verifier))
	x.Marshal(x.Sprintf("%sid", name), XdrVecOpaque{&v.Id, NFS4_OPAQUE_LIMIT})
}
func XDR_Nfs_client_id4(v *Nfs_client_id4) *Nfs_client_id4 { return v }
type XdrType_Open_owner4 = *Open_owner4
func (v *Open_owner4) XdrPointer() interface{} { return v }
func (Open_owner4) XdrTypeName() string { return "Open_owner4" }
func (v Open_owner4) XdrValue() interface{} { return v }
func (v *Open_owner4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Open_owner4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sclientid", name), XDR_Clientid4(&v.Clientid))
	x.Marshal(x.Sprintf("%sowner", name), XdrVecOpaque{&v.Owner, NFS4_OPAQUE_LIMIT})
}
func XDR_Open_owner4(v *Open_owner4) *Open_owner4 { return v }
type XdrType_Lock_owner4 = *Lock_owner4
func (v *Lock_owner4) XdrPointer() interface{} { return v }
func (Lock_owner4) XdrTypeName() string { return "Lock_owner4" }
func (v Lock_owner4) XdrValue() interface{} { return v }
func (v *Lock_owner4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Lock_owner4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sclientid", name), XDR_Clientid4(&v.Clientid))
	x.Marshal(x.Sprintf("%sowner", name), XdrVecOpaque{&v.Owner, NFS4_OPAQUE_LIMIT})
}
func XDR_Lock_owner4(v *Lock_owner4) *Lock_owner4 { return v }
var _XdrNames_Nfs_lock_type4 = map[int32]string{
	int32(READ_LT): "READ_LT",
	int32(WRITE_LT): "WRITE_LT",
	int32(READW_LT): "READW_LT",
	int32(WRITEW_LT): "WRITEW_LT",
}
var _XdrValues_Nfs_lock_type4 = map[string]int32{
	"READ_LT": int32(READ_LT),
	"WRITE_LT": int32(WRITE_LT),
	"READW_LT": int32(READW_LT),
	"WRITEW_LT": int32(WRITEW_LT),
}
func (Nfs_lock_type4) XdrEnumNames() map[int32]string {
	return _XdrNames_Nfs_lock_type4
}
func (v Nfs_lock_type4) String() string {
	if s, ok := _XdrNames_Nfs_lock_type4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Nfs_lock_type4#%d", v)
}
func (v *Nfs_lock_type4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Nfs_lock_type4[stok]; ok {
			*v = Nfs_lock_type4(val)
			return nil
		} else if stok == "Nfs_lock_type4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Nfs_lock_type4.", stok))
	}
}
func (v Nfs_lock_type4) GetU32() uint32 { return uint32(v) }
func (v *Nfs_lock_type4) SetU32(n uint32) { *v = Nfs_lock_type4(n) }
func (v *Nfs_lock_type4) XdrPointer() interface{} { return v }
func (Nfs_lock_type4) XdrTypeName() string { return "Nfs_lock_type4" }
func (v Nfs_lock_type4) XdrValue() interface{} { return v }
func (v *Nfs_lock_type4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Nfs_lock_type4 = *Nfs_lock_type4
func XDR_Nfs_lock_type4(v *Nfs_lock_type4) *Nfs_lock_type4 { return v }
func (v *Nfs_lock_type4) XdrInitialize() {
	switch Nfs_lock_type4(0) {
	case READ_LT, WRITE_LT, READW_LT, WRITEW_LT:
	default:
		if *v == Nfs_lock_type4(0) { *v = READ_LT }
	}
}
type XdrType_ACCESS4args = *ACCESS4args
func (v *ACCESS4args) XdrPointer() interface{} { return v }
func (ACCESS4args) XdrTypeName() string { return "ACCESS4args" }
func (v ACCESS4args) XdrValue() interface{} { return v }
func (v *ACCESS4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ACCESS4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%saccess", name), XDR_Uint32_t(&v.Access))
}
func XDR_ACCESS4args(v *ACCESS4args) *ACCESS4args { return v }
type XdrType_ACCESS4resok = *ACCESS4resok
func (v *ACCESS4resok) XdrPointer() interface{} { return v }
func (ACCESS4resok) XdrTypeName() string { return "ACCESS4resok" }
func (v ACCESS4resok) XdrValue() interface{} { return v }
func (v *ACCESS4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ACCESS4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssupported", name), XDR_Uint32_t(&v.Supported))
	x.Marshal(x.Sprintf("%saccess", name), XDR_Uint32_t(&v.Access))
}
func XDR_ACCESS4resok(v *ACCESS4resok) *ACCESS4resok { return v }
func (u *ACCESS4res) Resok4() *ACCESS4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*ACCESS4resok); ok {
			return v
		} else {
			var zero ACCESS4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("ACCESS4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u ACCESS4res) XdrValid() bool {
	return true
}
func (u *ACCESS4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *ACCESS4res) XdrUnionTagName() string {
	return "Status"
}
func (u *ACCESS4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_ACCESS4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *ACCESS4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_ACCESS4res = *ACCESS4res
func (v *ACCESS4res) XdrPointer() interface{} { return v }
func (ACCESS4res) XdrTypeName() string { return "ACCESS4res" }
func (v ACCESS4res) XdrValue() interface{} { return v }
func (v *ACCESS4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *ACCESS4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_ACCESS4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_ACCESS4res(v *ACCESS4res) *ACCESS4res { return v}
type XdrType_CLOSE4args = *CLOSE4args
func (v *CLOSE4args) XdrPointer() interface{} { return v }
func (CLOSE4args) XdrTypeName() string { return "CLOSE4args" }
func (v CLOSE4args) XdrValue() interface{} { return v }
func (v *CLOSE4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CLOSE4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sseqid", name), XDR_Seqid4(&v.Seqid))
	x.Marshal(x.Sprintf("%sopen_stateid", name), XDR_Stateid4(&v.Open_stateid))
}
func XDR_CLOSE4args(v *CLOSE4args) *CLOSE4args { return v }
func (u *CLOSE4res) Open_stateid() *Stateid4 {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*Stateid4); ok {
			return v
		} else {
			var zero Stateid4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("CLOSE4res.Open_stateid accessed when Status == %v", u.Status)
		return nil
	}
}
func (u CLOSE4res) XdrValid() bool {
	return true
}
func (u *CLOSE4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *CLOSE4res) XdrUnionTagName() string {
	return "Status"
}
func (u *CLOSE4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_Stateid4(u.Open_stateid())
	default:
		return nil
	}
}
func (u *CLOSE4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Open_stateid"
	default:
		return ""
	}
}
type XdrType_CLOSE4res = *CLOSE4res
func (v *CLOSE4res) XdrPointer() interface{} { return v }
func (CLOSE4res) XdrTypeName() string { return "CLOSE4res" }
func (v CLOSE4res) XdrValue() interface{} { return v }
func (v *CLOSE4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *CLOSE4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sopen_stateid", name), XDR_Stateid4(u.Open_stateid()))
		return
	default:
		return
	}
}
func XDR_CLOSE4res(v *CLOSE4res) *CLOSE4res { return v}
type XdrType_COMMIT4args = *COMMIT4args
func (v *COMMIT4args) XdrPointer() interface{} { return v }
func (COMMIT4args) XdrTypeName() string { return "COMMIT4args" }
func (v COMMIT4args) XdrValue() interface{} { return v }
func (v *COMMIT4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *COMMIT4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soffset", name), XDR_Offset4(&v.Offset))
	x.Marshal(x.Sprintf("%scount", name), XDR_Count4(&v.Count))
}
func XDR_COMMIT4args(v *COMMIT4args) *COMMIT4args { return v }
type XdrType_COMMIT4resok = *COMMIT4resok
func (v *COMMIT4resok) XdrPointer() interface{} { return v }
func (COMMIT4resok) XdrTypeName() string { return "COMMIT4resok" }
func (v COMMIT4resok) XdrValue() interface{} { return v }
func (v *COMMIT4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *COMMIT4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%swriteverf", name), XDR_Verifier4(&v.Writeverf))
}
func XDR_COMMIT4resok(v *COMMIT4resok) *COMMIT4resok { return v }
func (u *COMMIT4res) Resok4() *COMMIT4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*COMMIT4resok); ok {
			return v
		} else {
			var zero COMMIT4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("COMMIT4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u COMMIT4res) XdrValid() bool {
	return true
}
func (u *COMMIT4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *COMMIT4res) XdrUnionTagName() string {
	return "Status"
}
func (u *COMMIT4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_COMMIT4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *COMMIT4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_COMMIT4res = *COMMIT4res
func (v *COMMIT4res) XdrPointer() interface{} { return v }
func (COMMIT4res) XdrTypeName() string { return "COMMIT4res" }
func (v COMMIT4res) XdrValue() interface{} { return v }
func (v *COMMIT4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *COMMIT4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_COMMIT4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_COMMIT4res(v *COMMIT4res) *COMMIT4res { return v}
func (u *Createtype4) Linkdata() *Linktext4 {
	switch u.Type {
	case NF4LNK:
		if v, ok := u.U.(*Linktext4); ok {
			return v
		} else {
			var zero Linktext4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Createtype4.Linkdata accessed when Type == %v", u.Type)
		return nil
	}
}
func (u *Createtype4) Devdata() *Specdata4 {
	switch u.Type {
	case NF4BLK, NF4CHR:
		if v, ok := u.U.(*Specdata4); ok {
			return v
		} else {
			var zero Specdata4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Createtype4.Devdata accessed when Type == %v", u.Type)
		return nil
	}
}
func (u Createtype4) XdrValid() bool {
	return true
}
func (u *Createtype4) XdrUnionTag() XdrNum32 {
	return XDR_Nfs_ftype4(&u.Type)
}
func (u *Createtype4) XdrUnionTagName() string {
	return "Type"
}
func (u *Createtype4) XdrUnionBody() XdrType {
	switch u.Type {
	case NF4LNK:
		return XDR_Linktext4(u.Linkdata())
	case NF4BLK, NF4CHR:
		return XDR_Specdata4(u.Devdata())
	case NF4SOCK, NF4FIFO, NF4DIR:
		return nil
	default:
		return nil
	}
}
func (u *Createtype4) XdrUnionBodyName() string {
	switch u.Type {
	case NF4LNK:
		return "Linkdata"
	case NF4BLK, NF4CHR:
		return "Devdata"
	case NF4SOCK, NF4FIFO, NF4DIR:
		return ""
	default:
		return ""
	}
}
type XdrType_Createtype4 = *Createtype4
func (v *Createtype4) XdrPointer() interface{} { return v }
func (Createtype4) XdrTypeName() string { return "Createtype4" }
func (v Createtype4) XdrValue() interface{} { return v }
func (v *Createtype4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Createtype4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfs_ftype4(&u.Type).XdrMarshal(x, x.Sprintf("%stype", name))
	switch u.Type {
	case NF4LNK:
		x.Marshal(x.Sprintf("%slinkdata", name), XDR_Linktext4(u.Linkdata()))
		return
	case NF4BLK, NF4CHR:
		x.Marshal(x.Sprintf("%sdevdata", name), XDR_Specdata4(u.Devdata()))
		return
	case NF4SOCK, NF4FIFO, NF4DIR:
		return
	default:
		return
	}
}
func XDR_Createtype4(v *Createtype4) *Createtype4 { return v}
type XdrType_CREATE4args = *CREATE4args
func (v *CREATE4args) XdrPointer() interface{} { return v }
func (CREATE4args) XdrTypeName() string { return "CREATE4args" }
func (v CREATE4args) XdrValue() interface{} { return v }
func (v *CREATE4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CREATE4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sobjtype", name), XDR_Createtype4(&v.Objtype))
	x.Marshal(x.Sprintf("%sobjname", name), XDR_Component4(&v.Objname))
	x.Marshal(x.Sprintf("%screateattrs", name), XDR_Fattr4(&v.Createattrs))
}
func XDR_CREATE4args(v *CREATE4args) *CREATE4args { return v }
type XdrType_CREATE4resok = *CREATE4resok
func (v *CREATE4resok) XdrPointer() interface{} { return v }
func (CREATE4resok) XdrTypeName() string { return "CREATE4resok" }
func (v CREATE4resok) XdrValue() interface{} { return v }
func (v *CREATE4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CREATE4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scinfo", name), XDR_Change_info4(&v.Cinfo))
	x.Marshal(x.Sprintf("%sattrset", name), XDR_Bitmap4(&v.Attrset))
}
func XDR_CREATE4resok(v *CREATE4resok) *CREATE4resok { return v }
func (u *CREATE4res) Resok4() *CREATE4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*CREATE4resok); ok {
			return v
		} else {
			var zero CREATE4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("CREATE4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u CREATE4res) XdrValid() bool {
	return true
}
func (u *CREATE4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *CREATE4res) XdrUnionTagName() string {
	return "Status"
}
func (u *CREATE4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_CREATE4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *CREATE4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_CREATE4res = *CREATE4res
func (v *CREATE4res) XdrPointer() interface{} { return v }
func (CREATE4res) XdrTypeName() string { return "CREATE4res" }
func (v CREATE4res) XdrValue() interface{} { return v }
func (v *CREATE4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *CREATE4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_CREATE4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_CREATE4res(v *CREATE4res) *CREATE4res { return v}
type XdrType_DELEGPURGE4args = *DELEGPURGE4args
func (v *DELEGPURGE4args) XdrPointer() interface{} { return v }
func (DELEGPURGE4args) XdrTypeName() string { return "DELEGPURGE4args" }
func (v DELEGPURGE4args) XdrValue() interface{} { return v }
func (v *DELEGPURGE4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DELEGPURGE4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sclientid", name), XDR_Clientid4(&v.Clientid))
}
func XDR_DELEGPURGE4args(v *DELEGPURGE4args) *DELEGPURGE4args { return v }
type XdrType_DELEGPURGE4res = *DELEGPURGE4res
func (v *DELEGPURGE4res) XdrPointer() interface{} { return v }
func (DELEGPURGE4res) XdrTypeName() string { return "DELEGPURGE4res" }
func (v DELEGPURGE4res) XdrValue() interface{} { return v }
func (v *DELEGPURGE4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DELEGPURGE4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_DELEGPURGE4res(v *DELEGPURGE4res) *DELEGPURGE4res { return v }
type XdrType_DELEGRETURN4args = *DELEGRETURN4args
func (v *DELEGRETURN4args) XdrPointer() interface{} { return v }
func (DELEGRETURN4args) XdrTypeName() string { return "DELEGRETURN4args" }
func (v DELEGRETURN4args) XdrValue() interface{} { return v }
func (v *DELEGRETURN4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DELEGRETURN4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdeleg_stateid", name), XDR_Stateid4(&v.Deleg_stateid))
}
func XDR_DELEGRETURN4args(v *DELEGRETURN4args) *DELEGRETURN4args { return v }
type XdrType_DELEGRETURN4res = *DELEGRETURN4res
func (v *DELEGRETURN4res) XdrPointer() interface{} { return v }
func (DELEGRETURN4res) XdrTypeName() string { return "DELEGRETURN4res" }
func (v DELEGRETURN4res) XdrValue() interface{} { return v }
func (v *DELEGRETURN4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DELEGRETURN4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_DELEGRETURN4res(v *DELEGRETURN4res) *DELEGRETURN4res { return v }
type XdrType_GETATTR4args = *GETATTR4args
func (v *GETATTR4args) XdrPointer() interface{} { return v }
func (GETATTR4args) XdrTypeName() string { return "GETATTR4args" }
func (v GETATTR4args) XdrValue() interface{} { return v }
func (v *GETATTR4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *GETATTR4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sattr_request", name), XDR_Bitmap4(&v.Attr_request))
}
func XDR_GETATTR4args(v *GETATTR4args) *GETATTR4args { return v }
type XdrType_GETATTR4resok = *GETATTR4resok
func (v *GETATTR4resok) XdrPointer() interface{} { return v }
func (GETATTR4resok) XdrTypeName() string { return "GETATTR4resok" }
func (v GETATTR4resok) XdrValue() interface{} { return v }
func (v *GETATTR4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *GETATTR4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sobj_attributes", name), XDR_Fattr4(&v.Obj_attributes))
}
func XDR_GETATTR4resok(v *GETATTR4resok) *GETATTR4resok { return v }
func (u *GETATTR4res) Resok4() *GETATTR4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*GETATTR4resok); ok {
			return v
		} else {
			var zero GETATTR4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("GETATTR4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u GETATTR4res) XdrValid() bool {
	return true
}
func (u *GETATTR4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *GETATTR4res) XdrUnionTagName() string {
	return "Status"
}
func (u *GETATTR4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_GETATTR4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *GETATTR4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_GETATTR4res = *GETATTR4res
func (v *GETATTR4res) XdrPointer() interface{} { return v }
func (GETATTR4res) XdrTypeName() string { return "GETATTR4res" }
func (v GETATTR4res) XdrValue() interface{} { return v }
func (v *GETATTR4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *GETATTR4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_GETATTR4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_GETATTR4res(v *GETATTR4res) *GETATTR4res { return v}
type XdrType_GETFH4resok = *GETFH4resok
func (v *GETFH4resok) XdrPointer() interface{} { return v }
func (GETFH4resok) XdrTypeName() string { return "GETFH4resok" }
func (v GETFH4resok) XdrValue() interface{} { return v }
func (v *GETFH4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *GETFH4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sobject", name), XDR_Nfs_fh4(&v.Object))
}
func XDR_GETFH4resok(v *GETFH4resok) *GETFH4resok { return v }
func (u *GETFH4res) Resok4() *GETFH4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*GETFH4resok); ok {
			return v
		} else {
			var zero GETFH4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("GETFH4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u GETFH4res) XdrValid() bool {
	return true
}
func (u *GETFH4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *GETFH4res) XdrUnionTagName() string {
	return "Status"
}
func (u *GETFH4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_GETFH4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *GETFH4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_GETFH4res = *GETFH4res
func (v *GETFH4res) XdrPointer() interface{} { return v }
func (GETFH4res) XdrTypeName() string { return "GETFH4res" }
func (v GETFH4res) XdrValue() interface{} { return v }
func (v *GETFH4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *GETFH4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_GETFH4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_GETFH4res(v *GETFH4res) *GETFH4res { return v}
type XdrType_LINK4args = *LINK4args
func (v *LINK4args) XdrPointer() interface{} { return v }
func (LINK4args) XdrTypeName() string { return "LINK4args" }
func (v LINK4args) XdrValue() interface{} { return v }
func (v *LINK4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LINK4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snewname", name), XDR_Component4(&v.Newname))
}
func XDR_LINK4args(v *LINK4args) *LINK4args { return v }
type XdrType_LINK4resok = *LINK4resok
func (v *LINK4resok) XdrPointer() interface{} { return v }
func (LINK4resok) XdrTypeName() string { return "LINK4resok" }
func (v LINK4resok) XdrValue() interface{} { return v }
func (v *LINK4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LINK4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scinfo", name), XDR_Change_info4(&v.Cinfo))
}
func XDR_LINK4resok(v *LINK4resok) *LINK4resok { return v }
func (u *LINK4res) Resok4() *LINK4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*LINK4resok); ok {
			return v
		} else {
			var zero LINK4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("LINK4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u LINK4res) XdrValid() bool {
	return true
}
func (u *LINK4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *LINK4res) XdrUnionTagName() string {
	return "Status"
}
func (u *LINK4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_LINK4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *LINK4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_LINK4res = *LINK4res
func (v *LINK4res) XdrPointer() interface{} { return v }
func (LINK4res) XdrTypeName() string { return "LINK4res" }
func (v LINK4res) XdrValue() interface{} { return v }
func (v *LINK4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LINK4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_LINK4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_LINK4res(v *LINK4res) *LINK4res { return v}
type XdrType_Open_to_lock_owner4 = *Open_to_lock_owner4
func (v *Open_to_lock_owner4) XdrPointer() interface{} { return v }
func (Open_to_lock_owner4) XdrTypeName() string { return "Open_to_lock_owner4" }
func (v Open_to_lock_owner4) XdrValue() interface{} { return v }
func (v *Open_to_lock_owner4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Open_to_lock_owner4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sopen_seqid", name), XDR_Seqid4(&v.Open_seqid))
	x.Marshal(x.Sprintf("%sopen_stateid", name), XDR_Stateid4(&v.Open_stateid))
	x.Marshal(x.Sprintf("%slock_seqid", name), XDR_Seqid4(&v.Lock_seqid))
	x.Marshal(x.Sprintf("%slock_owner", name), XDR_Lock_owner4(&v.Lock_owner))
}
func XDR_Open_to_lock_owner4(v *Open_to_lock_owner4) *Open_to_lock_owner4 { return v }
type XdrType_Exist_lock_owner4 = *Exist_lock_owner4
func (v *Exist_lock_owner4) XdrPointer() interface{} { return v }
func (Exist_lock_owner4) XdrTypeName() string { return "Exist_lock_owner4" }
func (v Exist_lock_owner4) XdrValue() interface{} { return v }
func (v *Exist_lock_owner4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Exist_lock_owner4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slock_stateid", name), XDR_Stateid4(&v.Lock_stateid))
	x.Marshal(x.Sprintf("%slock_seqid", name), XDR_Seqid4(&v.Lock_seqid))
}
func XDR_Exist_lock_owner4(v *Exist_lock_owner4) *Exist_lock_owner4 { return v }
var _XdrTags_Locker4 = map[int32]bool{
	XdrToI32(true): true,
	XdrToI32(false): true,
}
func (_ Locker4) XdrValidTags() map[int32]bool {
	return _XdrTags_Locker4
}
func (u *Locker4) Open_owner() *Open_to_lock_owner4 {
	switch u.New_lock_owner {
	case true:
		if v, ok := u.U.(*Open_to_lock_owner4); ok {
			return v
		} else {
			var zero Open_to_lock_owner4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Locker4.Open_owner accessed when New_lock_owner == %v", u.New_lock_owner)
		return nil
	}
}
func (u *Locker4) Lock_owner() *Exist_lock_owner4 {
	switch u.New_lock_owner {
	case false:
		if v, ok := u.U.(*Exist_lock_owner4); ok {
			return v
		} else {
			var zero Exist_lock_owner4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Locker4.Lock_owner accessed when New_lock_owner == %v", u.New_lock_owner)
		return nil
	}
}
func (u Locker4) XdrValid() bool {
	switch u.New_lock_owner {
	case true,false:
		return true
	}
	return false
}
func (u *Locker4) XdrUnionTag() XdrNum32 {
	return XDR_bool(&u.New_lock_owner)
}
func (u *Locker4) XdrUnionTagName() string {
	return "New_lock_owner"
}
func (u *Locker4) XdrUnionBody() XdrType {
	switch u.New_lock_owner {
	case true:
		return XDR_Open_to_lock_owner4(u.Open_owner())
	case false:
		return XDR_Exist_lock_owner4(u.Lock_owner())
	}
	return nil
}
func (u *Locker4) XdrUnionBodyName() string {
	switch u.New_lock_owner {
	case true:
		return "Open_owner"
	case false:
		return "Lock_owner"
	}
	return ""
}
type XdrType_Locker4 = *Locker4
func (v *Locker4) XdrPointer() interface{} { return v }
func (Locker4) XdrTypeName() string { return "Locker4" }
func (v Locker4) XdrValue() interface{} { return v }
func (v *Locker4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Locker4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_bool(&u.New_lock_owner).XdrMarshal(x, x.Sprintf("%snew_lock_owner", name))
	switch u.New_lock_owner {
	case true:
		x.Marshal(x.Sprintf("%sopen_owner", name), XDR_Open_to_lock_owner4(u.Open_owner()))
		return
	case false:
		x.Marshal(x.Sprintf("%slock_owner", name), XDR_Exist_lock_owner4(u.Lock_owner()))
		return
	}
	XdrPanic("invalid New_lock_owner (%v) in Locker4", u.New_lock_owner)
}
func XDR_Locker4(v *Locker4) *Locker4 { return v}
type XdrType_LOCK4args = *LOCK4args
func (v *LOCK4args) XdrPointer() interface{} { return v }
func (LOCK4args) XdrTypeName() string { return "LOCK4args" }
func (v LOCK4args) XdrValue() interface{} { return v }
func (v *LOCK4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LOCK4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slocktype", name), XDR_Nfs_lock_type4(&v.Locktype))
	x.Marshal(x.Sprintf("%sreclaim", name), XDR_bool(&v.Reclaim))
	x.Marshal(x.Sprintf("%soffset", name), XDR_Offset4(&v.Offset))
	x.Marshal(x.Sprintf("%slength", name), XDR_Length4(&v.Length))
	x.Marshal(x.Sprintf("%slocker", name), XDR_Locker4(&v.Locker))
}
func XDR_LOCK4args(v *LOCK4args) *LOCK4args { return v }
type XdrType_LOCK4denied = *LOCK4denied
func (v *LOCK4denied) XdrPointer() interface{} { return v }
func (LOCK4denied) XdrTypeName() string { return "LOCK4denied" }
func (v LOCK4denied) XdrValue() interface{} { return v }
func (v *LOCK4denied) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LOCK4denied) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soffset", name), XDR_Offset4(&v.Offset))
	x.Marshal(x.Sprintf("%slength", name), XDR_Length4(&v.Length))
	x.Marshal(x.Sprintf("%slocktype", name), XDR_Nfs_lock_type4(&v.Locktype))
	x.Marshal(x.Sprintf("%sowner", name), XDR_Lock_owner4(&v.Owner))
}
func XDR_LOCK4denied(v *LOCK4denied) *LOCK4denied { return v }
type XdrType_LOCK4resok = *LOCK4resok
func (v *LOCK4resok) XdrPointer() interface{} { return v }
func (LOCK4resok) XdrTypeName() string { return "LOCK4resok" }
func (v LOCK4resok) XdrValue() interface{} { return v }
func (v *LOCK4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LOCK4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slock_stateid", name), XDR_Stateid4(&v.Lock_stateid))
}
func XDR_LOCK4resok(v *LOCK4resok) *LOCK4resok { return v }
func (u *LOCK4res) Resok4() *LOCK4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*LOCK4resok); ok {
			return v
		} else {
			var zero LOCK4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("LOCK4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u *LOCK4res) Denied() *LOCK4denied {
	switch u.Status {
	case NFS4ERR_DENIED:
		if v, ok := u.U.(*LOCK4denied); ok {
			return v
		} else {
			var zero LOCK4denied
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("LOCK4res.Denied accessed when Status == %v", u.Status)
		return nil
	}
}
func (u LOCK4res) XdrValid() bool {
	return true
}
func (u *LOCK4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *LOCK4res) XdrUnionTagName() string {
	return "Status"
}
func (u *LOCK4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_LOCK4resok(u.Resok4())
	case NFS4ERR_DENIED:
		return XDR_LOCK4denied(u.Denied())
	default:
		return nil
	}
}
func (u *LOCK4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	case NFS4ERR_DENIED:
		return "Denied"
	default:
		return ""
	}
}
type XdrType_LOCK4res = *LOCK4res
func (v *LOCK4res) XdrPointer() interface{} { return v }
func (LOCK4res) XdrTypeName() string { return "LOCK4res" }
func (v LOCK4res) XdrValue() interface{} { return v }
func (v *LOCK4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LOCK4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_LOCK4resok(u.Resok4()))
		return
	case NFS4ERR_DENIED:
		x.Marshal(x.Sprintf("%sdenied", name), XDR_LOCK4denied(u.Denied()))
		return
	default:
		return
	}
}
func XDR_LOCK4res(v *LOCK4res) *LOCK4res { return v}
type XdrType_LOCKT4args = *LOCKT4args
func (v *LOCKT4args) XdrPointer() interface{} { return v }
func (LOCKT4args) XdrTypeName() string { return "LOCKT4args" }
func (v LOCKT4args) XdrValue() interface{} { return v }
func (v *LOCKT4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LOCKT4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slocktype", name), XDR_Nfs_lock_type4(&v.Locktype))
	x.Marshal(x.Sprintf("%soffset", name), XDR_Offset4(&v.Offset))
	x.Marshal(x.Sprintf("%slength", name), XDR_Length4(&v.Length))
	x.Marshal(x.Sprintf("%sowner", name), XDR_Lock_owner4(&v.Owner))
}
func XDR_LOCKT4args(v *LOCKT4args) *LOCKT4args { return v }
func (u *LOCKT4res) Denied() *LOCK4denied {
	switch u.Status {
	case NFS4ERR_DENIED:
		if v, ok := u.U.(*LOCK4denied); ok {
			return v
		} else {
			var zero LOCK4denied
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("LOCKT4res.Denied accessed when Status == %v", u.Status)
		return nil
	}
}
func (u LOCKT4res) XdrValid() bool {
	return true
}
func (u *LOCKT4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *LOCKT4res) XdrUnionTagName() string {
	return "Status"
}
func (u *LOCKT4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4ERR_DENIED:
		return XDR_LOCK4denied(u.Denied())
	case NFS4_OK:
		return nil
	default:
		return nil
	}
}
func (u *LOCKT4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4ERR_DENIED:
		return "Denied"
	case NFS4_OK:
		return ""
	default:
		return ""
	}
}
type XdrType_LOCKT4res = *LOCKT4res
func (v *LOCKT4res) XdrPointer() interface{} { return v }
func (LOCKT4res) XdrTypeName() string { return "LOCKT4res" }
func (v LOCKT4res) XdrValue() interface{} { return v }
func (v *LOCKT4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LOCKT4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4ERR_DENIED:
		x.Marshal(x.Sprintf("%sdenied", name), XDR_LOCK4denied(u.Denied()))
		return
	case NFS4_OK:
		return
	default:
		return
	}
}
func XDR_LOCKT4res(v *LOCKT4res) *LOCKT4res { return v}
type XdrType_LOCKU4args = *LOCKU4args
func (v *LOCKU4args) XdrPointer() interface{} { return v }
func (LOCKU4args) XdrTypeName() string { return "LOCKU4args" }
func (v LOCKU4args) XdrValue() interface{} { return v }
func (v *LOCKU4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LOCKU4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slocktype", name), XDR_Nfs_lock_type4(&v.Locktype))
	x.Marshal(x.Sprintf("%sseqid", name), XDR_Seqid4(&v.Seqid))
	x.Marshal(x.Sprintf("%slock_stateid", name), XDR_Stateid4(&v.Lock_stateid))
	x.Marshal(x.Sprintf("%soffset", name), XDR_Offset4(&v.Offset))
	x.Marshal(x.Sprintf("%slength", name), XDR_Length4(&v.Length))
}
func XDR_LOCKU4args(v *LOCKU4args) *LOCKU4args { return v }
func (u *LOCKU4res) Lock_stateid() *Stateid4 {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*Stateid4); ok {
			return v
		} else {
			var zero Stateid4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("LOCKU4res.Lock_stateid accessed when Status == %v", u.Status)
		return nil
	}
}
func (u LOCKU4res) XdrValid() bool {
	return true
}
func (u *LOCKU4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *LOCKU4res) XdrUnionTagName() string {
	return "Status"
}
func (u *LOCKU4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_Stateid4(u.Lock_stateid())
	default:
		return nil
	}
}
func (u *LOCKU4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Lock_stateid"
	default:
		return ""
	}
}
type XdrType_LOCKU4res = *LOCKU4res
func (v *LOCKU4res) XdrPointer() interface{} { return v }
func (LOCKU4res) XdrTypeName() string { return "LOCKU4res" }
func (v LOCKU4res) XdrValue() interface{} { return v }
func (v *LOCKU4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LOCKU4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%slock_stateid", name), XDR_Stateid4(u.Lock_stateid()))
		return
	default:
		return
	}
}
func XDR_LOCKU4res(v *LOCKU4res) *LOCKU4res { return v}
type XdrType_LOOKUP4args = *LOOKUP4args
func (v *LOOKUP4args) XdrPointer() interface{} { return v }
func (LOOKUP4args) XdrTypeName() string { return "LOOKUP4args" }
func (v LOOKUP4args) XdrValue() interface{} { return v }
func (v *LOOKUP4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LOOKUP4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sobjname", name), XDR_Component4(&v.Objname))
}
func XDR_LOOKUP4args(v *LOOKUP4args) *LOOKUP4args { return v }
type XdrType_LOOKUP4res = *LOOKUP4res
func (v *LOOKUP4res) XdrPointer() interface{} { return v }
func (LOOKUP4res) XdrTypeName() string { return "LOOKUP4res" }
func (v LOOKUP4res) XdrValue() interface{} { return v }
func (v *LOOKUP4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LOOKUP4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_LOOKUP4res(v *LOOKUP4res) *LOOKUP4res { return v }
type XdrType_LOOKUPP4res = *LOOKUPP4res
func (v *LOOKUPP4res) XdrPointer() interface{} { return v }
func (LOOKUPP4res) XdrTypeName() string { return "LOOKUPP4res" }
func (v LOOKUPP4res) XdrValue() interface{} { return v }
func (v *LOOKUPP4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LOOKUPP4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_LOOKUPP4res(v *LOOKUPP4res) *LOOKUPP4res { return v }
type XdrType_NVERIFY4args = *NVERIFY4args
func (v *NVERIFY4args) XdrPointer() interface{} { return v }
func (NVERIFY4args) XdrTypeName() string { return "NVERIFY4args" }
func (v NVERIFY4args) XdrValue() interface{} { return v }
func (v *NVERIFY4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *NVERIFY4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sobj_attributes", name), XDR_Fattr4(&v.Obj_attributes))
}
func XDR_NVERIFY4args(v *NVERIFY4args) *NVERIFY4args { return v }
type XdrType_NVERIFY4res = *NVERIFY4res
func (v *NVERIFY4res) XdrPointer() interface{} { return v }
func (NVERIFY4res) XdrTypeName() string { return "NVERIFY4res" }
func (v NVERIFY4res) XdrValue() interface{} { return v }
func (v *NVERIFY4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *NVERIFY4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_NVERIFY4res(v *NVERIFY4res) *NVERIFY4res { return v }
var _XdrNames_Createmode4 = map[int32]string{
	int32(UNCHECKED4): "UNCHECKED4",
	int32(GUARDED4): "GUARDED4",
	int32(EXCLUSIVE4): "EXCLUSIVE4",
}
var _XdrValues_Createmode4 = map[string]int32{
	"UNCHECKED4": int32(UNCHECKED4),
	"GUARDED4": int32(GUARDED4),
	"EXCLUSIVE4": int32(EXCLUSIVE4),
}
func (Createmode4) XdrEnumNames() map[int32]string {
	return _XdrNames_Createmode4
}
func (v Createmode4) String() string {
	if s, ok := _XdrNames_Createmode4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Createmode4#%d", v)
}
func (v *Createmode4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Createmode4[stok]; ok {
			*v = Createmode4(val)
			return nil
		} else if stok == "Createmode4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Createmode4.", stok))
	}
}
func (v Createmode4) GetU32() uint32 { return uint32(v) }
func (v *Createmode4) SetU32(n uint32) { *v = Createmode4(n) }
func (v *Createmode4) XdrPointer() interface{} { return v }
func (Createmode4) XdrTypeName() string { return "Createmode4" }
func (v Createmode4) XdrValue() interface{} { return v }
func (v *Createmode4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Createmode4 = *Createmode4
func XDR_Createmode4(v *Createmode4) *Createmode4 { return v }
var _XdrTags_Createhow4 = map[int32]bool{
	XdrToI32(UNCHECKED4): true,
	XdrToI32(GUARDED4): true,
	XdrToI32(EXCLUSIVE4): true,
}
func (_ Createhow4) XdrValidTags() map[int32]bool {
	return _XdrTags_Createhow4
}
func (u *Createhow4) Createattrs() *Fattr4 {
	switch u.Mode {
	case UNCHECKED4, GUARDED4:
		if v, ok := u.U.(*Fattr4); ok {
			return v
		} else {
			var zero Fattr4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Createhow4.Createattrs accessed when Mode == %v", u.Mode)
		return nil
	}
}
func (u *Createhow4) Createverf() *Verifier4 {
	switch u.Mode {
	case EXCLUSIVE4:
		if v, ok := u.U.(*Verifier4); ok {
			return v
		} else {
			var zero Verifier4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Createhow4.Createverf accessed when Mode == %v", u.Mode)
		return nil
	}
}
func (u Createhow4) XdrValid() bool {
	switch u.Mode {
	case UNCHECKED4, GUARDED4,EXCLUSIVE4:
		return true
	}
	return false
}
func (u *Createhow4) XdrUnionTag() XdrNum32 {
	return XDR_Createmode4(&u.Mode)
}
func (u *Createhow4) XdrUnionTagName() string {
	return "Mode"
}
func (u *Createhow4) XdrUnionBody() XdrType {
	switch u.Mode {
	case UNCHECKED4, GUARDED4:
		return XDR_Fattr4(u.Createattrs())
	case EXCLUSIVE4:
		return XDR_Verifier4(u.Createverf())
	}
	return nil
}
func (u *Createhow4) XdrUnionBodyName() string {
	switch u.Mode {
	case UNCHECKED4, GUARDED4:
		return "Createattrs"
	case EXCLUSIVE4:
		return "Createverf"
	}
	return ""
}
type XdrType_Createhow4 = *Createhow4
func (v *Createhow4) XdrPointer() interface{} { return v }
func (Createhow4) XdrTypeName() string { return "Createhow4" }
func (v Createhow4) XdrValue() interface{} { return v }
func (v *Createhow4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Createhow4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Createmode4(&u.Mode).XdrMarshal(x, x.Sprintf("%smode", name))
	switch u.Mode {
	case UNCHECKED4, GUARDED4:
		x.Marshal(x.Sprintf("%screateattrs", name), XDR_Fattr4(u.Createattrs()))
		return
	case EXCLUSIVE4:
		x.Marshal(x.Sprintf("%screateverf", name), XDR_Verifier4(u.Createverf()))
		return
	}
	XdrPanic("invalid Mode (%v) in Createhow4", u.Mode)
}
func XDR_Createhow4(v *Createhow4) *Createhow4 { return v}
var _XdrNames_Opentype4 = map[int32]string{
	int32(OPEN4_NOCREATE): "OPEN4_NOCREATE",
	int32(OPEN4_CREATE): "OPEN4_CREATE",
}
var _XdrValues_Opentype4 = map[string]int32{
	"OPEN4_NOCREATE": int32(OPEN4_NOCREATE),
	"OPEN4_CREATE": int32(OPEN4_CREATE),
}
func (Opentype4) XdrEnumNames() map[int32]string {
	return _XdrNames_Opentype4
}
func (v Opentype4) String() string {
	if s, ok := _XdrNames_Opentype4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Opentype4#%d", v)
}
func (v *Opentype4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Opentype4[stok]; ok {
			*v = Opentype4(val)
			return nil
		} else if stok == "Opentype4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Opentype4.", stok))
	}
}
func (v Opentype4) GetU32() uint32 { return uint32(v) }
func (v *Opentype4) SetU32(n uint32) { *v = Opentype4(n) }
func (v *Opentype4) XdrPointer() interface{} { return v }
func (Opentype4) XdrTypeName() string { return "Opentype4" }
func (v Opentype4) XdrValue() interface{} { return v }
func (v *Opentype4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Opentype4 = *Opentype4
func XDR_Opentype4(v *Opentype4) *Opentype4 { return v }
func (u *Openflag4) How() *Createhow4 {
	switch u.Opentype {
	case OPEN4_CREATE:
		if v, ok := u.U.(*Createhow4); ok {
			return v
		} else {
			var zero Createhow4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Openflag4.How accessed when Opentype == %v", u.Opentype)
		return nil
	}
}
func (u Openflag4) XdrValid() bool {
	return true
}
func (u *Openflag4) XdrUnionTag() XdrNum32 {
	return XDR_Opentype4(&u.Opentype)
}
func (u *Openflag4) XdrUnionTagName() string {
	return "Opentype"
}
func (u *Openflag4) XdrUnionBody() XdrType {
	switch u.Opentype {
	case OPEN4_CREATE:
		return XDR_Createhow4(u.How())
	default:
		return nil
	}
}
func (u *Openflag4) XdrUnionBodyName() string {
	switch u.Opentype {
	case OPEN4_CREATE:
		return "How"
	default:
		return ""
	}
}
type XdrType_Openflag4 = *Openflag4
func (v *Openflag4) XdrPointer() interface{} { return v }
func (Openflag4) XdrTypeName() string { return "Openflag4" }
func (v Openflag4) XdrValue() interface{} { return v }
func (v *Openflag4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Openflag4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Opentype4(&u.Opentype).XdrMarshal(x, x.Sprintf("%sopentype", name))
	switch u.Opentype {
	case OPEN4_CREATE:
		x.Marshal(x.Sprintf("%show", name), XDR_Createhow4(u.How()))
		return
	default:
		return
	}
}
func XDR_Openflag4(v *Openflag4) *Openflag4 { return v}
var _XdrNames_Limit_by4 = map[int32]string{
	int32(NFS_LIMIT_SIZE): "NFS_LIMIT_SIZE",
	int32(NFS_LIMIT_BLOCKS): "NFS_LIMIT_BLOCKS",
}
var _XdrValues_Limit_by4 = map[string]int32{
	"NFS_LIMIT_SIZE": int32(NFS_LIMIT_SIZE),
	"NFS_LIMIT_BLOCKS": int32(NFS_LIMIT_BLOCKS),
}
func (Limit_by4) XdrEnumNames() map[int32]string {
	return _XdrNames_Limit_by4
}
func (v Limit_by4) String() string {
	if s, ok := _XdrNames_Limit_by4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Limit_by4#%d", v)
}
func (v *Limit_by4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Limit_by4[stok]; ok {
			*v = Limit_by4(val)
			return nil
		} else if stok == "Limit_by4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Limit_by4.", stok))
	}
}
func (v Limit_by4) GetU32() uint32 { return uint32(v) }
func (v *Limit_by4) SetU32(n uint32) { *v = Limit_by4(n) }
func (v *Limit_by4) XdrPointer() interface{} { return v }
func (Limit_by4) XdrTypeName() string { return "Limit_by4" }
func (v Limit_by4) XdrValue() interface{} { return v }
func (v *Limit_by4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Limit_by4 = *Limit_by4
func XDR_Limit_by4(v *Limit_by4) *Limit_by4 { return v }
func (v *Limit_by4) XdrInitialize() {
	switch Limit_by4(0) {
	case NFS_LIMIT_SIZE, NFS_LIMIT_BLOCKS:
	default:
		if *v == Limit_by4(0) { *v = NFS_LIMIT_SIZE }
	}
}
type XdrType_Nfs_modified_limit4 = *Nfs_modified_limit4
func (v *Nfs_modified_limit4) XdrPointer() interface{} { return v }
func (Nfs_modified_limit4) XdrTypeName() string { return "Nfs_modified_limit4" }
func (v Nfs_modified_limit4) XdrValue() interface{} { return v }
func (v *Nfs_modified_limit4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Nfs_modified_limit4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%snum_blocks", name), XDR_Uint32_t(&v.Num_blocks))
	x.Marshal(x.Sprintf("%sbytes_per_block", name), XDR_Uint32_t(&v.Bytes_per_block))
}
func XDR_Nfs_modified_limit4(v *Nfs_modified_limit4) *Nfs_modified_limit4 { return v }
var _XdrTags_Nfs_space_limit4 = map[int32]bool{
	XdrToI32(NFS_LIMIT_SIZE): true,
	XdrToI32(NFS_LIMIT_BLOCKS): true,
}
func (_ Nfs_space_limit4) XdrValidTags() map[int32]bool {
	return _XdrTags_Nfs_space_limit4
}
func (u *Nfs_space_limit4) Filesize() *Uint64_t {
	switch u.Limitby {
	case NFS_LIMIT_SIZE:
		if v, ok := u.U.(*Uint64_t); ok {
			return v
		} else {
			var zero Uint64_t
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_space_limit4.Filesize accessed when Limitby == %v", u.Limitby)
		return nil
	}
}
func (u *Nfs_space_limit4) Mod_blocks() *Nfs_modified_limit4 {
	switch u.Limitby {
	case NFS_LIMIT_BLOCKS:
		if v, ok := u.U.(*Nfs_modified_limit4); ok {
			return v
		} else {
			var zero Nfs_modified_limit4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_space_limit4.Mod_blocks accessed when Limitby == %v", u.Limitby)
		return nil
	}
}
func (u Nfs_space_limit4) XdrValid() bool {
	switch u.Limitby {
	case NFS_LIMIT_SIZE,NFS_LIMIT_BLOCKS:
		return true
	}
	return false
}
func (u *Nfs_space_limit4) XdrUnionTag() XdrNum32 {
	return XDR_Limit_by4(&u.Limitby)
}
func (u *Nfs_space_limit4) XdrUnionTagName() string {
	return "Limitby"
}
func (u *Nfs_space_limit4) XdrUnionBody() XdrType {
	switch u.Limitby {
	case NFS_LIMIT_SIZE:
		return XDR_Uint64_t(u.Filesize())
	case NFS_LIMIT_BLOCKS:
		return XDR_Nfs_modified_limit4(u.Mod_blocks())
	}
	return nil
}
func (u *Nfs_space_limit4) XdrUnionBodyName() string {
	switch u.Limitby {
	case NFS_LIMIT_SIZE:
		return "Filesize"
	case NFS_LIMIT_BLOCKS:
		return "Mod_blocks"
	}
	return ""
}
type XdrType_Nfs_space_limit4 = *Nfs_space_limit4
func (v *Nfs_space_limit4) XdrPointer() interface{} { return v }
func (Nfs_space_limit4) XdrTypeName() string { return "Nfs_space_limit4" }
func (v Nfs_space_limit4) XdrValue() interface{} { return v }
func (v *Nfs_space_limit4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Nfs_space_limit4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Limit_by4(&u.Limitby).XdrMarshal(x, x.Sprintf("%slimitby", name))
	switch u.Limitby {
	case NFS_LIMIT_SIZE:
		x.Marshal(x.Sprintf("%sfilesize", name), XDR_Uint64_t(u.Filesize()))
		return
	case NFS_LIMIT_BLOCKS:
		x.Marshal(x.Sprintf("%smod_blocks", name), XDR_Nfs_modified_limit4(u.Mod_blocks()))
		return
	}
	XdrPanic("invalid Limitby (%v) in Nfs_space_limit4", u.Limitby)
}
func (v *Nfs_space_limit4) XdrInitialize() {
	var zero Limit_by4
	switch zero {
	case NFS_LIMIT_SIZE, NFS_LIMIT_BLOCKS:
	default:
		if v.Limitby == zero { v.Limitby = NFS_LIMIT_SIZE }
	}
}
func XDR_Nfs_space_limit4(v *Nfs_space_limit4) *Nfs_space_limit4 { return v}
var _XdrNames_Open_delegation_type4 = map[int32]string{
	int32(OPEN_DELEGATE_NONE): "OPEN_DELEGATE_NONE",
	int32(OPEN_DELEGATE_READ): "OPEN_DELEGATE_READ",
	int32(OPEN_DELEGATE_WRITE): "OPEN_DELEGATE_WRITE",
}
var _XdrValues_Open_delegation_type4 = map[string]int32{
	"OPEN_DELEGATE_NONE": int32(OPEN_DELEGATE_NONE),
	"OPEN_DELEGATE_READ": int32(OPEN_DELEGATE_READ),
	"OPEN_DELEGATE_WRITE": int32(OPEN_DELEGATE_WRITE),
}
func (Open_delegation_type4) XdrEnumNames() map[int32]string {
	return _XdrNames_Open_delegation_type4
}
func (v Open_delegation_type4) String() string {
	if s, ok := _XdrNames_Open_delegation_type4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Open_delegation_type4#%d", v)
}
func (v *Open_delegation_type4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Open_delegation_type4[stok]; ok {
			*v = Open_delegation_type4(val)
			return nil
		} else if stok == "Open_delegation_type4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Open_delegation_type4.", stok))
	}
}
func (v Open_delegation_type4) GetU32() uint32 { return uint32(v) }
func (v *Open_delegation_type4) SetU32(n uint32) { *v = Open_delegation_type4(n) }
func (v *Open_delegation_type4) XdrPointer() interface{} { return v }
func (Open_delegation_type4) XdrTypeName() string { return "Open_delegation_type4" }
func (v Open_delegation_type4) XdrValue() interface{} { return v }
func (v *Open_delegation_type4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Open_delegation_type4 = *Open_delegation_type4
func XDR_Open_delegation_type4(v *Open_delegation_type4) *Open_delegation_type4 { return v }
var _XdrNames_Open_claim_type4 = map[int32]string{
	int32(CLAIM_NULL): "CLAIM_NULL",
	int32(CLAIM_PREVIOUS): "CLAIM_PREVIOUS",
	int32(CLAIM_DELEGATE_CUR): "CLAIM_DELEGATE_CUR",
	int32(CLAIM_DELEGATE_PREV): "CLAIM_DELEGATE_PREV",
	int32(CLAIM_FH): "CLAIM_FH",
	int32(CLAIM_DELEG_CUR_FH): "CLAIM_DELEG_CUR_FH",
	int32(CLAIM_DELEG_PREV_FH): "CLAIM_DELEG_PREV_FH",
}
var _XdrValues_Open_claim_type4 = map[string]int32{
	"CLAIM_NULL": int32(CLAIM_NULL),
	"CLAIM_PREVIOUS": int32(CLAIM_PREVIOUS),
	"CLAIM_DELEGATE_CUR": int32(CLAIM_DELEGATE_CUR),
	"CLAIM_DELEGATE_PREV": int32(CLAIM_DELEGATE_PREV),
	"CLAIM_FH": int32(CLAIM_FH),
	"CLAIM_DELEG_CUR_FH": int32(CLAIM_DELEG_CUR_FH),
	"CLAIM_DELEG_PREV_FH": int32(CLAIM_DELEG_PREV_FH),
}
func (Open_claim_type4) XdrEnumNames() map[int32]string {
	return _XdrNames_Open_claim_type4
}
func (v Open_claim_type4) String() string {
	if s, ok := _XdrNames_Open_claim_type4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Open_claim_type4#%d", v)
}
func (v *Open_claim_type4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Open_claim_type4[stok]; ok {
			*v = Open_claim_type4(val)
			return nil
		} else if stok == "Open_claim_type4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Open_claim_type4.", stok))
	}
}
func (v Open_claim_type4) GetU32() uint32 { return uint32(v) }
func (v *Open_claim_type4) SetU32(n uint32) { *v = Open_claim_type4(n) }
func (v *Open_claim_type4) XdrPointer() interface{} { return v }
func (Open_claim_type4) XdrTypeName() string { return "Open_claim_type4" }
func (v Open_claim_type4) XdrValue() interface{} { return v }
func (v *Open_claim_type4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Open_claim_type4 = *Open_claim_type4
func XDR_Open_claim_type4(v *Open_claim_type4) *Open_claim_type4 { return v }
type XdrType_Open_claim_delegate_cur4 = *Open_claim_delegate_cur4
func (v *Open_claim_delegate_cur4) XdrPointer() interface{} { return v }
func (Open_claim_delegate_cur4) XdrTypeName() string { return "Open_claim_delegate_cur4" }
func (v Open_claim_delegate_cur4) XdrValue() interface{} { return v }
func (v *Open_claim_delegate_cur4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Open_claim_delegate_cur4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdelegate_stateid", name), XDR_Stateid4(&v.Delegate_stateid))
	x.Marshal(x.Sprintf("%sfile", name), XDR_Component4(&v.File))
}
func XDR_Open_claim_delegate_cur4(v *Open_claim_delegate_cur4) *Open_claim_delegate_cur4 { return v }
var _XdrTags_Open_claim4 = map[int32]bool{
	XdrToI32(CLAIM_NULL): true,
	XdrToI32(CLAIM_PREVIOUS): true,
	XdrToI32(CLAIM_DELEGATE_CUR): true,
	XdrToI32(CLAIM_DELEGATE_PREV): true,
}
func (_ Open_claim4) XdrValidTags() map[int32]bool {
	return _XdrTags_Open_claim4
}
/* CURRENT_FH: directory */
func (u *Open_claim4) File() *Component4 {
	switch u.Claim {
	case CLAIM_NULL:
		if v, ok := u.U.(*Component4); ok {
			return v
		} else {
			var zero Component4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Open_claim4.File accessed when Claim == %v", u.Claim)
		return nil
	}
}
/* CURRENT_FH: file being reclaimed */
func (u *Open_claim4) Delegate_type() *Open_delegation_type4 {
	switch u.Claim {
	case CLAIM_PREVIOUS:
		if v, ok := u.U.(*Open_delegation_type4); ok {
			return v
		} else {
			var zero Open_delegation_type4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Open_claim4.Delegate_type accessed when Claim == %v", u.Claim)
		return nil
	}
}
/* CURRENT_FH: directory */
func (u *Open_claim4) Delegate_cur_info() *Open_claim_delegate_cur4 {
	switch u.Claim {
	case CLAIM_DELEGATE_CUR:
		if v, ok := u.U.(*Open_claim_delegate_cur4); ok {
			return v
		} else {
			var zero Open_claim_delegate_cur4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Open_claim4.Delegate_cur_info accessed when Claim == %v", u.Claim)
		return nil
	}
}
/* CURRENT_FH: directory */
func (u *Open_claim4) File_delegate_prev() *Component4 {
	switch u.Claim {
	case CLAIM_DELEGATE_PREV:
		if v, ok := u.U.(*Component4); ok {
			return v
		} else {
			var zero Component4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Open_claim4.File_delegate_prev accessed when Claim == %v", u.Claim)
		return nil
	}
}
func (u Open_claim4) XdrValid() bool {
	switch u.Claim {
	case CLAIM_NULL,CLAIM_PREVIOUS,CLAIM_DELEGATE_CUR,CLAIM_DELEGATE_PREV:
		return true
	}
	return false
}
func (u *Open_claim4) XdrUnionTag() XdrNum32 {
	return XDR_Open_claim_type4(&u.Claim)
}
func (u *Open_claim4) XdrUnionTagName() string {
	return "Claim"
}
func (u *Open_claim4) XdrUnionBody() XdrType {
	switch u.Claim {
	case CLAIM_NULL:
		return XDR_Component4(u.File())
	case CLAIM_PREVIOUS:
		return XDR_Open_delegation_type4(u.Delegate_type())
	case CLAIM_DELEGATE_CUR:
		return XDR_Open_claim_delegate_cur4(u.Delegate_cur_info())
	case CLAIM_DELEGATE_PREV:
		return XDR_Component4(u.File_delegate_prev())
	}
	return nil
}
func (u *Open_claim4) XdrUnionBodyName() string {
	switch u.Claim {
	case CLAIM_NULL:
		return "File"
	case CLAIM_PREVIOUS:
		return "Delegate_type"
	case CLAIM_DELEGATE_CUR:
		return "Delegate_cur_info"
	case CLAIM_DELEGATE_PREV:
		return "File_delegate_prev"
	}
	return ""
}
type XdrType_Open_claim4 = *Open_claim4
func (v *Open_claim4) XdrPointer() interface{} { return v }
func (Open_claim4) XdrTypeName() string { return "Open_claim4" }
func (v Open_claim4) XdrValue() interface{} { return v }
func (v *Open_claim4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Open_claim4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Open_claim_type4(&u.Claim).XdrMarshal(x, x.Sprintf("%sclaim", name))
	switch u.Claim {
	case CLAIM_NULL:
		x.Marshal(x.Sprintf("%sfile", name), XDR_Component4(u.File()))
		return
	case CLAIM_PREVIOUS:
		x.Marshal(x.Sprintf("%sdelegate_type", name), XDR_Open_delegation_type4(u.Delegate_type()))
		return
	case CLAIM_DELEGATE_CUR:
		x.Marshal(x.Sprintf("%sdelegate_cur_info", name), XDR_Open_claim_delegate_cur4(u.Delegate_cur_info()))
		return
	case CLAIM_DELEGATE_PREV:
		x.Marshal(x.Sprintf("%sfile_delegate_prev", name), XDR_Component4(u.File_delegate_prev()))
		return
	}
	XdrPanic("invalid Claim (%v) in Open_claim4", u.Claim)
}
func XDR_Open_claim4(v *Open_claim4) *Open_claim4 { return v}
type XdrType_OPEN4args = *OPEN4args
func (v *OPEN4args) XdrPointer() interface{} { return v }
func (OPEN4args) XdrTypeName() string { return "OPEN4args" }
func (v OPEN4args) XdrValue() interface{} { return v }
func (v *OPEN4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *OPEN4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sseqid", name), XDR_Seqid4(&v.Seqid))
	x.Marshal(x.Sprintf("%sshare_access", name), XDR_Uint32_t(&v.Share_access))
	x.Marshal(x.Sprintf("%sshare_deny", name), XDR_Uint32_t(&v.Share_deny))
	x.Marshal(x.Sprintf("%sowner", name), XDR_Open_owner4(&v.Owner))
	x.Marshal(x.Sprintf("%sopenhow", name), XDR_Openflag4(&v.Openhow))
	x.Marshal(x.Sprintf("%sclaim", name), XDR_Open_claim4(&v.Claim))
}
func XDR_OPEN4args(v *OPEN4args) *OPEN4args { return v }
type XdrType_Open_read_delegation4 = *Open_read_delegation4
func (v *Open_read_delegation4) XdrPointer() interface{} { return v }
func (Open_read_delegation4) XdrTypeName() string { return "Open_read_delegation4" }
func (v Open_read_delegation4) XdrValue() interface{} { return v }
func (v *Open_read_delegation4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Open_read_delegation4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstateid", name), XDR_Stateid4(&v.Stateid))
	x.Marshal(x.Sprintf("%srecall", name), XDR_bool(&v.Recall))
	x.Marshal(x.Sprintf("%spermissions", name), XDR_Nfsace4(&v.Permissions))
}
func XDR_Open_read_delegation4(v *Open_read_delegation4) *Open_read_delegation4 { return v }
type XdrType_Open_write_delegation4 = *Open_write_delegation4
func (v *Open_write_delegation4) XdrPointer() interface{} { return v }
func (Open_write_delegation4) XdrTypeName() string { return "Open_write_delegation4" }
func (v Open_write_delegation4) XdrValue() interface{} { return v }
func (v *Open_write_delegation4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Open_write_delegation4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstateid", name), XDR_Stateid4(&v.Stateid))
	x.Marshal(x.Sprintf("%srecall", name), XDR_bool(&v.Recall))
	x.Marshal(x.Sprintf("%sspace_limit", name), XDR_Nfs_space_limit4(&v.Space_limit))
	x.Marshal(x.Sprintf("%spermissions", name), XDR_Nfsace4(&v.Permissions))
}
func XDR_Open_write_delegation4(v *Open_write_delegation4) *Open_write_delegation4 { return v }
var _XdrTags_Open_delegation4 = map[int32]bool{
	XdrToI32(OPEN_DELEGATE_NONE): true,
	XdrToI32(OPEN_DELEGATE_READ): true,
	XdrToI32(OPEN_DELEGATE_WRITE): true,
}
func (_ Open_delegation4) XdrValidTags() map[int32]bool {
	return _XdrTags_Open_delegation4
}
func (u *Open_delegation4) Read() *Open_read_delegation4 {
	switch u.Delegation_type {
	case OPEN_DELEGATE_READ:
		if v, ok := u.U.(*Open_read_delegation4); ok {
			return v
		} else {
			var zero Open_read_delegation4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Open_delegation4.Read accessed when Delegation_type == %v", u.Delegation_type)
		return nil
	}
}
func (u *Open_delegation4) Write() *Open_write_delegation4 {
	switch u.Delegation_type {
	case OPEN_DELEGATE_WRITE:
		if v, ok := u.U.(*Open_write_delegation4); ok {
			return v
		} else {
			var zero Open_write_delegation4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Open_delegation4.Write accessed when Delegation_type == %v", u.Delegation_type)
		return nil
	}
}
func (u Open_delegation4) XdrValid() bool {
	switch u.Delegation_type {
	case OPEN_DELEGATE_NONE,OPEN_DELEGATE_READ,OPEN_DELEGATE_WRITE:
		return true
	}
	return false
}
func (u *Open_delegation4) XdrUnionTag() XdrNum32 {
	return XDR_Open_delegation_type4(&u.Delegation_type)
}
func (u *Open_delegation4) XdrUnionTagName() string {
	return "Delegation_type"
}
func (u *Open_delegation4) XdrUnionBody() XdrType {
	switch u.Delegation_type {
	case OPEN_DELEGATE_NONE:
		return nil
	case OPEN_DELEGATE_READ:
		return XDR_Open_read_delegation4(u.Read())
	case OPEN_DELEGATE_WRITE:
		return XDR_Open_write_delegation4(u.Write())
	}
	return nil
}
func (u *Open_delegation4) XdrUnionBodyName() string {
	switch u.Delegation_type {
	case OPEN_DELEGATE_NONE:
		return ""
	case OPEN_DELEGATE_READ:
		return "Read"
	case OPEN_DELEGATE_WRITE:
		return "Write"
	}
	return ""
}
type XdrType_Open_delegation4 = *Open_delegation4
func (v *Open_delegation4) XdrPointer() interface{} { return v }
func (Open_delegation4) XdrTypeName() string { return "Open_delegation4" }
func (v Open_delegation4) XdrValue() interface{} { return v }
func (v *Open_delegation4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Open_delegation4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Open_delegation_type4(&u.Delegation_type).XdrMarshal(x, x.Sprintf("%sdelegation_type", name))
	switch u.Delegation_type {
	case OPEN_DELEGATE_NONE:
		return
	case OPEN_DELEGATE_READ:
		x.Marshal(x.Sprintf("%sread", name), XDR_Open_read_delegation4(u.Read()))
		return
	case OPEN_DELEGATE_WRITE:
		x.Marshal(x.Sprintf("%swrite", name), XDR_Open_write_delegation4(u.Write()))
		return
	}
	XdrPanic("invalid Delegation_type (%v) in Open_delegation4", u.Delegation_type)
}
func XDR_Open_delegation4(v *Open_delegation4) *Open_delegation4 { return v}
type XdrType_OPEN4resok = *OPEN4resok
func (v *OPEN4resok) XdrPointer() interface{} { return v }
func (OPEN4resok) XdrTypeName() string { return "OPEN4resok" }
func (v OPEN4resok) XdrValue() interface{} { return v }
func (v *OPEN4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *OPEN4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstateid", name), XDR_Stateid4(&v.Stateid))
	x.Marshal(x.Sprintf("%scinfo", name), XDR_Change_info4(&v.Cinfo))
	x.Marshal(x.Sprintf("%srflags", name), XDR_Uint32_t(&v.Rflags))
	x.Marshal(x.Sprintf("%sattrset", name), XDR_Bitmap4(&v.Attrset))
	x.Marshal(x.Sprintf("%sdelegation", name), XDR_Open_delegation4(&v.Delegation))
}
func XDR_OPEN4resok(v *OPEN4resok) *OPEN4resok { return v }
/* CURRENT_FH: opened file */
func (u *OPEN4res) Resok4() *OPEN4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*OPEN4resok); ok {
			return v
		} else {
			var zero OPEN4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("OPEN4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u OPEN4res) XdrValid() bool {
	return true
}
func (u *OPEN4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *OPEN4res) XdrUnionTagName() string {
	return "Status"
}
func (u *OPEN4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_OPEN4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *OPEN4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_OPEN4res = *OPEN4res
func (v *OPEN4res) XdrPointer() interface{} { return v }
func (OPEN4res) XdrTypeName() string { return "OPEN4res" }
func (v OPEN4res) XdrValue() interface{} { return v }
func (v *OPEN4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *OPEN4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_OPEN4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_OPEN4res(v *OPEN4res) *OPEN4res { return v}
type XdrType_OPENATTR4args = *OPENATTR4args
func (v *OPENATTR4args) XdrPointer() interface{} { return v }
func (OPENATTR4args) XdrTypeName() string { return "OPENATTR4args" }
func (v OPENATTR4args) XdrValue() interface{} { return v }
func (v *OPENATTR4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *OPENATTR4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%screatedir", name), XDR_bool(&v.Createdir))
}
func XDR_OPENATTR4args(v *OPENATTR4args) *OPENATTR4args { return v }
type XdrType_OPENATTR4res = *OPENATTR4res
func (v *OPENATTR4res) XdrPointer() interface{} { return v }
func (OPENATTR4res) XdrTypeName() string { return "OPENATTR4res" }
func (v OPENATTR4res) XdrValue() interface{} { return v }
func (v *OPENATTR4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *OPENATTR4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_OPENATTR4res(v *OPENATTR4res) *OPENATTR4res { return v }
type XdrType_OPEN_CONFIRM4args = *OPEN_CONFIRM4args
func (v *OPEN_CONFIRM4args) XdrPointer() interface{} { return v }
func (OPEN_CONFIRM4args) XdrTypeName() string { return "OPEN_CONFIRM4args" }
func (v OPEN_CONFIRM4args) XdrValue() interface{} { return v }
func (v *OPEN_CONFIRM4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *OPEN_CONFIRM4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sopen_stateid", name), XDR_Stateid4(&v.Open_stateid))
	x.Marshal(x.Sprintf("%sseqid", name), XDR_Seqid4(&v.Seqid))
}
func XDR_OPEN_CONFIRM4args(v *OPEN_CONFIRM4args) *OPEN_CONFIRM4args { return v }
type XdrType_OPEN_CONFIRM4resok = *OPEN_CONFIRM4resok
func (v *OPEN_CONFIRM4resok) XdrPointer() interface{} { return v }
func (OPEN_CONFIRM4resok) XdrTypeName() string { return "OPEN_CONFIRM4resok" }
func (v OPEN_CONFIRM4resok) XdrValue() interface{} { return v }
func (v *OPEN_CONFIRM4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *OPEN_CONFIRM4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sopen_stateid", name), XDR_Stateid4(&v.Open_stateid))
}
func XDR_OPEN_CONFIRM4resok(v *OPEN_CONFIRM4resok) *OPEN_CONFIRM4resok { return v }
func (u *OPEN_CONFIRM4res) Resok4() *OPEN_CONFIRM4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*OPEN_CONFIRM4resok); ok {
			return v
		} else {
			var zero OPEN_CONFIRM4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("OPEN_CONFIRM4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u OPEN_CONFIRM4res) XdrValid() bool {
	return true
}
func (u *OPEN_CONFIRM4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *OPEN_CONFIRM4res) XdrUnionTagName() string {
	return "Status"
}
func (u *OPEN_CONFIRM4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_OPEN_CONFIRM4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *OPEN_CONFIRM4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_OPEN_CONFIRM4res = *OPEN_CONFIRM4res
func (v *OPEN_CONFIRM4res) XdrPointer() interface{} { return v }
func (OPEN_CONFIRM4res) XdrTypeName() string { return "OPEN_CONFIRM4res" }
func (v OPEN_CONFIRM4res) XdrValue() interface{} { return v }
func (v *OPEN_CONFIRM4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *OPEN_CONFIRM4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_OPEN_CONFIRM4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_OPEN_CONFIRM4res(v *OPEN_CONFIRM4res) *OPEN_CONFIRM4res { return v}
type XdrType_OPEN_DOWNGRADE4args = *OPEN_DOWNGRADE4args
func (v *OPEN_DOWNGRADE4args) XdrPointer() interface{} { return v }
func (OPEN_DOWNGRADE4args) XdrTypeName() string { return "OPEN_DOWNGRADE4args" }
func (v OPEN_DOWNGRADE4args) XdrValue() interface{} { return v }
func (v *OPEN_DOWNGRADE4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *OPEN_DOWNGRADE4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sopen_stateid", name), XDR_Stateid4(&v.Open_stateid))
	x.Marshal(x.Sprintf("%sseqid", name), XDR_Seqid4(&v.Seqid))
	x.Marshal(x.Sprintf("%sshare_access", name), XDR_Uint32_t(&v.Share_access))
	x.Marshal(x.Sprintf("%sshare_deny", name), XDR_Uint32_t(&v.Share_deny))
}
func XDR_OPEN_DOWNGRADE4args(v *OPEN_DOWNGRADE4args) *OPEN_DOWNGRADE4args { return v }
type XdrType_OPEN_DOWNGRADE4resok = *OPEN_DOWNGRADE4resok
func (v *OPEN_DOWNGRADE4resok) XdrPointer() interface{} { return v }
func (OPEN_DOWNGRADE4resok) XdrTypeName() string { return "OPEN_DOWNGRADE4resok" }
func (v OPEN_DOWNGRADE4resok) XdrValue() interface{} { return v }
func (v *OPEN_DOWNGRADE4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *OPEN_DOWNGRADE4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sopen_stateid", name), XDR_Stateid4(&v.Open_stateid))
}
func XDR_OPEN_DOWNGRADE4resok(v *OPEN_DOWNGRADE4resok) *OPEN_DOWNGRADE4resok { return v }
func (u *OPEN_DOWNGRADE4res) Resok4() *OPEN_DOWNGRADE4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*OPEN_DOWNGRADE4resok); ok {
			return v
		} else {
			var zero OPEN_DOWNGRADE4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("OPEN_DOWNGRADE4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u OPEN_DOWNGRADE4res) XdrValid() bool {
	return true
}
func (u *OPEN_DOWNGRADE4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *OPEN_DOWNGRADE4res) XdrUnionTagName() string {
	return "Status"
}
func (u *OPEN_DOWNGRADE4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_OPEN_DOWNGRADE4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *OPEN_DOWNGRADE4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_OPEN_DOWNGRADE4res = *OPEN_DOWNGRADE4res
func (v *OPEN_DOWNGRADE4res) XdrPointer() interface{} { return v }
func (OPEN_DOWNGRADE4res) XdrTypeName() string { return "OPEN_DOWNGRADE4res" }
func (v OPEN_DOWNGRADE4res) XdrValue() interface{} { return v }
func (v *OPEN_DOWNGRADE4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *OPEN_DOWNGRADE4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_OPEN_DOWNGRADE4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_OPEN_DOWNGRADE4res(v *OPEN_DOWNGRADE4res) *OPEN_DOWNGRADE4res { return v}
type XdrType_PUTFH4args = *PUTFH4args
func (v *PUTFH4args) XdrPointer() interface{} { return v }
func (PUTFH4args) XdrTypeName() string { return "PUTFH4args" }
func (v PUTFH4args) XdrValue() interface{} { return v }
func (v *PUTFH4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PUTFH4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sobject", name), XDR_Nfs_fh4(&v.Object))
}
func XDR_PUTFH4args(v *PUTFH4args) *PUTFH4args { return v }
type XdrType_PUTFH4res = *PUTFH4res
func (v *PUTFH4res) XdrPointer() interface{} { return v }
func (PUTFH4res) XdrTypeName() string { return "PUTFH4res" }
func (v PUTFH4res) XdrValue() interface{} { return v }
func (v *PUTFH4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PUTFH4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_PUTFH4res(v *PUTFH4res) *PUTFH4res { return v }
type XdrType_PUTPUBFH4res = *PUTPUBFH4res
func (v *PUTPUBFH4res) XdrPointer() interface{} { return v }
func (PUTPUBFH4res) XdrTypeName() string { return "PUTPUBFH4res" }
func (v PUTPUBFH4res) XdrValue() interface{} { return v }
func (v *PUTPUBFH4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PUTPUBFH4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_PUTPUBFH4res(v *PUTPUBFH4res) *PUTPUBFH4res { return v }
type XdrType_PUTROOTFH4res = *PUTROOTFH4res
func (v *PUTROOTFH4res) XdrPointer() interface{} { return v }
func (PUTROOTFH4res) XdrTypeName() string { return "PUTROOTFH4res" }
func (v PUTROOTFH4res) XdrValue() interface{} { return v }
func (v *PUTROOTFH4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *PUTROOTFH4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_PUTROOTFH4res(v *PUTROOTFH4res) *PUTROOTFH4res { return v }
type XdrType_READ4args = *READ4args
func (v *READ4args) XdrPointer() interface{} { return v }
func (READ4args) XdrTypeName() string { return "READ4args" }
func (v READ4args) XdrValue() interface{} { return v }
func (v *READ4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *READ4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstateid", name), XDR_Stateid4(&v.Stateid))
	x.Marshal(x.Sprintf("%soffset", name), XDR_Offset4(&v.Offset))
	x.Marshal(x.Sprintf("%scount", name), XDR_Count4(&v.Count))
}
func XDR_READ4args(v *READ4args) *READ4args { return v }
type XdrType_READ4resok = *READ4resok
func (v *READ4resok) XdrPointer() interface{} { return v }
func (READ4resok) XdrTypeName() string { return "READ4resok" }
func (v READ4resok) XdrValue() interface{} { return v }
func (v *READ4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *READ4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%seof", name), XDR_bool(&v.Eof))
	x.Marshal(x.Sprintf("%sdata", name), XdrVecOpaque{&v.Data, 0xffffffff})
}
func XDR_READ4resok(v *READ4resok) *READ4resok { return v }
func (u *READ4res) Resok4() *READ4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*READ4resok); ok {
			return v
		} else {
			var zero READ4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("READ4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u READ4res) XdrValid() bool {
	return true
}
func (u *READ4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *READ4res) XdrUnionTagName() string {
	return "Status"
}
func (u *READ4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_READ4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *READ4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_READ4res = *READ4res
func (v *READ4res) XdrPointer() interface{} { return v }
func (READ4res) XdrTypeName() string { return "READ4res" }
func (v READ4res) XdrValue() interface{} { return v }
func (v *READ4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *READ4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_READ4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_READ4res(v *READ4res) *READ4res { return v}
type XdrType_READDIR4args = *READDIR4args
func (v *READDIR4args) XdrPointer() interface{} { return v }
func (READDIR4args) XdrTypeName() string { return "READDIR4args" }
func (v READDIR4args) XdrValue() interface{} { return v }
func (v *READDIR4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *READDIR4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scookie", name), XDR_Nfs_cookie4(&v.Cookie))
	x.Marshal(x.Sprintf("%scookieverf", name), XDR_Verifier4(&v.Cookieverf))
	x.Marshal(x.Sprintf("%sdircount", name), XDR_Count4(&v.Dircount))
	x.Marshal(x.Sprintf("%smaxcount", name), XDR_Count4(&v.Maxcount))
	x.Marshal(x.Sprintf("%sattr_request", name), XDR_Bitmap4(&v.Attr_request))
}
func XDR_READDIR4args(v *READDIR4args) *READDIR4args { return v }
type _XdrPtr_Entry4 struct {
	p **Entry4
}
type _ptrflag_Entry4 _XdrPtr_Entry4
func (v _ptrflag_Entry4) String() string {
	if *v.p == nil {
		return "nil"
	}
	return "non-nil"
}
func (v _ptrflag_Entry4) Scan(ss fmt.ScanState, r rune) error {
	tok, err := ss.Token(true, func(c rune) bool {
		return c == '-' || (c >= 'a' && c <= 'z')
	})
	if err != nil {
		return err
	}
	switch string(tok) {
	case "nil":
		v.SetU32(0)
	case "non-nil":
		v.SetU32(1)
	default:
		return XdrError("Entry4 flag should be \"nil\" or \"non-nil\"")
	}
	return nil
}
func (v _ptrflag_Entry4) GetU32() uint32 {
	if *v.p == nil {
		return 0
	}
	return 1
}
func (v _ptrflag_Entry4) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v.p = nil
	case 1:
		if *v.p == nil {
			*v.p = new(Entry4)
		}
	default:
		XdrPanic("*Entry4 present flag value %d should be 0 or 1", nv)
	}
}
func (_ptrflag_Entry4) XdrTypeName() string { return "Entry4?" }
func (v _ptrflag_Entry4) XdrPointer() interface{} { return nil }
func (v _ptrflag_Entry4) XdrValue() interface{} { return v.GetU32() != 0 }
func (v _ptrflag_Entry4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _ptrflag_Entry4) XdrBound() uint32 { return 1 }
func (v _XdrPtr_Entry4) GetPresent() bool { return *v.p != nil }
func (v _XdrPtr_Entry4) SetPresent(present bool) {
	if !present {
		*v.p = nil
	} else if *v.p == nil {
		*v.p = new(Entry4)
	}
}
func (v _XdrPtr_Entry4) XdrMarshalValue(x XDR, name string) {
	if *v.p != nil {
		XDR_Entry4(*v.p).XdrMarshal(x, name)
	}
}
func (v _XdrPtr_Entry4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v _XdrPtr_Entry4) XdrRecurse(x XDR, name string) {
	x.Marshal(name, _ptrflag_Entry4(v))
	v.XdrMarshalValue(x, name)
}
func (_XdrPtr_Entry4) XdrTypeName() string { return "Entry4*" }
func (v _XdrPtr_Entry4) XdrPointer() interface{} { return v.p }
func (v _XdrPtr_Entry4) XdrValue() interface{} { return *v.p }
type XdrType_Entry4 = *Entry4
func (v *Entry4) XdrPointer() interface{} { return v }
func (Entry4) XdrTypeName() string { return "Entry4" }
func (v Entry4) XdrValue() interface{} { return v }
func (v *Entry4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Entry4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scookie", name), XDR_Nfs_cookie4(&v.Cookie))
	x.Marshal(x.Sprintf("%sname", name), XDR_Component4(&v.Name))
	x.Marshal(x.Sprintf("%sattrs", name), XDR_Fattr4(&v.Attrs))
	x.Marshal(x.Sprintf("%snextentry", name), _XdrPtr_Entry4{&v.Nextentry})
}
func XDR_Entry4(v *Entry4) *Entry4 { return v }
type XdrType_Dirlist4 = *Dirlist4
func (v *Dirlist4) XdrPointer() interface{} { return v }
func (Dirlist4) XdrTypeName() string { return "Dirlist4" }
func (v Dirlist4) XdrValue() interface{} { return v }
func (v *Dirlist4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Dirlist4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sentries", name), _XdrPtr_Entry4{&v.Entries})
	x.Marshal(x.Sprintf("%seof", name), XDR_bool(&v.Eof))
}
func XDR_Dirlist4(v *Dirlist4) *Dirlist4 { return v }
type XdrType_READDIR4resok = *READDIR4resok
func (v *READDIR4resok) XdrPointer() interface{} { return v }
func (READDIR4resok) XdrTypeName() string { return "READDIR4resok" }
func (v READDIR4resok) XdrValue() interface{} { return v }
func (v *READDIR4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *READDIR4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scookieverf", name), XDR_Verifier4(&v.Cookieverf))
	x.Marshal(x.Sprintf("%sreply", name), XDR_Dirlist4(&v.Reply))
}
func XDR_READDIR4resok(v *READDIR4resok) *READDIR4resok { return v }
func (u *READDIR4res) Resok4() *READDIR4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*READDIR4resok); ok {
			return v
		} else {
			var zero READDIR4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("READDIR4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u READDIR4res) XdrValid() bool {
	return true
}
func (u *READDIR4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *READDIR4res) XdrUnionTagName() string {
	return "Status"
}
func (u *READDIR4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_READDIR4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *READDIR4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_READDIR4res = *READDIR4res
func (v *READDIR4res) XdrPointer() interface{} { return v }
func (READDIR4res) XdrTypeName() string { return "READDIR4res" }
func (v READDIR4res) XdrValue() interface{} { return v }
func (v *READDIR4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *READDIR4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_READDIR4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_READDIR4res(v *READDIR4res) *READDIR4res { return v}
type XdrType_READLINK4resok = *READLINK4resok
func (v *READLINK4resok) XdrPointer() interface{} { return v }
func (READLINK4resok) XdrTypeName() string { return "READLINK4resok" }
func (v READLINK4resok) XdrValue() interface{} { return v }
func (v *READLINK4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *READLINK4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slink", name), XDR_Linktext4(&v.Link))
}
func XDR_READLINK4resok(v *READLINK4resok) *READLINK4resok { return v }
func (u *READLINK4res) Resok4() *READLINK4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*READLINK4resok); ok {
			return v
		} else {
			var zero READLINK4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("READLINK4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u READLINK4res) XdrValid() bool {
	return true
}
func (u *READLINK4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *READLINK4res) XdrUnionTagName() string {
	return "Status"
}
func (u *READLINK4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_READLINK4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *READLINK4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_READLINK4res = *READLINK4res
func (v *READLINK4res) XdrPointer() interface{} { return v }
func (READLINK4res) XdrTypeName() string { return "READLINK4res" }
func (v READLINK4res) XdrValue() interface{} { return v }
func (v *READLINK4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *READLINK4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_READLINK4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_READLINK4res(v *READLINK4res) *READLINK4res { return v}
type XdrType_REMOVE4args = *REMOVE4args
func (v *REMOVE4args) XdrPointer() interface{} { return v }
func (REMOVE4args) XdrTypeName() string { return "REMOVE4args" }
func (v REMOVE4args) XdrValue() interface{} { return v }
func (v *REMOVE4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *REMOVE4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%starget", name), XDR_Component4(&v.Target))
}
func XDR_REMOVE4args(v *REMOVE4args) *REMOVE4args { return v }
type XdrType_REMOVE4resok = *REMOVE4resok
func (v *REMOVE4resok) XdrPointer() interface{} { return v }
func (REMOVE4resok) XdrTypeName() string { return "REMOVE4resok" }
func (v REMOVE4resok) XdrValue() interface{} { return v }
func (v *REMOVE4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *REMOVE4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scinfo", name), XDR_Change_info4(&v.Cinfo))
}
func XDR_REMOVE4resok(v *REMOVE4resok) *REMOVE4resok { return v }
func (u *REMOVE4res) Resok4() *REMOVE4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*REMOVE4resok); ok {
			return v
		} else {
			var zero REMOVE4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("REMOVE4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u REMOVE4res) XdrValid() bool {
	return true
}
func (u *REMOVE4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *REMOVE4res) XdrUnionTagName() string {
	return "Status"
}
func (u *REMOVE4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_REMOVE4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *REMOVE4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_REMOVE4res = *REMOVE4res
func (v *REMOVE4res) XdrPointer() interface{} { return v }
func (REMOVE4res) XdrTypeName() string { return "REMOVE4res" }
func (v REMOVE4res) XdrValue() interface{} { return v }
func (v *REMOVE4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *REMOVE4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_REMOVE4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_REMOVE4res(v *REMOVE4res) *REMOVE4res { return v}
type XdrType_RENAME4args = *RENAME4args
func (v *RENAME4args) XdrPointer() interface{} { return v }
func (RENAME4args) XdrTypeName() string { return "RENAME4args" }
func (v RENAME4args) XdrValue() interface{} { return v }
func (v *RENAME4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *RENAME4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soldname", name), XDR_Component4(&v.Oldname))
	x.Marshal(x.Sprintf("%snewname", name), XDR_Component4(&v.Newname))
}
func XDR_RENAME4args(v *RENAME4args) *RENAME4args { return v }
type XdrType_RENAME4resok = *RENAME4resok
func (v *RENAME4resok) XdrPointer() interface{} { return v }
func (RENAME4resok) XdrTypeName() string { return "RENAME4resok" }
func (v RENAME4resok) XdrValue() interface{} { return v }
func (v *RENAME4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *RENAME4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssource_cinfo", name), XDR_Change_info4(&v.Source_cinfo))
	x.Marshal(x.Sprintf("%starget_cinfo", name), XDR_Change_info4(&v.Target_cinfo))
}
func XDR_RENAME4resok(v *RENAME4resok) *RENAME4resok { return v }
func (u *RENAME4res) Resok4() *RENAME4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*RENAME4resok); ok {
			return v
		} else {
			var zero RENAME4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("RENAME4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u RENAME4res) XdrValid() bool {
	return true
}
func (u *RENAME4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *RENAME4res) XdrUnionTagName() string {
	return "Status"
}
func (u *RENAME4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_RENAME4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *RENAME4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_RENAME4res = *RENAME4res
func (v *RENAME4res) XdrPointer() interface{} { return v }
func (RENAME4res) XdrTypeName() string { return "RENAME4res" }
func (v RENAME4res) XdrValue() interface{} { return v }
func (v *RENAME4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *RENAME4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_RENAME4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_RENAME4res(v *RENAME4res) *RENAME4res { return v}
type XdrType_RENEW4args = *RENEW4args
func (v *RENEW4args) XdrPointer() interface{} { return v }
func (RENEW4args) XdrTypeName() string { return "RENEW4args" }
func (v RENEW4args) XdrValue() interface{} { return v }
func (v *RENEW4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *RENEW4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sclientid", name), XDR_Clientid4(&v.Clientid))
}
func XDR_RENEW4args(v *RENEW4args) *RENEW4args { return v }
type XdrType_RENEW4res = *RENEW4res
func (v *RENEW4res) XdrPointer() interface{} { return v }
func (RENEW4res) XdrTypeName() string { return "RENEW4res" }
func (v RENEW4res) XdrValue() interface{} { return v }
func (v *RENEW4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *RENEW4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_RENEW4res(v *RENEW4res) *RENEW4res { return v }
type XdrType_RESTOREFH4res = *RESTOREFH4res
func (v *RESTOREFH4res) XdrPointer() interface{} { return v }
func (RESTOREFH4res) XdrTypeName() string { return "RESTOREFH4res" }
func (v RESTOREFH4res) XdrValue() interface{} { return v }
func (v *RESTOREFH4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *RESTOREFH4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_RESTOREFH4res(v *RESTOREFH4res) *RESTOREFH4res { return v }
type XdrType_SAVEFH4res = *SAVEFH4res
func (v *SAVEFH4res) XdrPointer() interface{} { return v }
func (SAVEFH4res) XdrTypeName() string { return "SAVEFH4res" }
func (v SAVEFH4res) XdrValue() interface{} { return v }
func (v *SAVEFH4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SAVEFH4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_SAVEFH4res(v *SAVEFH4res) *SAVEFH4res { return v }
type XdrType_SECINFO4args = *SECINFO4args
func (v *SECINFO4args) XdrPointer() interface{} { return v }
func (SECINFO4args) XdrTypeName() string { return "SECINFO4args" }
func (v SECINFO4args) XdrValue() interface{} { return v }
func (v *SECINFO4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SECINFO4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sname", name), XDR_Component4(&v.Name))
}
func XDR_SECINFO4args(v *SECINFO4args) *SECINFO4args { return v }
var _XdrNames_Rpc_gss_svc_t = map[int32]string{
	int32(RPC_GSS_SVC_NONE): "RPC_GSS_SVC_NONE",
	int32(RPC_GSS_SVC_INTEGRITY): "RPC_GSS_SVC_INTEGRITY",
	int32(RPC_GSS_SVC_PRIVACY): "RPC_GSS_SVC_PRIVACY",
}
var _XdrValues_Rpc_gss_svc_t = map[string]int32{
	"RPC_GSS_SVC_NONE": int32(RPC_GSS_SVC_NONE),
	"RPC_GSS_SVC_INTEGRITY": int32(RPC_GSS_SVC_INTEGRITY),
	"RPC_GSS_SVC_PRIVACY": int32(RPC_GSS_SVC_PRIVACY),
}
func (Rpc_gss_svc_t) XdrEnumNames() map[int32]string {
	return _XdrNames_Rpc_gss_svc_t
}
func (v Rpc_gss_svc_t) String() string {
	if s, ok := _XdrNames_Rpc_gss_svc_t[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Rpc_gss_svc_t#%d", v)
}
func (v *Rpc_gss_svc_t) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Rpc_gss_svc_t[stok]; ok {
			*v = Rpc_gss_svc_t(val)
			return nil
		} else if stok == "Rpc_gss_svc_t" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Rpc_gss_svc_t.", stok))
	}
}
func (v Rpc_gss_svc_t) GetU32() uint32 { return uint32(v) }
func (v *Rpc_gss_svc_t) SetU32(n uint32) { *v = Rpc_gss_svc_t(n) }
func (v *Rpc_gss_svc_t) XdrPointer() interface{} { return v }
func (Rpc_gss_svc_t) XdrTypeName() string { return "Rpc_gss_svc_t" }
func (v Rpc_gss_svc_t) XdrValue() interface{} { return v }
func (v *Rpc_gss_svc_t) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Rpc_gss_svc_t = *Rpc_gss_svc_t
func XDR_Rpc_gss_svc_t(v *Rpc_gss_svc_t) *Rpc_gss_svc_t { return v }
func (v *Rpc_gss_svc_t) XdrInitialize() {
	switch Rpc_gss_svc_t(0) {
	case RPC_GSS_SVC_NONE, RPC_GSS_SVC_INTEGRITY, RPC_GSS_SVC_PRIVACY:
	default:
		if *v == Rpc_gss_svc_t(0) { *v = RPC_GSS_SVC_NONE }
	}
}
type XdrType_Rpcsec_gss_info = *Rpcsec_gss_info
func (v *Rpcsec_gss_info) XdrPointer() interface{} { return v }
func (Rpcsec_gss_info) XdrTypeName() string { return "Rpcsec_gss_info" }
func (v Rpcsec_gss_info) XdrValue() interface{} { return v }
func (v *Rpcsec_gss_info) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Rpcsec_gss_info) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%soid", name), XDR_Sec_oid4(&v.Oid))
	x.Marshal(x.Sprintf("%sqop", name), XDR_Qop4(&v.Qop))
	x.Marshal(x.Sprintf("%sservice", name), XDR_Rpc_gss_svc_t(&v.Service))
}
func XDR_Rpcsec_gss_info(v *Rpcsec_gss_info) *Rpcsec_gss_info { return v }
func (u *Secinfo4) Flavor_info() *Rpcsec_gss_info {
	switch u.Flavor {
	case RPCSEC_GSS:
		if v, ok := u.U.(*Rpcsec_gss_info); ok {
			return v
		} else {
			var zero Rpcsec_gss_info
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Secinfo4.Flavor_info accessed when Flavor == %v", u.Flavor)
		return nil
	}
}
func (u Secinfo4) XdrValid() bool {
	return true
}
func (u *Secinfo4) XdrUnionTag() XdrNum32 {
	return XDR_Uint32_t(&u.Flavor)
}
func (u *Secinfo4) XdrUnionTagName() string {
	return "Flavor"
}
func (u *Secinfo4) XdrUnionBody() XdrType {
	switch u.Flavor {
	case RPCSEC_GSS:
		return XDR_Rpcsec_gss_info(u.Flavor_info())
	default:
		return nil
	}
}
func (u *Secinfo4) XdrUnionBodyName() string {
	switch u.Flavor {
	case RPCSEC_GSS:
		return "Flavor_info"
	default:
		return ""
	}
}
type XdrType_Secinfo4 = *Secinfo4
func (v *Secinfo4) XdrPointer() interface{} { return v }
func (Secinfo4) XdrTypeName() string { return "Secinfo4" }
func (v Secinfo4) XdrValue() interface{} { return v }
func (v *Secinfo4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Secinfo4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32_t(&u.Flavor).XdrMarshal(x, x.Sprintf("%sflavor", name))
	switch u.Flavor {
	case RPCSEC_GSS:
		x.Marshal(x.Sprintf("%sflavor_info", name), XDR_Rpcsec_gss_info(u.Flavor_info()))
		return
	default:
		return
	}
}
func XDR_Secinfo4(v *Secinfo4) *Secinfo4 { return v}
type _XdrVec_unbounded_Secinfo4 []Secinfo4
func (_XdrVec_unbounded_Secinfo4) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Secinfo4) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Secinfo4 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Secinfo4 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Secinfo4) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Secinfo4) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Secinfo4, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Secinfo4) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Secinfo4(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Secinfo4) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Secinfo4) XdrTypeName() string { return "Secinfo4<>" }
func (v *_XdrVec_unbounded_Secinfo4) XdrPointer() interface{} { return (*[]Secinfo4)(v) }
func (v _XdrVec_unbounded_Secinfo4) XdrValue() interface{} { return ([]Secinfo4)(v) }
func (v *_XdrVec_unbounded_Secinfo4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_SECINFO4resok struct {
	*_XdrVec_unbounded_Secinfo4
}
func XDR_SECINFO4resok(v *SECINFO4resok) XdrType_SECINFO4resok {
	return XdrType_SECINFO4resok{(*_XdrVec_unbounded_Secinfo4)(v)}
}
func (XdrType_SECINFO4resok) XdrTypeName() string { return "SECINFO4resok" }
func (v XdrType_SECINFO4resok) XdrUnwrap() XdrType { return v._XdrVec_unbounded_Secinfo4 }
func (u *SECINFO4res) Resok4() *SECINFO4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*SECINFO4resok); ok {
			return v
		} else {
			var zero SECINFO4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("SECINFO4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u SECINFO4res) XdrValid() bool {
	return true
}
func (u *SECINFO4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *SECINFO4res) XdrUnionTagName() string {
	return "Status"
}
func (u *SECINFO4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_SECINFO4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *SECINFO4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_SECINFO4res = *SECINFO4res
func (v *SECINFO4res) XdrPointer() interface{} { return v }
func (SECINFO4res) XdrTypeName() string { return "SECINFO4res" }
func (v SECINFO4res) XdrValue() interface{} { return v }
func (v *SECINFO4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SECINFO4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_SECINFO4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_SECINFO4res(v *SECINFO4res) *SECINFO4res { return v}
type XdrType_SETATTR4args = *SETATTR4args
func (v *SETATTR4args) XdrPointer() interface{} { return v }
func (SETATTR4args) XdrTypeName() string { return "SETATTR4args" }
func (v SETATTR4args) XdrValue() interface{} { return v }
func (v *SETATTR4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SETATTR4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstateid", name), XDR_Stateid4(&v.Stateid))
	x.Marshal(x.Sprintf("%sobj_attributes", name), XDR_Fattr4(&v.Obj_attributes))
}
func XDR_SETATTR4args(v *SETATTR4args) *SETATTR4args { return v }
type XdrType_SETATTR4res = *SETATTR4res
func (v *SETATTR4res) XdrPointer() interface{} { return v }
func (SETATTR4res) XdrTypeName() string { return "SETATTR4res" }
func (v SETATTR4res) XdrValue() interface{} { return v }
func (v *SETATTR4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SETATTR4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
	x.Marshal(x.Sprintf("%sattrsset", name), XDR_Bitmap4(&v.Attrsset))
}
func XDR_SETATTR4res(v *SETATTR4res) *SETATTR4res { return v }
type XdrType_SETCLIENTID4args = *SETCLIENTID4args
func (v *SETCLIENTID4args) XdrPointer() interface{} { return v }
func (SETCLIENTID4args) XdrTypeName() string { return "SETCLIENTID4args" }
func (v SETCLIENTID4args) XdrValue() interface{} { return v }
func (v *SETCLIENTID4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SETCLIENTID4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sclient", name), XDR_Nfs_client_id4(&v.Client))
	x.Marshal(x.Sprintf("%scallback", name), XDR_Cb_client4(&v.Callback))
	x.Marshal(x.Sprintf("%scallback_ident", name), XDR_Uint32_t(&v.Callback_ident))
}
func XDR_SETCLIENTID4args(v *SETCLIENTID4args) *SETCLIENTID4args { return v }
type XdrType_SETCLIENTID4resok = *SETCLIENTID4resok
func (v *SETCLIENTID4resok) XdrPointer() interface{} { return v }
func (SETCLIENTID4resok) XdrTypeName() string { return "SETCLIENTID4resok" }
func (v SETCLIENTID4resok) XdrValue() interface{} { return v }
func (v *SETCLIENTID4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SETCLIENTID4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sclientid", name), XDR_Clientid4(&v.Clientid))
	x.Marshal(x.Sprintf("%ssetclientid_confirm", name), XDR_Verifier4(&v.Setclientid_confirm))
}
func XDR_SETCLIENTID4resok(v *SETCLIENTID4resok) *SETCLIENTID4resok { return v }
func (u *SETCLIENTID4res) Resok4() *SETCLIENTID4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*SETCLIENTID4resok); ok {
			return v
		} else {
			var zero SETCLIENTID4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("SETCLIENTID4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u *SETCLIENTID4res) Client_using() *Clientaddr4 {
	switch u.Status {
	case NFS4ERR_CLID_INUSE:
		if v, ok := u.U.(*Clientaddr4); ok {
			return v
		} else {
			var zero Clientaddr4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("SETCLIENTID4res.Client_using accessed when Status == %v", u.Status)
		return nil
	}
}
func (u SETCLIENTID4res) XdrValid() bool {
	return true
}
func (u *SETCLIENTID4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *SETCLIENTID4res) XdrUnionTagName() string {
	return "Status"
}
func (u *SETCLIENTID4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_SETCLIENTID4resok(u.Resok4())
	case NFS4ERR_CLID_INUSE:
		return XDR_Clientaddr4(u.Client_using())
	default:
		return nil
	}
}
func (u *SETCLIENTID4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	case NFS4ERR_CLID_INUSE:
		return "Client_using"
	default:
		return ""
	}
}
type XdrType_SETCLIENTID4res = *SETCLIENTID4res
func (v *SETCLIENTID4res) XdrPointer() interface{} { return v }
func (SETCLIENTID4res) XdrTypeName() string { return "SETCLIENTID4res" }
func (v SETCLIENTID4res) XdrValue() interface{} { return v }
func (v *SETCLIENTID4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SETCLIENTID4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_SETCLIENTID4resok(u.Resok4()))
		return
	case NFS4ERR_CLID_INUSE:
		x.Marshal(x.Sprintf("%sclient_using", name), XDR_Clientaddr4(u.Client_using()))
		return
	default:
		return
	}
}
func XDR_SETCLIENTID4res(v *SETCLIENTID4res) *SETCLIENTID4res { return v}
type XdrType_SETCLIENTID_CONFIRM4args = *SETCLIENTID_CONFIRM4args
func (v *SETCLIENTID_CONFIRM4args) XdrPointer() interface{} { return v }
func (SETCLIENTID_CONFIRM4args) XdrTypeName() string { return "SETCLIENTID_CONFIRM4args" }
func (v SETCLIENTID_CONFIRM4args) XdrValue() interface{} { return v }
func (v *SETCLIENTID_CONFIRM4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SETCLIENTID_CONFIRM4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sclientid", name), XDR_Clientid4(&v.Clientid))
	x.Marshal(x.Sprintf("%ssetclientid_confirm", name), XDR_Verifier4(&v.Setclientid_confirm))
}
func XDR_SETCLIENTID_CONFIRM4args(v *SETCLIENTID_CONFIRM4args) *SETCLIENTID_CONFIRM4args { return v }
type XdrType_SETCLIENTID_CONFIRM4res = *SETCLIENTID_CONFIRM4res
func (v *SETCLIENTID_CONFIRM4res) XdrPointer() interface{} { return v }
func (SETCLIENTID_CONFIRM4res) XdrTypeName() string { return "SETCLIENTID_CONFIRM4res" }
func (v SETCLIENTID_CONFIRM4res) XdrValue() interface{} { return v }
func (v *SETCLIENTID_CONFIRM4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SETCLIENTID_CONFIRM4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_SETCLIENTID_CONFIRM4res(v *SETCLIENTID_CONFIRM4res) *SETCLIENTID_CONFIRM4res { return v }
type XdrType_VERIFY4args = *VERIFY4args
func (v *VERIFY4args) XdrPointer() interface{} { return v }
func (VERIFY4args) XdrTypeName() string { return "VERIFY4args" }
func (v VERIFY4args) XdrValue() interface{} { return v }
func (v *VERIFY4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *VERIFY4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sobj_attributes", name), XDR_Fattr4(&v.Obj_attributes))
}
func XDR_VERIFY4args(v *VERIFY4args) *VERIFY4args { return v }
type XdrType_VERIFY4res = *VERIFY4res
func (v *VERIFY4res) XdrPointer() interface{} { return v }
func (VERIFY4res) XdrTypeName() string { return "VERIFY4res" }
func (v VERIFY4res) XdrValue() interface{} { return v }
func (v *VERIFY4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *VERIFY4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_VERIFY4res(v *VERIFY4res) *VERIFY4res { return v }
var _XdrNames_Stable_how4 = map[int32]string{
	int32(UNSTABLE4): "UNSTABLE4",
	int32(DATA_SYNC4): "DATA_SYNC4",
	int32(FILE_SYNC4): "FILE_SYNC4",
}
var _XdrValues_Stable_how4 = map[string]int32{
	"UNSTABLE4": int32(UNSTABLE4),
	"DATA_SYNC4": int32(DATA_SYNC4),
	"FILE_SYNC4": int32(FILE_SYNC4),
}
func (Stable_how4) XdrEnumNames() map[int32]string {
	return _XdrNames_Stable_how4
}
func (v Stable_how4) String() string {
	if s, ok := _XdrNames_Stable_how4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Stable_how4#%d", v)
}
func (v *Stable_how4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Stable_how4[stok]; ok {
			*v = Stable_how4(val)
			return nil
		} else if stok == "Stable_how4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Stable_how4.", stok))
	}
}
func (v Stable_how4) GetU32() uint32 { return uint32(v) }
func (v *Stable_how4) SetU32(n uint32) { *v = Stable_how4(n) }
func (v *Stable_how4) XdrPointer() interface{} { return v }
func (Stable_how4) XdrTypeName() string { return "Stable_how4" }
func (v Stable_how4) XdrValue() interface{} { return v }
func (v *Stable_how4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Stable_how4 = *Stable_how4
func XDR_Stable_how4(v *Stable_how4) *Stable_how4 { return v }
type XdrType_WRITE4args = *WRITE4args
func (v *WRITE4args) XdrPointer() interface{} { return v }
func (WRITE4args) XdrTypeName() string { return "WRITE4args" }
func (v WRITE4args) XdrValue() interface{} { return v }
func (v *WRITE4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *WRITE4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstateid", name), XDR_Stateid4(&v.Stateid))
	x.Marshal(x.Sprintf("%soffset", name), XDR_Offset4(&v.Offset))
	x.Marshal(x.Sprintf("%sstable", name), XDR_Stable_how4(&v.Stable))
	x.Marshal(x.Sprintf("%sdata", name), XdrVecOpaque{&v.Data, 0xffffffff})
}
func XDR_WRITE4args(v *WRITE4args) *WRITE4args { return v }
type XdrType_WRITE4resok = *WRITE4resok
func (v *WRITE4resok) XdrPointer() interface{} { return v }
func (WRITE4resok) XdrTypeName() string { return "WRITE4resok" }
func (v WRITE4resok) XdrValue() interface{} { return v }
func (v *WRITE4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *WRITE4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scount", name), XDR_Count4(&v.Count))
	x.Marshal(x.Sprintf("%scommitted", name), XDR_Stable_how4(&v.Committed))
	x.Marshal(x.Sprintf("%swriteverf", name), XDR_Verifier4(&v.Writeverf))
}
func XDR_WRITE4resok(v *WRITE4resok) *WRITE4resok { return v }
func (u *WRITE4res) Resok4() *WRITE4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*WRITE4resok); ok {
			return v
		} else {
			var zero WRITE4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("WRITE4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u WRITE4res) XdrValid() bool {
	return true
}
func (u *WRITE4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *WRITE4res) XdrUnionTagName() string {
	return "Status"
}
func (u *WRITE4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_WRITE4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *WRITE4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_WRITE4res = *WRITE4res
func (v *WRITE4res) XdrPointer() interface{} { return v }
func (WRITE4res) XdrTypeName() string { return "WRITE4res" }
func (v WRITE4res) XdrValue() interface{} { return v }
func (v *WRITE4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *WRITE4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_WRITE4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_WRITE4res(v *WRITE4res) *WRITE4res { return v}
type XdrType_RELEASE_LOCKOWNER4args = *RELEASE_LOCKOWNER4args
func (v *RELEASE_LOCKOWNER4args) XdrPointer() interface{} { return v }
func (RELEASE_LOCKOWNER4args) XdrTypeName() string { return "RELEASE_LOCKOWNER4args" }
func (v RELEASE_LOCKOWNER4args) XdrValue() interface{} { return v }
func (v *RELEASE_LOCKOWNER4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *RELEASE_LOCKOWNER4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slock_owner", name), XDR_Lock_owner4(&v.Lock_owner))
}
func XDR_RELEASE_LOCKOWNER4args(v *RELEASE_LOCKOWNER4args) *RELEASE_LOCKOWNER4args { return v }
type XdrType_RELEASE_LOCKOWNER4res = *RELEASE_LOCKOWNER4res
func (v *RELEASE_LOCKOWNER4res) XdrPointer() interface{} { return v }
func (RELEASE_LOCKOWNER4res) XdrTypeName() string { return "RELEASE_LOCKOWNER4res" }
func (v RELEASE_LOCKOWNER4res) XdrValue() interface{} { return v }
func (v *RELEASE_LOCKOWNER4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *RELEASE_LOCKOWNER4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_RELEASE_LOCKOWNER4res(v *RELEASE_LOCKOWNER4res) *RELEASE_LOCKOWNER4res { return v }
var _XdrTags_Callback_sec_parms4 = map[int32]bool{
	XdrToI32(AUTH_NONE): true,
	XdrToI32(AUTH_SYS): true,
}
func (_ Callback_sec_parms4) XdrValidTags() map[int32]bool {
	return _XdrTags_Callback_sec_parms4
}
/* RFC 1831 */
func (u *Callback_sec_parms4) Cbsp_sys_cred() *Authsys_parms {
	switch Auth_flavor(u.Cb_secflavor) {
	case AUTH_SYS:
		if v, ok := u.U.(*Authsys_parms); ok {
			return v
		} else {
			var zero Authsys_parms
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Callback_sec_parms4.Cbsp_sys_cred accessed when Cb_secflavor == %v", u.Cb_secflavor)
		return nil
	}
}
func (u Callback_sec_parms4) XdrValid() bool {
	switch Auth_flavor(u.Cb_secflavor) {
	case AUTH_NONE,AUTH_SYS:
		return true
	}
	return false
}
func (u *Callback_sec_parms4) XdrUnionTag() XdrNum32 {
	return XDR_Uint32_t(&u.Cb_secflavor)
}
func (u *Callback_sec_parms4) XdrUnionTagName() string {
	return "Cb_secflavor"
}
func (u *Callback_sec_parms4) XdrUnionBody() XdrType {
	switch Auth_flavor(u.Cb_secflavor) {
	case AUTH_NONE:
		return nil
	case AUTH_SYS:
		return XDR_Authsys_parms(u.Cbsp_sys_cred())
	}
	return nil
}
func (u *Callback_sec_parms4) XdrUnionBodyName() string {
	switch Auth_flavor(u.Cb_secflavor) {
	case AUTH_NONE:
		return ""
	case AUTH_SYS:
		return "Cbsp_sys_cred"
	}
	return ""
}
type XdrType_Callback_sec_parms4 = *Callback_sec_parms4
func (v *Callback_sec_parms4) XdrPointer() interface{} { return v }
func (Callback_sec_parms4) XdrTypeName() string { return "Callback_sec_parms4" }
func (v Callback_sec_parms4) XdrValue() interface{} { return v }
func (v *Callback_sec_parms4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Callback_sec_parms4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Uint32_t(&u.Cb_secflavor).XdrMarshal(x, x.Sprintf("%scb_secflavor", name))
	switch Auth_flavor(u.Cb_secflavor) {
	case AUTH_NONE:
		return
	case AUTH_SYS:
		x.Marshal(x.Sprintf("%scbsp_sys_cred", name), XDR_Authsys_parms(u.Cbsp_sys_cred()))
		return
	}
	XdrPanic("invalid Cb_secflavor (%v) in Callback_sec_parms4", u.Cb_secflavor)
}
func (v *Callback_sec_parms4) XdrInitialize() {
	var zero Uint32_t
	switch Auth_flavor(zero) {
	case AUTH_NONE, AUTH_SYS:
	default:
		if v.Cb_secflavor == zero { v.Cb_secflavor = uint32(AUTH_NONE) }
	}
}
func XDR_Callback_sec_parms4(v *Callback_sec_parms4) *Callback_sec_parms4 { return v}
type _XdrVec_1_Uint32_t []Uint32_t
func (_XdrVec_1_Uint32_t) XdrBound() uint32 {
	const bound uint32 = 1 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_1_Uint32_t) XdrCheckLen(length uint32) {
	if length > uint32(1) {
		XdrPanic("_XdrVec_1_Uint32_t length %d exceeds bound 1", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_1_Uint32_t length %d exceeds max int", length)
	}
}
func (v _XdrVec_1_Uint32_t) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_1_Uint32_t) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(1); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Uint32_t, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_1_Uint32_t) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Uint32_t(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_1_Uint32_t) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 1 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_1_Uint32_t) XdrTypeName() string { return "Uint32_t<>" }
func (v *_XdrVec_1_Uint32_t) XdrPointer() interface{} { return (*[]Uint32_t)(v) }
func (v _XdrVec_1_Uint32_t) XdrValue() interface{} { return ([]Uint32_t)(v) }
func (v *_XdrVec_1_Uint32_t) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Channel_attrs4 = *Channel_attrs4
func (v *Channel_attrs4) XdrPointer() interface{} { return v }
func (Channel_attrs4) XdrTypeName() string { return "Channel_attrs4" }
func (v Channel_attrs4) XdrValue() interface{} { return v }
func (v *Channel_attrs4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Channel_attrs4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sca_headerpadsize", name), XDR_Count4(&v.Ca_headerpadsize))
	x.Marshal(x.Sprintf("%sca_maxrequestsize", name), XDR_Count4(&v.Ca_maxrequestsize))
	x.Marshal(x.Sprintf("%sca_maxresponsesize", name), XDR_Count4(&v.Ca_maxresponsesize))
	x.Marshal(x.Sprintf("%sca_maxresponsesize_cached", name), XDR_Count4(&v.Ca_maxresponsesize_cached))
	x.Marshal(x.Sprintf("%sca_maxoperations", name), XDR_Count4(&v.Ca_maxoperations))
	x.Marshal(x.Sprintf("%sca_maxrequests", name), XDR_Count4(&v.Ca_maxrequests))
	x.Marshal(x.Sprintf("%sca_rdma_ird", name), (*_XdrVec_1_Uint32_t)(&v.Ca_rdma_ird))
}
func XDR_Channel_attrs4(v *Channel_attrs4) *Channel_attrs4 { return v }
type _XdrVec_unbounded_Callback_sec_parms4 []Callback_sec_parms4
func (_XdrVec_unbounded_Callback_sec_parms4) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Callback_sec_parms4) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Callback_sec_parms4 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Callback_sec_parms4 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Callback_sec_parms4) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Callback_sec_parms4) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Callback_sec_parms4, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Callback_sec_parms4) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Callback_sec_parms4(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Callback_sec_parms4) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Callback_sec_parms4) XdrTypeName() string { return "Callback_sec_parms4<>" }
func (v *_XdrVec_unbounded_Callback_sec_parms4) XdrPointer() interface{} { return (*[]Callback_sec_parms4)(v) }
func (v _XdrVec_unbounded_Callback_sec_parms4) XdrValue() interface{} { return ([]Callback_sec_parms4)(v) }
func (v *_XdrVec_unbounded_Callback_sec_parms4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_CREATE_SESSION4args = *CREATE_SESSION4args
func (v *CREATE_SESSION4args) XdrPointer() interface{} { return v }
func (CREATE_SESSION4args) XdrTypeName() string { return "CREATE_SESSION4args" }
func (v CREATE_SESSION4args) XdrValue() interface{} { return v }
func (v *CREATE_SESSION4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CREATE_SESSION4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scsa_clientid", name), XDR_Clientid4(&v.Csa_clientid))
	x.Marshal(x.Sprintf("%scsa_sequence", name), XDR_Sequenceid4(&v.Csa_sequence))
	x.Marshal(x.Sprintf("%scsa_flags", name), XDR_Uint32_t(&v.Csa_flags))
	x.Marshal(x.Sprintf("%scsa_fore_chan_attrs", name), XDR_Channel_attrs4(&v.Csa_fore_chan_attrs))
	x.Marshal(x.Sprintf("%scsa_back_chan_attrs", name), XDR_Channel_attrs4(&v.Csa_back_chan_attrs))
	x.Marshal(x.Sprintf("%scsa_cb_program", name), XDR_Uint32_t(&v.Csa_cb_program))
	x.Marshal(x.Sprintf("%scsa_sec_parms", name), (*_XdrVec_unbounded_Callback_sec_parms4)(&v.Csa_sec_parms))
}
func XDR_CREATE_SESSION4args(v *CREATE_SESSION4args) *CREATE_SESSION4args { return v }
type XdrType_CREATE_SESSION4resok = *CREATE_SESSION4resok
func (v *CREATE_SESSION4resok) XdrPointer() interface{} { return v }
func (CREATE_SESSION4resok) XdrTypeName() string { return "CREATE_SESSION4resok" }
func (v CREATE_SESSION4resok) XdrValue() interface{} { return v }
func (v *CREATE_SESSION4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CREATE_SESSION4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%scsr_sessionid", name), XDR_Sessionid4(&v.Csr_sessionid))
	x.Marshal(x.Sprintf("%scsr_sequence", name), XDR_Sequenceid4(&v.Csr_sequence))
	x.Marshal(x.Sprintf("%scsr_flags", name), XDR_Uint32_t(&v.Csr_flags))
	x.Marshal(x.Sprintf("%scsr_fore_chan_attrs", name), XDR_Channel_attrs4(&v.Csr_fore_chan_attrs))
	x.Marshal(x.Sprintf("%scsr_back_chan_attrs", name), XDR_Channel_attrs4(&v.Csr_back_chan_attrs))
}
func XDR_CREATE_SESSION4resok(v *CREATE_SESSION4resok) *CREATE_SESSION4resok { return v }
func (u *CREATE_SESSION4res) Csr_resok4() *CREATE_SESSION4resok {
	switch u.Csr_status {
	case NFS4_OK:
		if v, ok := u.U.(*CREATE_SESSION4resok); ok {
			return v
		} else {
			var zero CREATE_SESSION4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("CREATE_SESSION4res.Csr_resok4 accessed when Csr_status == %v", u.Csr_status)
		return nil
	}
}
func (u CREATE_SESSION4res) XdrValid() bool {
	return true
}
func (u *CREATE_SESSION4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Csr_status)
}
func (u *CREATE_SESSION4res) XdrUnionTagName() string {
	return "Csr_status"
}
func (u *CREATE_SESSION4res) XdrUnionBody() XdrType {
	switch u.Csr_status {
	case NFS4_OK:
		return XDR_CREATE_SESSION4resok(u.Csr_resok4())
	default:
		return nil
	}
}
func (u *CREATE_SESSION4res) XdrUnionBodyName() string {
	switch u.Csr_status {
	case NFS4_OK:
		return "Csr_resok4"
	default:
		return ""
	}
}
type XdrType_CREATE_SESSION4res = *CREATE_SESSION4res
func (v *CREATE_SESSION4res) XdrPointer() interface{} { return v }
func (CREATE_SESSION4res) XdrTypeName() string { return "CREATE_SESSION4res" }
func (v CREATE_SESSION4res) XdrValue() interface{} { return v }
func (v *CREATE_SESSION4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *CREATE_SESSION4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Csr_status).XdrMarshal(x, x.Sprintf("%scsr_status", name))
	switch u.Csr_status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%scsr_resok4", name), XDR_CREATE_SESSION4resok(u.Csr_resok4()))
		return
	default:
		return
	}
}
func XDR_CREATE_SESSION4res(v *CREATE_SESSION4res) *CREATE_SESSION4res { return v}
type XdrType_DESTROY_SESSION4args = *DESTROY_SESSION4args
func (v *DESTROY_SESSION4args) XdrPointer() interface{} { return v }
func (DESTROY_SESSION4args) XdrTypeName() string { return "DESTROY_SESSION4args" }
func (v DESTROY_SESSION4args) XdrValue() interface{} { return v }
func (v *DESTROY_SESSION4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DESTROY_SESSION4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdsa_sessionid", name), XDR_Sessionid4(&v.Dsa_sessionid))
}
func XDR_DESTROY_SESSION4args(v *DESTROY_SESSION4args) *DESTROY_SESSION4args { return v }
type XdrType_DESTROY_SESSION4res = *DESTROY_SESSION4res
func (v *DESTROY_SESSION4res) XdrPointer() interface{} { return v }
func (DESTROY_SESSION4res) XdrTypeName() string { return "DESTROY_SESSION4res" }
func (v DESTROY_SESSION4res) XdrValue() interface{} { return v }
func (v *DESTROY_SESSION4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DESTROY_SESSION4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdsr_status", name), XDR_Nfsstat4(&v.Dsr_status))
}
func XDR_DESTROY_SESSION4res(v *DESTROY_SESSION4res) *DESTROY_SESSION4res { return v }
type XdrType_FREE_STATEID4args = *FREE_STATEID4args
func (v *FREE_STATEID4args) XdrPointer() interface{} { return v }
func (FREE_STATEID4args) XdrTypeName() string { return "FREE_STATEID4args" }
func (v FREE_STATEID4args) XdrValue() interface{} { return v }
func (v *FREE_STATEID4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *FREE_STATEID4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfsa_stateid", name), XDR_Stateid4(&v.Fsa_stateid))
}
func XDR_FREE_STATEID4args(v *FREE_STATEID4args) *FREE_STATEID4args { return v }
type XdrType_FREE_STATEID4res = *FREE_STATEID4res
func (v *FREE_STATEID4res) XdrPointer() interface{} { return v }
func (FREE_STATEID4res) XdrTypeName() string { return "FREE_STATEID4res" }
func (v FREE_STATEID4res) XdrValue() interface{} { return v }
func (v *FREE_STATEID4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *FREE_STATEID4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfsr_status", name), XDR_Nfsstat4(&v.Fsr_status))
}
func XDR_FREE_STATEID4res(v *FREE_STATEID4res) *FREE_STATEID4res { return v }
type XdrType_Attr_notice4 struct {
	XdrType_Nfstime4
}
func XDR_Attr_notice4(v *Attr_notice4) *XdrType_Attr_notice4 {
	return &XdrType_Attr_notice4{XDR_Nfstime4(v)}
}
func (XdrType_Attr_notice4) XdrTypeName() string { return "Attr_notice4" }
func (v XdrType_Attr_notice4) XdrUnwrap() XdrType { return v.XdrType_Nfstime4 }
type XdrType_GET_DIR_DELEGATION4args = *GET_DIR_DELEGATION4args
func (v *GET_DIR_DELEGATION4args) XdrPointer() interface{} { return v }
func (GET_DIR_DELEGATION4args) XdrTypeName() string { return "GET_DIR_DELEGATION4args" }
func (v GET_DIR_DELEGATION4args) XdrValue() interface{} { return v }
func (v *GET_DIR_DELEGATION4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *GET_DIR_DELEGATION4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sgdda_signal_deleg_avail", name), XDR_bool(&v.Gdda_signal_deleg_avail))
	x.Marshal(x.Sprintf("%sgdda_notification_types", name), XDR_Bitmap4(&v.Gdda_notification_types))
	x.Marshal(x.Sprintf("%sgdda_child_attr_delay", name), XDR_Attr_notice4(&v.Gdda_child_attr_delay))
	x.Marshal(x.Sprintf("%sgdda_dir_attr_delay", name), XDR_Attr_notice4(&v.Gdda_dir_attr_delay))
	x.Marshal(x.Sprintf("%sgdda_child_attributes", name), XDR_Bitmap4(&v.Gdda_child_attributes))
	x.Marshal(x.Sprintf("%sgdda_dir_attributes", name), XDR_Bitmap4(&v.Gdda_dir_attributes))
}
func XDR_GET_DIR_DELEGATION4args(v *GET_DIR_DELEGATION4args) *GET_DIR_DELEGATION4args { return v }
type XdrType_GET_DIR_DELEGATION4resok = *GET_DIR_DELEGATION4resok
func (v *GET_DIR_DELEGATION4resok) XdrPointer() interface{} { return v }
func (GET_DIR_DELEGATION4resok) XdrTypeName() string { return "GET_DIR_DELEGATION4resok" }
func (v GET_DIR_DELEGATION4resok) XdrValue() interface{} { return v }
func (v *GET_DIR_DELEGATION4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *GET_DIR_DELEGATION4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sgddr_cookieverf", name), XDR_Verifier4(&v.Gddr_cookieverf))
	x.Marshal(x.Sprintf("%sgddr_stateid", name), XDR_Stateid4(&v.Gddr_stateid))
	x.Marshal(x.Sprintf("%sgddr_notification", name), XDR_Bitmap4(&v.Gddr_notification))
	x.Marshal(x.Sprintf("%sgddr_child_attributes", name), XDR_Bitmap4(&v.Gddr_child_attributes))
	x.Marshal(x.Sprintf("%sgddr_dir_attributes", name), XDR_Bitmap4(&v.Gddr_dir_attributes))
}
func XDR_GET_DIR_DELEGATION4resok(v *GET_DIR_DELEGATION4resok) *GET_DIR_DELEGATION4resok { return v }
var _XdrNames_Gddrnf4_status = map[int32]string{
	int32(GDD4_OK): "GDD4_OK",
	int32(GDD4_UNAVAIL): "GDD4_UNAVAIL",
}
var _XdrValues_Gddrnf4_status = map[string]int32{
	"GDD4_OK": int32(GDD4_OK),
	"GDD4_UNAVAIL": int32(GDD4_UNAVAIL),
}
func (Gddrnf4_status) XdrEnumNames() map[int32]string {
	return _XdrNames_Gddrnf4_status
}
func (v Gddrnf4_status) String() string {
	if s, ok := _XdrNames_Gddrnf4_status[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Gddrnf4_status#%d", v)
}
func (v *Gddrnf4_status) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Gddrnf4_status[stok]; ok {
			*v = Gddrnf4_status(val)
			return nil
		} else if stok == "Gddrnf4_status" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Gddrnf4_status.", stok))
	}
}
func (v Gddrnf4_status) GetU32() uint32 { return uint32(v) }
func (v *Gddrnf4_status) SetU32(n uint32) { *v = Gddrnf4_status(n) }
func (v *Gddrnf4_status) XdrPointer() interface{} { return v }
func (Gddrnf4_status) XdrTypeName() string { return "Gddrnf4_status" }
func (v Gddrnf4_status) XdrValue() interface{} { return v }
func (v *Gddrnf4_status) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Gddrnf4_status = *Gddrnf4_status
func XDR_Gddrnf4_status(v *Gddrnf4_status) *Gddrnf4_status { return v }
var _XdrTags_GET_DIR_DELEGATION4res_non_fatal = map[int32]bool{
	XdrToI32(GDD4_OK): true,
	XdrToI32(GDD4_UNAVAIL): true,
}
func (_ GET_DIR_DELEGATION4res_non_fatal) XdrValidTags() map[int32]bool {
	return _XdrTags_GET_DIR_DELEGATION4res_non_fatal
}
func (u *GET_DIR_DELEGATION4res_non_fatal) Gddrnf_resok4() *GET_DIR_DELEGATION4resok {
	switch u.Gddrnf_status {
	case GDD4_OK:
		if v, ok := u.U.(*GET_DIR_DELEGATION4resok); ok {
			return v
		} else {
			var zero GET_DIR_DELEGATION4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("GET_DIR_DELEGATION4res_non_fatal.Gddrnf_resok4 accessed when Gddrnf_status == %v", u.Gddrnf_status)
		return nil
	}
}
func (u *GET_DIR_DELEGATION4res_non_fatal) Gddrnf_will_signal_deleg_avail() *bool {
	switch u.Gddrnf_status {
	case GDD4_UNAVAIL:
		if v, ok := u.U.(*bool); ok {
			return v
		} else {
			var zero bool
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("GET_DIR_DELEGATION4res_non_fatal.Gddrnf_will_signal_deleg_avail accessed when Gddrnf_status == %v", u.Gddrnf_status)
		return nil
	}
}
func (u GET_DIR_DELEGATION4res_non_fatal) XdrValid() bool {
	switch u.Gddrnf_status {
	case GDD4_OK,GDD4_UNAVAIL:
		return true
	}
	return false
}
func (u *GET_DIR_DELEGATION4res_non_fatal) XdrUnionTag() XdrNum32 {
	return XDR_Gddrnf4_status(&u.Gddrnf_status)
}
func (u *GET_DIR_DELEGATION4res_non_fatal) XdrUnionTagName() string {
	return "Gddrnf_status"
}
func (u *GET_DIR_DELEGATION4res_non_fatal) XdrUnionBody() XdrType {
	switch u.Gddrnf_status {
	case GDD4_OK:
		return XDR_GET_DIR_DELEGATION4resok(u.Gddrnf_resok4())
	case GDD4_UNAVAIL:
		return XDR_bool(u.Gddrnf_will_signal_deleg_avail())
	}
	return nil
}
func (u *GET_DIR_DELEGATION4res_non_fatal) XdrUnionBodyName() string {
	switch u.Gddrnf_status {
	case GDD4_OK:
		return "Gddrnf_resok4"
	case GDD4_UNAVAIL:
		return "Gddrnf_will_signal_deleg_avail"
	}
	return ""
}
type XdrType_GET_DIR_DELEGATION4res_non_fatal = *GET_DIR_DELEGATION4res_non_fatal
func (v *GET_DIR_DELEGATION4res_non_fatal) XdrPointer() interface{} { return v }
func (GET_DIR_DELEGATION4res_non_fatal) XdrTypeName() string { return "GET_DIR_DELEGATION4res_non_fatal" }
func (v GET_DIR_DELEGATION4res_non_fatal) XdrValue() interface{} { return v }
func (v *GET_DIR_DELEGATION4res_non_fatal) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *GET_DIR_DELEGATION4res_non_fatal) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Gddrnf4_status(&u.Gddrnf_status).XdrMarshal(x, x.Sprintf("%sgddrnf_status", name))
	switch u.Gddrnf_status {
	case GDD4_OK:
		x.Marshal(x.Sprintf("%sgddrnf_resok4", name), XDR_GET_DIR_DELEGATION4resok(u.Gddrnf_resok4()))
		return
	case GDD4_UNAVAIL:
		x.Marshal(x.Sprintf("%sgddrnf_will_signal_deleg_avail", name), XDR_bool(u.Gddrnf_will_signal_deleg_avail()))
		return
	}
	XdrPanic("invalid Gddrnf_status (%v) in GET_DIR_DELEGATION4res_non_fatal", u.Gddrnf_status)
}
func XDR_GET_DIR_DELEGATION4res_non_fatal(v *GET_DIR_DELEGATION4res_non_fatal) *GET_DIR_DELEGATION4res_non_fatal { return v}
func (u *GET_DIR_DELEGATION4res) Gddr_res_non_fatal4() *GET_DIR_DELEGATION4res_non_fatal {
	switch u.Gddr_status {
	case NFS4_OK:
		if v, ok := u.U.(*GET_DIR_DELEGATION4res_non_fatal); ok {
			return v
		} else {
			var zero GET_DIR_DELEGATION4res_non_fatal
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("GET_DIR_DELEGATION4res.Gddr_res_non_fatal4 accessed when Gddr_status == %v", u.Gddr_status)
		return nil
	}
}
func (u GET_DIR_DELEGATION4res) XdrValid() bool {
	return true
}
func (u *GET_DIR_DELEGATION4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Gddr_status)
}
func (u *GET_DIR_DELEGATION4res) XdrUnionTagName() string {
	return "Gddr_status"
}
func (u *GET_DIR_DELEGATION4res) XdrUnionBody() XdrType {
	switch u.Gddr_status {
	case NFS4_OK:
		return XDR_GET_DIR_DELEGATION4res_non_fatal(u.Gddr_res_non_fatal4())
	default:
		return nil
	}
}
func (u *GET_DIR_DELEGATION4res) XdrUnionBodyName() string {
	switch u.Gddr_status {
	case NFS4_OK:
		return "Gddr_res_non_fatal4"
	default:
		return ""
	}
}
type XdrType_GET_DIR_DELEGATION4res = *GET_DIR_DELEGATION4res
func (v *GET_DIR_DELEGATION4res) XdrPointer() interface{} { return v }
func (GET_DIR_DELEGATION4res) XdrTypeName() string { return "GET_DIR_DELEGATION4res" }
func (v GET_DIR_DELEGATION4res) XdrValue() interface{} { return v }
func (v *GET_DIR_DELEGATION4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *GET_DIR_DELEGATION4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Gddr_status).XdrMarshal(x, x.Sprintf("%sgddr_status", name))
	switch u.Gddr_status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sgddr_res_non_fatal4", name), XDR_GET_DIR_DELEGATION4res_non_fatal(u.Gddr_res_non_fatal4()))
		return
	default:
		return
	}
}
func XDR_GET_DIR_DELEGATION4res(v *GET_DIR_DELEGATION4res) *GET_DIR_DELEGATION4res { return v}
type XdrType_GETDEVICEINFO4args = *GETDEVICEINFO4args
func (v *GETDEVICEINFO4args) XdrPointer() interface{} { return v }
func (GETDEVICEINFO4args) XdrTypeName() string { return "GETDEVICEINFO4args" }
func (v GETDEVICEINFO4args) XdrValue() interface{} { return v }
func (v *GETDEVICEINFO4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *GETDEVICEINFO4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sgdia_device_id", name), XDR_Deviceid4(&v.Gdia_device_id))
	x.Marshal(x.Sprintf("%sgdia_layout_type", name), XDR_Layouttype4(&v.Gdia_layout_type))
	x.Marshal(x.Sprintf("%sgdia_maxcount", name), XDR_Count4(&v.Gdia_maxcount))
	x.Marshal(x.Sprintf("%sgdia_notify_types", name), XDR_Bitmap4(&v.Gdia_notify_types))
}
func XDR_GETDEVICEINFO4args(v *GETDEVICEINFO4args) *GETDEVICEINFO4args { return v }
type XdrType_GETDEVICEINFO4resok = *GETDEVICEINFO4resok
func (v *GETDEVICEINFO4resok) XdrPointer() interface{} { return v }
func (GETDEVICEINFO4resok) XdrTypeName() string { return "GETDEVICEINFO4resok" }
func (v GETDEVICEINFO4resok) XdrValue() interface{} { return v }
func (v *GETDEVICEINFO4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *GETDEVICEINFO4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sgdir_device_addr", name), XDR_Device_addr4(&v.Gdir_device_addr))
	x.Marshal(x.Sprintf("%sgdir_notification", name), XDR_Bitmap4(&v.Gdir_notification))
}
func XDR_GETDEVICEINFO4resok(v *GETDEVICEINFO4resok) *GETDEVICEINFO4resok { return v }
func (u *GETDEVICEINFO4res) Gdir_resok4() *GETDEVICEINFO4resok {
	switch u.Gdir_status {
	case NFS4_OK:
		if v, ok := u.U.(*GETDEVICEINFO4resok); ok {
			return v
		} else {
			var zero GETDEVICEINFO4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("GETDEVICEINFO4res.Gdir_resok4 accessed when Gdir_status == %v", u.Gdir_status)
		return nil
	}
}
func (u *GETDEVICEINFO4res) Gdir_mincount() *Count4 {
	switch u.Gdir_status {
	case NFS4ERR_TOOSMALL:
		if v, ok := u.U.(*Count4); ok {
			return v
		} else {
			var zero Count4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("GETDEVICEINFO4res.Gdir_mincount accessed when Gdir_status == %v", u.Gdir_status)
		return nil
	}
}
func (u GETDEVICEINFO4res) XdrValid() bool {
	return true
}
func (u *GETDEVICEINFO4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Gdir_status)
}
func (u *GETDEVICEINFO4res) XdrUnionTagName() string {
	return "Gdir_status"
}
func (u *GETDEVICEINFO4res) XdrUnionBody() XdrType {
	switch u.Gdir_status {
	case NFS4_OK:
		return XDR_GETDEVICEINFO4resok(u.Gdir_resok4())
	case NFS4ERR_TOOSMALL:
		return XDR_Count4(u.Gdir_mincount())
	default:
		return nil
	}
}
func (u *GETDEVICEINFO4res) XdrUnionBodyName() string {
	switch u.Gdir_status {
	case NFS4_OK:
		return "Gdir_resok4"
	case NFS4ERR_TOOSMALL:
		return "Gdir_mincount"
	default:
		return ""
	}
}
type XdrType_GETDEVICEINFO4res = *GETDEVICEINFO4res
func (v *GETDEVICEINFO4res) XdrPointer() interface{} { return v }
func (GETDEVICEINFO4res) XdrTypeName() string { return "GETDEVICEINFO4res" }
func (v GETDEVICEINFO4res) XdrValue() interface{} { return v }
func (v *GETDEVICEINFO4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *GETDEVICEINFO4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Gdir_status).XdrMarshal(x, x.Sprintf("%sgdir_status", name))
	switch u.Gdir_status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sgdir_resok4", name), XDR_GETDEVICEINFO4resok(u.Gdir_resok4()))
		return
	case NFS4ERR_TOOSMALL:
		x.Marshal(x.Sprintf("%sgdir_mincount", name), XDR_Count4(u.Gdir_mincount()))
		return
	default:
		return
	}
}
func XDR_GETDEVICEINFO4res(v *GETDEVICEINFO4res) *GETDEVICEINFO4res { return v}
type XdrType_GETDEVICELIST4args = *GETDEVICELIST4args
func (v *GETDEVICELIST4args) XdrPointer() interface{} { return v }
func (GETDEVICELIST4args) XdrTypeName() string { return "GETDEVICELIST4args" }
func (v GETDEVICELIST4args) XdrValue() interface{} { return v }
func (v *GETDEVICELIST4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *GETDEVICELIST4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sgdla_layout_type", name), XDR_Layouttype4(&v.Gdla_layout_type))
	x.Marshal(x.Sprintf("%sgdla_maxdevices", name), XDR_Count4(&v.Gdla_maxdevices))
	x.Marshal(x.Sprintf("%sgdla_cookie", name), XDR_Nfs_cookie4(&v.Gdla_cookie))
	x.Marshal(x.Sprintf("%sgdla_cookieverf", name), XDR_Verifier4(&v.Gdla_cookieverf))
}
func XDR_GETDEVICELIST4args(v *GETDEVICELIST4args) *GETDEVICELIST4args { return v }
type _XdrVec_unbounded_Deviceid4 []Deviceid4
func (_XdrVec_unbounded_Deviceid4) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Deviceid4) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Deviceid4 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Deviceid4 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Deviceid4) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Deviceid4) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Deviceid4, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Deviceid4) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Deviceid4(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Deviceid4) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Deviceid4) XdrTypeName() string { return "Deviceid4<>" }
func (v *_XdrVec_unbounded_Deviceid4) XdrPointer() interface{} { return (*[]Deviceid4)(v) }
func (v _XdrVec_unbounded_Deviceid4) XdrValue() interface{} { return ([]Deviceid4)(v) }
func (v *_XdrVec_unbounded_Deviceid4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_GETDEVICELIST4resok = *GETDEVICELIST4resok
func (v *GETDEVICELIST4resok) XdrPointer() interface{} { return v }
func (GETDEVICELIST4resok) XdrTypeName() string { return "GETDEVICELIST4resok" }
func (v GETDEVICELIST4resok) XdrValue() interface{} { return v }
func (v *GETDEVICELIST4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *GETDEVICELIST4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sgdlr_cookie", name), XDR_Nfs_cookie4(&v.Gdlr_cookie))
	x.Marshal(x.Sprintf("%sgdlr_cookieverf", name), XDR_Verifier4(&v.Gdlr_cookieverf))
	x.Marshal(x.Sprintf("%sgdlr_deviceid_list", name), (*_XdrVec_unbounded_Deviceid4)(&v.Gdlr_deviceid_list))
	x.Marshal(x.Sprintf("%sgdlr_eof", name), XDR_bool(&v.Gdlr_eof))
}
func XDR_GETDEVICELIST4resok(v *GETDEVICELIST4resok) *GETDEVICELIST4resok { return v }
func (u *GETDEVICELIST4res) Gdlr_resok4() *GETDEVICELIST4resok {
	switch u.Gdlr_status {
	case NFS4_OK:
		if v, ok := u.U.(*GETDEVICELIST4resok); ok {
			return v
		} else {
			var zero GETDEVICELIST4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("GETDEVICELIST4res.Gdlr_resok4 accessed when Gdlr_status == %v", u.Gdlr_status)
		return nil
	}
}
func (u GETDEVICELIST4res) XdrValid() bool {
	return true
}
func (u *GETDEVICELIST4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Gdlr_status)
}
func (u *GETDEVICELIST4res) XdrUnionTagName() string {
	return "Gdlr_status"
}
func (u *GETDEVICELIST4res) XdrUnionBody() XdrType {
	switch u.Gdlr_status {
	case NFS4_OK:
		return XDR_GETDEVICELIST4resok(u.Gdlr_resok4())
	default:
		return nil
	}
}
func (u *GETDEVICELIST4res) XdrUnionBodyName() string {
	switch u.Gdlr_status {
	case NFS4_OK:
		return "Gdlr_resok4"
	default:
		return ""
	}
}
type XdrType_GETDEVICELIST4res = *GETDEVICELIST4res
func (v *GETDEVICELIST4res) XdrPointer() interface{} { return v }
func (GETDEVICELIST4res) XdrTypeName() string { return "GETDEVICELIST4res" }
func (v GETDEVICELIST4res) XdrValue() interface{} { return v }
func (v *GETDEVICELIST4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *GETDEVICELIST4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Gdlr_status).XdrMarshal(x, x.Sprintf("%sgdlr_status", name))
	switch u.Gdlr_status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sgdlr_resok4", name), XDR_GETDEVICELIST4resok(u.Gdlr_resok4()))
		return
	default:
		return
	}
}
func XDR_GETDEVICELIST4res(v *GETDEVICELIST4res) *GETDEVICELIST4res { return v}
var _XdrTags_Newtime4 = map[int32]bool{
	XdrToI32(true): true,
	XdrToI32(false): true,
}
func (_ Newtime4) XdrValidTags() map[int32]bool {
	return _XdrTags_Newtime4
}
func (u *Newtime4) Nt_time() *Nfstime4 {
	switch u.Nt_timechanged {
	case true:
		if v, ok := u.U.(*Nfstime4); ok {
			return v
		} else {
			var zero Nfstime4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Newtime4.Nt_time accessed when Nt_timechanged == %v", u.Nt_timechanged)
		return nil
	}
}
func (u Newtime4) XdrValid() bool {
	switch u.Nt_timechanged {
	case true,false:
		return true
	}
	return false
}
func (u *Newtime4) XdrUnionTag() XdrNum32 {
	return XDR_bool(&u.Nt_timechanged)
}
func (u *Newtime4) XdrUnionTagName() string {
	return "Nt_timechanged"
}
func (u *Newtime4) XdrUnionBody() XdrType {
	switch u.Nt_timechanged {
	case true:
		return XDR_Nfstime4(u.Nt_time())
	case false:
		return nil
	}
	return nil
}
func (u *Newtime4) XdrUnionBodyName() string {
	switch u.Nt_timechanged {
	case true:
		return "Nt_time"
	case false:
		return ""
	}
	return ""
}
type XdrType_Newtime4 = *Newtime4
func (v *Newtime4) XdrPointer() interface{} { return v }
func (Newtime4) XdrTypeName() string { return "Newtime4" }
func (v Newtime4) XdrValue() interface{} { return v }
func (v *Newtime4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Newtime4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_bool(&u.Nt_timechanged).XdrMarshal(x, x.Sprintf("%snt_timechanged", name))
	switch u.Nt_timechanged {
	case true:
		x.Marshal(x.Sprintf("%snt_time", name), XDR_Nfstime4(u.Nt_time()))
		return
	case false:
		return
	}
	XdrPanic("invalid Nt_timechanged (%v) in Newtime4", u.Nt_timechanged)
}
func XDR_Newtime4(v *Newtime4) *Newtime4 { return v}
var _XdrTags_Newoffset4 = map[int32]bool{
	XdrToI32(true): true,
	XdrToI32(false): true,
}
func (_ Newoffset4) XdrValidTags() map[int32]bool {
	return _XdrTags_Newoffset4
}
func (u *Newoffset4) No_offset() *Offset4 {
	switch u.No_newoffset {
	case true:
		if v, ok := u.U.(*Offset4); ok {
			return v
		} else {
			var zero Offset4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Newoffset4.No_offset accessed when No_newoffset == %v", u.No_newoffset)
		return nil
	}
}
func (u Newoffset4) XdrValid() bool {
	switch u.No_newoffset {
	case true,false:
		return true
	}
	return false
}
func (u *Newoffset4) XdrUnionTag() XdrNum32 {
	return XDR_bool(&u.No_newoffset)
}
func (u *Newoffset4) XdrUnionTagName() string {
	return "No_newoffset"
}
func (u *Newoffset4) XdrUnionBody() XdrType {
	switch u.No_newoffset {
	case true:
		return XDR_Offset4(u.No_offset())
	case false:
		return nil
	}
	return nil
}
func (u *Newoffset4) XdrUnionBodyName() string {
	switch u.No_newoffset {
	case true:
		return "No_offset"
	case false:
		return ""
	}
	return ""
}
type XdrType_Newoffset4 = *Newoffset4
func (v *Newoffset4) XdrPointer() interface{} { return v }
func (Newoffset4) XdrTypeName() string { return "Newoffset4" }
func (v Newoffset4) XdrValue() interface{} { return v }
func (v *Newoffset4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Newoffset4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_bool(&u.No_newoffset).XdrMarshal(x, x.Sprintf("%sno_newoffset", name))
	switch u.No_newoffset {
	case true:
		x.Marshal(x.Sprintf("%sno_offset", name), XDR_Offset4(u.No_offset()))
		return
	case false:
		return
	}
	XdrPanic("invalid No_newoffset (%v) in Newoffset4", u.No_newoffset)
}
func XDR_Newoffset4(v *Newoffset4) *Newoffset4 { return v}
type XdrType_LAYOUTCOMMIT4args = *LAYOUTCOMMIT4args
func (v *LAYOUTCOMMIT4args) XdrPointer() interface{} { return v }
func (LAYOUTCOMMIT4args) XdrTypeName() string { return "LAYOUTCOMMIT4args" }
func (v LAYOUTCOMMIT4args) XdrValue() interface{} { return v }
func (v *LAYOUTCOMMIT4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LAYOUTCOMMIT4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sloca_offset", name), XDR_Offset4(&v.Loca_offset))
	x.Marshal(x.Sprintf("%sloca_length", name), XDR_Length4(&v.Loca_length))
	x.Marshal(x.Sprintf("%sloca_reclaim", name), XDR_bool(&v.Loca_reclaim))
	x.Marshal(x.Sprintf("%sloca_stateid", name), XDR_Stateid4(&v.Loca_stateid))
	x.Marshal(x.Sprintf("%sloca_last_write_offset", name), XDR_Newoffset4(&v.Loca_last_write_offset))
	x.Marshal(x.Sprintf("%sloca_time_modify", name), XDR_Newtime4(&v.Loca_time_modify))
	x.Marshal(x.Sprintf("%sloca_layoutupdate", name), XDR_Layoutupdate4(&v.Loca_layoutupdate))
}
func XDR_LAYOUTCOMMIT4args(v *LAYOUTCOMMIT4args) *LAYOUTCOMMIT4args { return v }
var _XdrTags_Newsize4 = map[int32]bool{
	XdrToI32(true): true,
	XdrToI32(false): true,
}
func (_ Newsize4) XdrValidTags() map[int32]bool {
	return _XdrTags_Newsize4
}
func (u *Newsize4) Ns_size() *Length4 {
	switch u.Ns_sizechanged {
	case true:
		if v, ok := u.U.(*Length4); ok {
			return v
		} else {
			var zero Length4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Newsize4.Ns_size accessed when Ns_sizechanged == %v", u.Ns_sizechanged)
		return nil
	}
}
func (u Newsize4) XdrValid() bool {
	switch u.Ns_sizechanged {
	case true,false:
		return true
	}
	return false
}
func (u *Newsize4) XdrUnionTag() XdrNum32 {
	return XDR_bool(&u.Ns_sizechanged)
}
func (u *Newsize4) XdrUnionTagName() string {
	return "Ns_sizechanged"
}
func (u *Newsize4) XdrUnionBody() XdrType {
	switch u.Ns_sizechanged {
	case true:
		return XDR_Length4(u.Ns_size())
	case false:
		return nil
	}
	return nil
}
func (u *Newsize4) XdrUnionBodyName() string {
	switch u.Ns_sizechanged {
	case true:
		return "Ns_size"
	case false:
		return ""
	}
	return ""
}
type XdrType_Newsize4 = *Newsize4
func (v *Newsize4) XdrPointer() interface{} { return v }
func (Newsize4) XdrTypeName() string { return "Newsize4" }
func (v Newsize4) XdrValue() interface{} { return v }
func (v *Newsize4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Newsize4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_bool(&u.Ns_sizechanged).XdrMarshal(x, x.Sprintf("%sns_sizechanged", name))
	switch u.Ns_sizechanged {
	case true:
		x.Marshal(x.Sprintf("%sns_size", name), XDR_Length4(u.Ns_size()))
		return
	case false:
		return
	}
	XdrPanic("invalid Ns_sizechanged (%v) in Newsize4", u.Ns_sizechanged)
}
func XDR_Newsize4(v *Newsize4) *Newsize4 { return v}
type XdrType_LAYOUTCOMMIT4resok = *LAYOUTCOMMIT4resok
func (v *LAYOUTCOMMIT4resok) XdrPointer() interface{} { return v }
func (LAYOUTCOMMIT4resok) XdrTypeName() string { return "LAYOUTCOMMIT4resok" }
func (v LAYOUTCOMMIT4resok) XdrValue() interface{} { return v }
func (v *LAYOUTCOMMIT4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LAYOUTCOMMIT4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slocr_newsize", name), XDR_Newsize4(&v.Locr_newsize))
}
func XDR_LAYOUTCOMMIT4resok(v *LAYOUTCOMMIT4resok) *LAYOUTCOMMIT4resok { return v }
func (u *LAYOUTCOMMIT4res) Locr_resok4() *LAYOUTCOMMIT4resok {
	switch u.Locr_status {
	case NFS4_OK:
		if v, ok := u.U.(*LAYOUTCOMMIT4resok); ok {
			return v
		} else {
			var zero LAYOUTCOMMIT4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("LAYOUTCOMMIT4res.Locr_resok4 accessed when Locr_status == %v", u.Locr_status)
		return nil
	}
}
func (u LAYOUTCOMMIT4res) XdrValid() bool {
	return true
}
func (u *LAYOUTCOMMIT4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Locr_status)
}
func (u *LAYOUTCOMMIT4res) XdrUnionTagName() string {
	return "Locr_status"
}
func (u *LAYOUTCOMMIT4res) XdrUnionBody() XdrType {
	switch u.Locr_status {
	case NFS4_OK:
		return XDR_LAYOUTCOMMIT4resok(u.Locr_resok4())
	default:
		return nil
	}
}
func (u *LAYOUTCOMMIT4res) XdrUnionBodyName() string {
	switch u.Locr_status {
	case NFS4_OK:
		return "Locr_resok4"
	default:
		return ""
	}
}
type XdrType_LAYOUTCOMMIT4res = *LAYOUTCOMMIT4res
func (v *LAYOUTCOMMIT4res) XdrPointer() interface{} { return v }
func (LAYOUTCOMMIT4res) XdrTypeName() string { return "LAYOUTCOMMIT4res" }
func (v LAYOUTCOMMIT4res) XdrValue() interface{} { return v }
func (v *LAYOUTCOMMIT4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LAYOUTCOMMIT4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Locr_status).XdrMarshal(x, x.Sprintf("%slocr_status", name))
	switch u.Locr_status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%slocr_resok4", name), XDR_LAYOUTCOMMIT4resok(u.Locr_resok4()))
		return
	default:
		return
	}
}
func XDR_LAYOUTCOMMIT4res(v *LAYOUTCOMMIT4res) *LAYOUTCOMMIT4res { return v}
type XdrType_LAYOUTGET4args = *LAYOUTGET4args
func (v *LAYOUTGET4args) XdrPointer() interface{} { return v }
func (LAYOUTGET4args) XdrTypeName() string { return "LAYOUTGET4args" }
func (v LAYOUTGET4args) XdrValue() interface{} { return v }
func (v *LAYOUTGET4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LAYOUTGET4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sloga_signal_layout_avail", name), XDR_bool(&v.Loga_signal_layout_avail))
	x.Marshal(x.Sprintf("%sloga_layout_type", name), XDR_Layouttype4(&v.Loga_layout_type))
	x.Marshal(x.Sprintf("%sloga_iomode", name), XDR_Layoutiomode4(&v.Loga_iomode))
	x.Marshal(x.Sprintf("%sloga_offset", name), XDR_Offset4(&v.Loga_offset))
	x.Marshal(x.Sprintf("%sloga_length", name), XDR_Length4(&v.Loga_length))
	x.Marshal(x.Sprintf("%sloga_minlength", name), XDR_Length4(&v.Loga_minlength))
	x.Marshal(x.Sprintf("%sloga_stateid", name), XDR_Stateid4(&v.Loga_stateid))
	x.Marshal(x.Sprintf("%sloga_maxcount", name), XDR_Count4(&v.Loga_maxcount))
}
func XDR_LAYOUTGET4args(v *LAYOUTGET4args) *LAYOUTGET4args { return v }
type _XdrVec_unbounded_Layout4 []Layout4
func (_XdrVec_unbounded_Layout4) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Layout4) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Layout4 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Layout4 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Layout4) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Layout4) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Layout4, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Layout4) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Layout4(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Layout4) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Layout4) XdrTypeName() string { return "Layout4<>" }
func (v *_XdrVec_unbounded_Layout4) XdrPointer() interface{} { return (*[]Layout4)(v) }
func (v _XdrVec_unbounded_Layout4) XdrValue() interface{} { return ([]Layout4)(v) }
func (v *_XdrVec_unbounded_Layout4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_LAYOUTGET4resok = *LAYOUTGET4resok
func (v *LAYOUTGET4resok) XdrPointer() interface{} { return v }
func (LAYOUTGET4resok) XdrTypeName() string { return "LAYOUTGET4resok" }
func (v LAYOUTGET4resok) XdrValue() interface{} { return v }
func (v *LAYOUTGET4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LAYOUTGET4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slogr_return_on_close", name), XDR_bool(&v.Logr_return_on_close))
	x.Marshal(x.Sprintf("%slogr_stateid", name), XDR_Stateid4(&v.Logr_stateid))
	x.Marshal(x.Sprintf("%slogr_layout", name), (*_XdrVec_unbounded_Layout4)(&v.Logr_layout))
}
func XDR_LAYOUTGET4resok(v *LAYOUTGET4resok) *LAYOUTGET4resok { return v }
func (u *LAYOUTGET4res) Logr_resok4() *LAYOUTGET4resok {
	switch u.Logr_status {
	case NFS4_OK:
		if v, ok := u.U.(*LAYOUTGET4resok); ok {
			return v
		} else {
			var zero LAYOUTGET4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("LAYOUTGET4res.Logr_resok4 accessed when Logr_status == %v", u.Logr_status)
		return nil
	}
}
func (u *LAYOUTGET4res) Logr_will_signal_layout_avail() *bool {
	switch u.Logr_status {
	case NFS4ERR_LAYOUTTRYLATER:
		if v, ok := u.U.(*bool); ok {
			return v
		} else {
			var zero bool
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("LAYOUTGET4res.Logr_will_signal_layout_avail accessed when Logr_status == %v", u.Logr_status)
		return nil
	}
}
func (u LAYOUTGET4res) XdrValid() bool {
	return true
}
func (u *LAYOUTGET4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Logr_status)
}
func (u *LAYOUTGET4res) XdrUnionTagName() string {
	return "Logr_status"
}
func (u *LAYOUTGET4res) XdrUnionBody() XdrType {
	switch u.Logr_status {
	case NFS4_OK:
		return XDR_LAYOUTGET4resok(u.Logr_resok4())
	case NFS4ERR_LAYOUTTRYLATER:
		return XDR_bool(u.Logr_will_signal_layout_avail())
	default:
		return nil
	}
}
func (u *LAYOUTGET4res) XdrUnionBodyName() string {
	switch u.Logr_status {
	case NFS4_OK:
		return "Logr_resok4"
	case NFS4ERR_LAYOUTTRYLATER:
		return "Logr_will_signal_layout_avail"
	default:
		return ""
	}
}
type XdrType_LAYOUTGET4res = *LAYOUTGET4res
func (v *LAYOUTGET4res) XdrPointer() interface{} { return v }
func (LAYOUTGET4res) XdrTypeName() string { return "LAYOUTGET4res" }
func (v LAYOUTGET4res) XdrValue() interface{} { return v }
func (v *LAYOUTGET4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LAYOUTGET4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Logr_status).XdrMarshal(x, x.Sprintf("%slogr_status", name))
	switch u.Logr_status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%slogr_resok4", name), XDR_LAYOUTGET4resok(u.Logr_resok4()))
		return
	case NFS4ERR_LAYOUTTRYLATER:
		x.Marshal(x.Sprintf("%slogr_will_signal_layout_avail", name), XDR_bool(u.Logr_will_signal_layout_avail()))
		return
	default:
		return
	}
}
func XDR_LAYOUTGET4res(v *LAYOUTGET4res) *LAYOUTGET4res { return v}
var _XdrNames_Layoutreturn_type4 = map[int32]string{
	int32(LAYOUTRETURN4_FILE): "LAYOUTRETURN4_FILE",
	int32(LAYOUTRETURN4_FSID): "LAYOUTRETURN4_FSID",
	int32(LAYOUTRETURN4_ALL): "LAYOUTRETURN4_ALL",
}
var _XdrValues_Layoutreturn_type4 = map[string]int32{
	"LAYOUTRETURN4_FILE": int32(LAYOUTRETURN4_FILE),
	"LAYOUTRETURN4_FSID": int32(LAYOUTRETURN4_FSID),
	"LAYOUTRETURN4_ALL": int32(LAYOUTRETURN4_ALL),
}
func (Layoutreturn_type4) XdrEnumNames() map[int32]string {
	return _XdrNames_Layoutreturn_type4
}
func (v Layoutreturn_type4) String() string {
	if s, ok := _XdrNames_Layoutreturn_type4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Layoutreturn_type4#%d", v)
}
func (v *Layoutreturn_type4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Layoutreturn_type4[stok]; ok {
			*v = Layoutreturn_type4(val)
			return nil
		} else if stok == "Layoutreturn_type4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Layoutreturn_type4.", stok))
	}
}
func (v Layoutreturn_type4) GetU32() uint32 { return uint32(v) }
func (v *Layoutreturn_type4) SetU32(n uint32) { *v = Layoutreturn_type4(n) }
func (v *Layoutreturn_type4) XdrPointer() interface{} { return v }
func (Layoutreturn_type4) XdrTypeName() string { return "Layoutreturn_type4" }
func (v Layoutreturn_type4) XdrValue() interface{} { return v }
func (v *Layoutreturn_type4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Layoutreturn_type4 = *Layoutreturn_type4
func XDR_Layoutreturn_type4(v *Layoutreturn_type4) *Layoutreturn_type4 { return v }
func (v *Layoutreturn_type4) XdrInitialize() {
	switch Layoutreturn_type4(0) {
	case LAYOUTRETURN4_FILE, LAYOUTRETURN4_FSID, LAYOUTRETURN4_ALL:
	default:
		if *v == Layoutreturn_type4(0) { *v = LAYOUTRETURN4_FILE }
	}
}
type XdrType_Layoutreturn_file4 = *Layoutreturn_file4
func (v *Layoutreturn_file4) XdrPointer() interface{} { return v }
func (Layoutreturn_file4) XdrTypeName() string { return "Layoutreturn_file4" }
func (v Layoutreturn_file4) XdrValue() interface{} { return v }
func (v *Layoutreturn_file4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Layoutreturn_file4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slrf_offset", name), XDR_Offset4(&v.Lrf_offset))
	x.Marshal(x.Sprintf("%slrf_length", name), XDR_Length4(&v.Lrf_length))
	x.Marshal(x.Sprintf("%slrf_stateid", name), XDR_Stateid4(&v.Lrf_stateid))
	x.Marshal(x.Sprintf("%slrf_body", name), XdrVecOpaque{&v.Lrf_body, 0xffffffff})
}
func XDR_Layoutreturn_file4(v *Layoutreturn_file4) *Layoutreturn_file4 { return v }
func (u *Layoutreturn4) Lr_layout() *Layoutreturn_file4 {
	switch u.Lr_returntype {
	case LAYOUTRETURN4_FILE:
		if v, ok := u.U.(*Layoutreturn_file4); ok {
			return v
		} else {
			var zero Layoutreturn_file4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Layoutreturn4.Lr_layout accessed when Lr_returntype == %v", u.Lr_returntype)
		return nil
	}
}
func (u Layoutreturn4) XdrValid() bool {
	return true
}
func (u *Layoutreturn4) XdrUnionTag() XdrNum32 {
	return XDR_Layoutreturn_type4(&u.Lr_returntype)
}
func (u *Layoutreturn4) XdrUnionTagName() string {
	return "Lr_returntype"
}
func (u *Layoutreturn4) XdrUnionBody() XdrType {
	switch u.Lr_returntype {
	case LAYOUTRETURN4_FILE:
		return XDR_Layoutreturn_file4(u.Lr_layout())
	default:
		return nil
	}
}
func (u *Layoutreturn4) XdrUnionBodyName() string {
	switch u.Lr_returntype {
	case LAYOUTRETURN4_FILE:
		return "Lr_layout"
	default:
		return ""
	}
}
type XdrType_Layoutreturn4 = *Layoutreturn4
func (v *Layoutreturn4) XdrPointer() interface{} { return v }
func (Layoutreturn4) XdrTypeName() string { return "Layoutreturn4" }
func (v Layoutreturn4) XdrValue() interface{} { return v }
func (v *Layoutreturn4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Layoutreturn4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Layoutreturn_type4(&u.Lr_returntype).XdrMarshal(x, x.Sprintf("%slr_returntype", name))
	switch u.Lr_returntype {
	case LAYOUTRETURN4_FILE:
		x.Marshal(x.Sprintf("%slr_layout", name), XDR_Layoutreturn_file4(u.Lr_layout()))
		return
	default:
		return
	}
}
func XDR_Layoutreturn4(v *Layoutreturn4) *Layoutreturn4 { return v}
type XdrType_LAYOUTRETURN4args = *LAYOUTRETURN4args
func (v *LAYOUTRETURN4args) XdrPointer() interface{} { return v }
func (LAYOUTRETURN4args) XdrTypeName() string { return "LAYOUTRETURN4args" }
func (v LAYOUTRETURN4args) XdrValue() interface{} { return v }
func (v *LAYOUTRETURN4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *LAYOUTRETURN4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%slora_reclaim", name), XDR_bool(&v.Lora_reclaim))
	x.Marshal(x.Sprintf("%slora_layout_type", name), XDR_Layouttype4(&v.Lora_layout_type))
	x.Marshal(x.Sprintf("%slora_iomode", name), XDR_Layoutiomode4(&v.Lora_iomode))
	x.Marshal(x.Sprintf("%slora_layoutreturn", name), XDR_Layoutreturn4(&v.Lora_layoutreturn))
}
func XDR_LAYOUTRETURN4args(v *LAYOUTRETURN4args) *LAYOUTRETURN4args { return v }
var _XdrTags_Layoutreturn_stateid = map[int32]bool{
	XdrToI32(true): true,
	XdrToI32(false): true,
}
func (_ Layoutreturn_stateid) XdrValidTags() map[int32]bool {
	return _XdrTags_Layoutreturn_stateid
}
func (u *Layoutreturn_stateid) Lrs_stateid() *Stateid4 {
	switch u.Lrs_present {
	case true:
		if v, ok := u.U.(*Stateid4); ok {
			return v
		} else {
			var zero Stateid4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Layoutreturn_stateid.Lrs_stateid accessed when Lrs_present == %v", u.Lrs_present)
		return nil
	}
}
func (u Layoutreturn_stateid) XdrValid() bool {
	switch u.Lrs_present {
	case true,false:
		return true
	}
	return false
}
func (u *Layoutreturn_stateid) XdrUnionTag() XdrNum32 {
	return XDR_bool(&u.Lrs_present)
}
func (u *Layoutreturn_stateid) XdrUnionTagName() string {
	return "Lrs_present"
}
func (u *Layoutreturn_stateid) XdrUnionBody() XdrType {
	switch u.Lrs_present {
	case true:
		return XDR_Stateid4(u.Lrs_stateid())
	case false:
		return nil
	}
	return nil
}
func (u *Layoutreturn_stateid) XdrUnionBodyName() string {
	switch u.Lrs_present {
	case true:
		return "Lrs_stateid"
	case false:
		return ""
	}
	return ""
}
type XdrType_Layoutreturn_stateid = *Layoutreturn_stateid
func (v *Layoutreturn_stateid) XdrPointer() interface{} { return v }
func (Layoutreturn_stateid) XdrTypeName() string { return "Layoutreturn_stateid" }
func (v Layoutreturn_stateid) XdrValue() interface{} { return v }
func (v *Layoutreturn_stateid) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Layoutreturn_stateid) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_bool(&u.Lrs_present).XdrMarshal(x, x.Sprintf("%slrs_present", name))
	switch u.Lrs_present {
	case true:
		x.Marshal(x.Sprintf("%slrs_stateid", name), XDR_Stateid4(u.Lrs_stateid()))
		return
	case false:
		return
	}
	XdrPanic("invalid Lrs_present (%v) in Layoutreturn_stateid", u.Lrs_present)
}
func XDR_Layoutreturn_stateid(v *Layoutreturn_stateid) *Layoutreturn_stateid { return v}
func (u *LAYOUTRETURN4res) Lorr_stateid() *Layoutreturn_stateid {
	switch u.Lorr_status {
	case NFS4_OK:
		if v, ok := u.U.(*Layoutreturn_stateid); ok {
			return v
		} else {
			var zero Layoutreturn_stateid
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("LAYOUTRETURN4res.Lorr_stateid accessed when Lorr_status == %v", u.Lorr_status)
		return nil
	}
}
func (u LAYOUTRETURN4res) XdrValid() bool {
	return true
}
func (u *LAYOUTRETURN4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Lorr_status)
}
func (u *LAYOUTRETURN4res) XdrUnionTagName() string {
	return "Lorr_status"
}
func (u *LAYOUTRETURN4res) XdrUnionBody() XdrType {
	switch u.Lorr_status {
	case NFS4_OK:
		return XDR_Layoutreturn_stateid(u.Lorr_stateid())
	default:
		return nil
	}
}
func (u *LAYOUTRETURN4res) XdrUnionBodyName() string {
	switch u.Lorr_status {
	case NFS4_OK:
		return "Lorr_stateid"
	default:
		return ""
	}
}
type XdrType_LAYOUTRETURN4res = *LAYOUTRETURN4res
func (v *LAYOUTRETURN4res) XdrPointer() interface{} { return v }
func (LAYOUTRETURN4res) XdrTypeName() string { return "LAYOUTRETURN4res" }
func (v LAYOUTRETURN4res) XdrValue() interface{} { return v }
func (v *LAYOUTRETURN4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *LAYOUTRETURN4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Lorr_status).XdrMarshal(x, x.Sprintf("%slorr_status", name))
	switch u.Lorr_status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%slorr_stateid", name), XDR_Layoutreturn_stateid(u.Lorr_stateid()))
		return
	default:
		return
	}
}
func XDR_LAYOUTRETURN4res(v *LAYOUTRETURN4res) *LAYOUTRETURN4res { return v}
var _XdrNames_Secinfo_style4 = map[int32]string{
	int32(SECINFO_STYLE4_CURRENT_FH): "SECINFO_STYLE4_CURRENT_FH",
	int32(SECINFO_STYLE4_PARENT): "SECINFO_STYLE4_PARENT",
}
var _XdrValues_Secinfo_style4 = map[string]int32{
	"SECINFO_STYLE4_CURRENT_FH": int32(SECINFO_STYLE4_CURRENT_FH),
	"SECINFO_STYLE4_PARENT": int32(SECINFO_STYLE4_PARENT),
}
func (Secinfo_style4) XdrEnumNames() map[int32]string {
	return _XdrNames_Secinfo_style4
}
func (v Secinfo_style4) String() string {
	if s, ok := _XdrNames_Secinfo_style4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Secinfo_style4#%d", v)
}
func (v *Secinfo_style4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Secinfo_style4[stok]; ok {
			*v = Secinfo_style4(val)
			return nil
		} else if stok == "Secinfo_style4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Secinfo_style4.", stok))
	}
}
func (v Secinfo_style4) GetU32() uint32 { return uint32(v) }
func (v *Secinfo_style4) SetU32(n uint32) { *v = Secinfo_style4(n) }
func (v *Secinfo_style4) XdrPointer() interface{} { return v }
func (Secinfo_style4) XdrTypeName() string { return "Secinfo_style4" }
func (v Secinfo_style4) XdrValue() interface{} { return v }
func (v *Secinfo_style4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Secinfo_style4 = *Secinfo_style4
func XDR_Secinfo_style4(v *Secinfo_style4) *Secinfo_style4 { return v }
type XdrType_SECINFO_NO_NAME4args struct {
	XdrType_Secinfo_style4
}
func XDR_SECINFO_NO_NAME4args(v *SECINFO_NO_NAME4args) *XdrType_SECINFO_NO_NAME4args {
	return &XdrType_SECINFO_NO_NAME4args{XDR_Secinfo_style4(v)}
}
func (XdrType_SECINFO_NO_NAME4args) XdrTypeName() string { return "SECINFO_NO_NAME4args" }
func (v XdrType_SECINFO_NO_NAME4args) XdrUnwrap() XdrType { return v.XdrType_Secinfo_style4 }
type XdrType_SECINFO_NO_NAME4res struct {
	XdrType_SECINFO4res
}
func XDR_SECINFO_NO_NAME4res(v *SECINFO_NO_NAME4res) *XdrType_SECINFO_NO_NAME4res {
	return &XdrType_SECINFO_NO_NAME4res{XDR_SECINFO4res(v)}
}
func (XdrType_SECINFO_NO_NAME4res) XdrTypeName() string { return "SECINFO_NO_NAME4res" }
func (v XdrType_SECINFO_NO_NAME4res) XdrUnwrap() XdrType { return v.XdrType_SECINFO4res }
type XdrType_SEQUENCE4args = *SEQUENCE4args
func (v *SEQUENCE4args) XdrPointer() interface{} { return v }
func (SEQUENCE4args) XdrTypeName() string { return "SEQUENCE4args" }
func (v SEQUENCE4args) XdrValue() interface{} { return v }
func (v *SEQUENCE4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SEQUENCE4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssa_sessionid", name), XDR_Sessionid4(&v.Sa_sessionid))
	x.Marshal(x.Sprintf("%ssa_sequenceid", name), XDR_Sequenceid4(&v.Sa_sequenceid))
	x.Marshal(x.Sprintf("%ssa_slotid", name), XDR_Slotid4(&v.Sa_slotid))
	x.Marshal(x.Sprintf("%ssa_highest_slotid", name), XDR_Slotid4(&v.Sa_highest_slotid))
	x.Marshal(x.Sprintf("%ssa_cachethis", name), XDR_bool(&v.Sa_cachethis))
}
func XDR_SEQUENCE4args(v *SEQUENCE4args) *SEQUENCE4args { return v }
type XdrType_SEQUENCE4resok = *SEQUENCE4resok
func (v *SEQUENCE4resok) XdrPointer() interface{} { return v }
func (SEQUENCE4resok) XdrTypeName() string { return "SEQUENCE4resok" }
func (v SEQUENCE4resok) XdrValue() interface{} { return v }
func (v *SEQUENCE4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SEQUENCE4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssr_sessionid", name), XDR_Sessionid4(&v.Sr_sessionid))
	x.Marshal(x.Sprintf("%ssr_sequenceid", name), XDR_Sequenceid4(&v.Sr_sequenceid))
	x.Marshal(x.Sprintf("%ssr_slotid", name), XDR_Slotid4(&v.Sr_slotid))
	x.Marshal(x.Sprintf("%ssr_highest_slotid", name), XDR_Slotid4(&v.Sr_highest_slotid))
	x.Marshal(x.Sprintf("%ssr_target_highest_slotid", name), XDR_Slotid4(&v.Sr_target_highest_slotid))
	x.Marshal(x.Sprintf("%ssr_status_flags", name), XDR_Uint32_t(&v.Sr_status_flags))
}
func XDR_SEQUENCE4resok(v *SEQUENCE4resok) *SEQUENCE4resok { return v }
func (u *SEQUENCE4res) Sr_resok4() *SEQUENCE4resok {
	switch u.Sr_status {
	case NFS4_OK:
		if v, ok := u.U.(*SEQUENCE4resok); ok {
			return v
		} else {
			var zero SEQUENCE4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("SEQUENCE4res.Sr_resok4 accessed when Sr_status == %v", u.Sr_status)
		return nil
	}
}
func (u SEQUENCE4res) XdrValid() bool {
	return true
}
func (u *SEQUENCE4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Sr_status)
}
func (u *SEQUENCE4res) XdrUnionTagName() string {
	return "Sr_status"
}
func (u *SEQUENCE4res) XdrUnionBody() XdrType {
	switch u.Sr_status {
	case NFS4_OK:
		return XDR_SEQUENCE4resok(u.Sr_resok4())
	default:
		return nil
	}
}
func (u *SEQUENCE4res) XdrUnionBodyName() string {
	switch u.Sr_status {
	case NFS4_OK:
		return "Sr_resok4"
	default:
		return ""
	}
}
type XdrType_SEQUENCE4res = *SEQUENCE4res
func (v *SEQUENCE4res) XdrPointer() interface{} { return v }
func (SEQUENCE4res) XdrTypeName() string { return "SEQUENCE4res" }
func (v SEQUENCE4res) XdrValue() interface{} { return v }
func (v *SEQUENCE4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SEQUENCE4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Sr_status).XdrMarshal(x, x.Sprintf("%ssr_status", name))
	switch u.Sr_status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%ssr_resok4", name), XDR_SEQUENCE4resok(u.Sr_resok4()))
		return
	default:
		return
	}
}
func XDR_SEQUENCE4res(v *SEQUENCE4res) *SEQUENCE4res { return v}
type XdrType_Ssa_digest_input4 = *Ssa_digest_input4
func (v *Ssa_digest_input4) XdrPointer() interface{} { return v }
func (Ssa_digest_input4) XdrTypeName() string { return "Ssa_digest_input4" }
func (v Ssa_digest_input4) XdrValue() interface{} { return v }
func (v *Ssa_digest_input4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Ssa_digest_input4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssdi_seqargs", name), XDR_SEQUENCE4args(&v.Sdi_seqargs))
}
func XDR_Ssa_digest_input4(v *Ssa_digest_input4) *Ssa_digest_input4 { return v }
type XdrType_SET_SSV4args = *SET_SSV4args
func (v *SET_SSV4args) XdrPointer() interface{} { return v }
func (SET_SSV4args) XdrTypeName() string { return "SET_SSV4args" }
func (v SET_SSV4args) XdrValue() interface{} { return v }
func (v *SET_SSV4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SET_SSV4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sssa_ssv", name), XdrVecOpaque{&v.Ssa_ssv, 0xffffffff})
	x.Marshal(x.Sprintf("%sssa_digest", name), XdrVecOpaque{&v.Ssa_digest, 0xffffffff})
}
func XDR_SET_SSV4args(v *SET_SSV4args) *SET_SSV4args { return v }
type XdrType_Ssr_digest_input4 = *Ssr_digest_input4
func (v *Ssr_digest_input4) XdrPointer() interface{} { return v }
func (Ssr_digest_input4) XdrTypeName() string { return "Ssr_digest_input4" }
func (v Ssr_digest_input4) XdrValue() interface{} { return v }
func (v *Ssr_digest_input4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *Ssr_digest_input4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%ssdi_seqres", name), XDR_SEQUENCE4res(&v.Sdi_seqres))
}
func XDR_Ssr_digest_input4(v *Ssr_digest_input4) *Ssr_digest_input4 { return v }
type XdrType_SET_SSV4resok = *SET_SSV4resok
func (v *SET_SSV4resok) XdrPointer() interface{} { return v }
func (SET_SSV4resok) XdrTypeName() string { return "SET_SSV4resok" }
func (v SET_SSV4resok) XdrValue() interface{} { return v }
func (v *SET_SSV4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *SET_SSV4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sssr_digest", name), XdrVecOpaque{&v.Ssr_digest, 0xffffffff})
}
func XDR_SET_SSV4resok(v *SET_SSV4resok) *SET_SSV4resok { return v }
func (u *SET_SSV4res) Ssr_resok4() *SET_SSV4resok {
	switch u.Ssr_status {
	case NFS4_OK:
		if v, ok := u.U.(*SET_SSV4resok); ok {
			return v
		} else {
			var zero SET_SSV4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("SET_SSV4res.Ssr_resok4 accessed when Ssr_status == %v", u.Ssr_status)
		return nil
	}
}
func (u SET_SSV4res) XdrValid() bool {
	return true
}
func (u *SET_SSV4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Ssr_status)
}
func (u *SET_SSV4res) XdrUnionTagName() string {
	return "Ssr_status"
}
func (u *SET_SSV4res) XdrUnionBody() XdrType {
	switch u.Ssr_status {
	case NFS4_OK:
		return XDR_SET_SSV4resok(u.Ssr_resok4())
	default:
		return nil
	}
}
func (u *SET_SSV4res) XdrUnionBodyName() string {
	switch u.Ssr_status {
	case NFS4_OK:
		return "Ssr_resok4"
	default:
		return ""
	}
}
type XdrType_SET_SSV4res = *SET_SSV4res
func (v *SET_SSV4res) XdrPointer() interface{} { return v }
func (SET_SSV4res) XdrTypeName() string { return "SET_SSV4res" }
func (v SET_SSV4res) XdrValue() interface{} { return v }
func (v *SET_SSV4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *SET_SSV4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Ssr_status).XdrMarshal(x, x.Sprintf("%sssr_status", name))
	switch u.Ssr_status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sssr_resok4", name), XDR_SET_SSV4resok(u.Ssr_resok4()))
		return
	default:
		return
	}
}
func XDR_SET_SSV4res(v *SET_SSV4res) *SET_SSV4res { return v}
type _XdrVec_unbounded_Stateid4 []Stateid4
func (_XdrVec_unbounded_Stateid4) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Stateid4) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Stateid4 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Stateid4 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Stateid4) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Stateid4) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Stateid4, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Stateid4) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Stateid4(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Stateid4) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Stateid4) XdrTypeName() string { return "Stateid4<>" }
func (v *_XdrVec_unbounded_Stateid4) XdrPointer() interface{} { return (*[]Stateid4)(v) }
func (v _XdrVec_unbounded_Stateid4) XdrValue() interface{} { return ([]Stateid4)(v) }
func (v *_XdrVec_unbounded_Stateid4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_TEST_STATEID4args = *TEST_STATEID4args
func (v *TEST_STATEID4args) XdrPointer() interface{} { return v }
func (TEST_STATEID4args) XdrTypeName() string { return "TEST_STATEID4args" }
func (v TEST_STATEID4args) XdrValue() interface{} { return v }
func (v *TEST_STATEID4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TEST_STATEID4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sts_stateids", name), (*_XdrVec_unbounded_Stateid4)(&v.Ts_stateids))
}
func XDR_TEST_STATEID4args(v *TEST_STATEID4args) *TEST_STATEID4args { return v }
type _XdrVec_unbounded_Nfsstat4 []Nfsstat4
func (_XdrVec_unbounded_Nfsstat4) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Nfsstat4) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Nfsstat4 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Nfsstat4 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Nfsstat4) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Nfsstat4) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Nfsstat4, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Nfsstat4) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Nfsstat4(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Nfsstat4) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Nfsstat4) XdrTypeName() string { return "Nfsstat4<>" }
func (v *_XdrVec_unbounded_Nfsstat4) XdrPointer() interface{} { return (*[]Nfsstat4)(v) }
func (v _XdrVec_unbounded_Nfsstat4) XdrValue() interface{} { return ([]Nfsstat4)(v) }
func (v *_XdrVec_unbounded_Nfsstat4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_TEST_STATEID4resok = *TEST_STATEID4resok
func (v *TEST_STATEID4resok) XdrPointer() interface{} { return v }
func (TEST_STATEID4resok) XdrTypeName() string { return "TEST_STATEID4resok" }
func (v TEST_STATEID4resok) XdrValue() interface{} { return v }
func (v *TEST_STATEID4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *TEST_STATEID4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stsr_status_codes", name), (*_XdrVec_unbounded_Nfsstat4)(&v.Tsr_status_codes))
}
func XDR_TEST_STATEID4resok(v *TEST_STATEID4resok) *TEST_STATEID4resok { return v }
func (u *TEST_STATEID4res) Tsr_resok4() *TEST_STATEID4resok {
	switch u.Tsr_status {
	case NFS4_OK:
		if v, ok := u.U.(*TEST_STATEID4resok); ok {
			return v
		} else {
			var zero TEST_STATEID4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("TEST_STATEID4res.Tsr_resok4 accessed when Tsr_status == %v", u.Tsr_status)
		return nil
	}
}
func (u TEST_STATEID4res) XdrValid() bool {
	return true
}
func (u *TEST_STATEID4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Tsr_status)
}
func (u *TEST_STATEID4res) XdrUnionTagName() string {
	return "Tsr_status"
}
func (u *TEST_STATEID4res) XdrUnionBody() XdrType {
	switch u.Tsr_status {
	case NFS4_OK:
		return XDR_TEST_STATEID4resok(u.Tsr_resok4())
	default:
		return nil
	}
}
func (u *TEST_STATEID4res) XdrUnionBodyName() string {
	switch u.Tsr_status {
	case NFS4_OK:
		return "Tsr_resok4"
	default:
		return ""
	}
}
type XdrType_TEST_STATEID4res = *TEST_STATEID4res
func (v *TEST_STATEID4res) XdrPointer() interface{} { return v }
func (TEST_STATEID4res) XdrTypeName() string { return "TEST_STATEID4res" }
func (v TEST_STATEID4res) XdrValue() interface{} { return v }
func (v *TEST_STATEID4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *TEST_STATEID4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Tsr_status).XdrMarshal(x, x.Sprintf("%stsr_status", name))
	switch u.Tsr_status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%stsr_resok4", name), XDR_TEST_STATEID4resok(u.Tsr_resok4()))
		return
	default:
		return
	}
}
func XDR_TEST_STATEID4res(v *TEST_STATEID4res) *TEST_STATEID4res { return v}
var _XdrTags_Deleg_claim4 = map[int32]bool{
	XdrToI32(CLAIM_FH): true,
	XdrToI32(CLAIM_DELEG_PREV_FH): true,
	XdrToI32(CLAIM_PREVIOUS): true,
}
func (_ Deleg_claim4) XdrValidTags() map[int32]bool {
	return _XdrTags_Deleg_claim4
}
func (u *Deleg_claim4) Dc_delegate_type() *Open_delegation_type4 {
	switch u.Dc_claim {
	case CLAIM_PREVIOUS:
		if v, ok := u.U.(*Open_delegation_type4); ok {
			return v
		} else {
			var zero Open_delegation_type4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Deleg_claim4.Dc_delegate_type accessed when Dc_claim == %v", u.Dc_claim)
		return nil
	}
}
func (u Deleg_claim4) XdrValid() bool {
	switch u.Dc_claim {
	case CLAIM_FH,CLAIM_DELEG_PREV_FH,CLAIM_PREVIOUS:
		return true
	}
	return false
}
func (u *Deleg_claim4) XdrUnionTag() XdrNum32 {
	return XDR_Open_claim_type4(&u.Dc_claim)
}
func (u *Deleg_claim4) XdrUnionTagName() string {
	return "Dc_claim"
}
func (u *Deleg_claim4) XdrUnionBody() XdrType {
	switch u.Dc_claim {
	case CLAIM_FH:
		return nil
	case CLAIM_DELEG_PREV_FH:
		return nil
	case CLAIM_PREVIOUS:
		return XDR_Open_delegation_type4(u.Dc_delegate_type())
	}
	return nil
}
func (u *Deleg_claim4) XdrUnionBodyName() string {
	switch u.Dc_claim {
	case CLAIM_FH:
		return ""
	case CLAIM_DELEG_PREV_FH:
		return ""
	case CLAIM_PREVIOUS:
		return "Dc_delegate_type"
	}
	return ""
}
type XdrType_Deleg_claim4 = *Deleg_claim4
func (v *Deleg_claim4) XdrPointer() interface{} { return v }
func (Deleg_claim4) XdrTypeName() string { return "Deleg_claim4" }
func (v Deleg_claim4) XdrValue() interface{} { return v }
func (v *Deleg_claim4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Deleg_claim4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Open_claim_type4(&u.Dc_claim).XdrMarshal(x, x.Sprintf("%sdc_claim", name))
	switch u.Dc_claim {
	case CLAIM_FH:
		return
	case CLAIM_DELEG_PREV_FH:
		return
	case CLAIM_PREVIOUS:
		x.Marshal(x.Sprintf("%sdc_delegate_type", name), XDR_Open_delegation_type4(u.Dc_delegate_type()))
		return
	}
	XdrPanic("invalid Dc_claim (%v) in Deleg_claim4", u.Dc_claim)
}
func (v *Deleg_claim4) XdrInitialize() {
	var zero Open_claim_type4
	switch zero {
	case CLAIM_FH, CLAIM_DELEG_PREV_FH, CLAIM_PREVIOUS:
	default:
		if v.Dc_claim == zero { v.Dc_claim = CLAIM_FH }
	}
}
func XDR_Deleg_claim4(v *Deleg_claim4) *Deleg_claim4 { return v}
type XdrType_WANT_DELEGATION4args = *WANT_DELEGATION4args
func (v *WANT_DELEGATION4args) XdrPointer() interface{} { return v }
func (WANT_DELEGATION4args) XdrTypeName() string { return "WANT_DELEGATION4args" }
func (v WANT_DELEGATION4args) XdrValue() interface{} { return v }
func (v *WANT_DELEGATION4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *WANT_DELEGATION4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%swda_want", name), XDR_Uint32_t(&v.Wda_want))
	x.Marshal(x.Sprintf("%swda_claim", name), XDR_Deleg_claim4(&v.Wda_claim))
}
func XDR_WANT_DELEGATION4args(v *WANT_DELEGATION4args) *WANT_DELEGATION4args { return v }
func (u *WANT_DELEGATION4res) Wdr_resok4() *Open_delegation4 {
	switch u.Wdr_status {
	case NFS4_OK:
		if v, ok := u.U.(*Open_delegation4); ok {
			return v
		} else {
			var zero Open_delegation4
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("WANT_DELEGATION4res.Wdr_resok4 accessed when Wdr_status == %v", u.Wdr_status)
		return nil
	}
}
func (u WANT_DELEGATION4res) XdrValid() bool {
	return true
}
func (u *WANT_DELEGATION4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Wdr_status)
}
func (u *WANT_DELEGATION4res) XdrUnionTagName() string {
	return "Wdr_status"
}
func (u *WANT_DELEGATION4res) XdrUnionBody() XdrType {
	switch u.Wdr_status {
	case NFS4_OK:
		return XDR_Open_delegation4(u.Wdr_resok4())
	default:
		return nil
	}
}
func (u *WANT_DELEGATION4res) XdrUnionBodyName() string {
	switch u.Wdr_status {
	case NFS4_OK:
		return "Wdr_resok4"
	default:
		return ""
	}
}
type XdrType_WANT_DELEGATION4res = *WANT_DELEGATION4res
func (v *WANT_DELEGATION4res) XdrPointer() interface{} { return v }
func (WANT_DELEGATION4res) XdrTypeName() string { return "WANT_DELEGATION4res" }
func (v WANT_DELEGATION4res) XdrValue() interface{} { return v }
func (v *WANT_DELEGATION4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *WANT_DELEGATION4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Wdr_status).XdrMarshal(x, x.Sprintf("%swdr_status", name))
	switch u.Wdr_status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%swdr_resok4", name), XDR_Open_delegation4(u.Wdr_resok4()))
		return
	default:
		return
	}
}
func XDR_WANT_DELEGATION4res(v *WANT_DELEGATION4res) *WANT_DELEGATION4res { return v}
type XdrType_DESTROY_CLIENTID4args = *DESTROY_CLIENTID4args
func (v *DESTROY_CLIENTID4args) XdrPointer() interface{} { return v }
func (DESTROY_CLIENTID4args) XdrTypeName() string { return "DESTROY_CLIENTID4args" }
func (v DESTROY_CLIENTID4args) XdrValue() interface{} { return v }
func (v *DESTROY_CLIENTID4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DESTROY_CLIENTID4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdca_clientid", name), XDR_Clientid4(&v.Dca_clientid))
}
func XDR_DESTROY_CLIENTID4args(v *DESTROY_CLIENTID4args) *DESTROY_CLIENTID4args { return v }
type XdrType_DESTROY_CLIENTID4res = *DESTROY_CLIENTID4res
func (v *DESTROY_CLIENTID4res) XdrPointer() interface{} { return v }
func (DESTROY_CLIENTID4res) XdrTypeName() string { return "DESTROY_CLIENTID4res" }
func (v DESTROY_CLIENTID4res) XdrValue() interface{} { return v }
func (v *DESTROY_CLIENTID4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *DESTROY_CLIENTID4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sdcr_status", name), XDR_Nfsstat4(&v.Dcr_status))
}
func XDR_DESTROY_CLIENTID4res(v *DESTROY_CLIENTID4res) *DESTROY_CLIENTID4res { return v }
type XdrType_RECLAIM_COMPLETE4args = *RECLAIM_COMPLETE4args
func (v *RECLAIM_COMPLETE4args) XdrPointer() interface{} { return v }
func (RECLAIM_COMPLETE4args) XdrTypeName() string { return "RECLAIM_COMPLETE4args" }
func (v RECLAIM_COMPLETE4args) XdrValue() interface{} { return v }
func (v *RECLAIM_COMPLETE4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *RECLAIM_COMPLETE4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%srca_one_fs", name), XDR_bool(&v.Rca_one_fs))
}
func XDR_RECLAIM_COMPLETE4args(v *RECLAIM_COMPLETE4args) *RECLAIM_COMPLETE4args { return v }
type XdrType_RECLAIM_COMPLETE4res = *RECLAIM_COMPLETE4res
func (v *RECLAIM_COMPLETE4res) XdrPointer() interface{} { return v }
func (RECLAIM_COMPLETE4res) XdrTypeName() string { return "RECLAIM_COMPLETE4res" }
func (v RECLAIM_COMPLETE4res) XdrValue() interface{} { return v }
func (v *RECLAIM_COMPLETE4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *RECLAIM_COMPLETE4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%srcr_status", name), XDR_Nfsstat4(&v.Rcr_status))
}
func XDR_RECLAIM_COMPLETE4res(v *RECLAIM_COMPLETE4res) *RECLAIM_COMPLETE4res { return v }
type XdrType_ILLEGAL4res = *ILLEGAL4res
func (v *ILLEGAL4res) XdrPointer() interface{} { return v }
func (ILLEGAL4res) XdrTypeName() string { return "ILLEGAL4res" }
func (v ILLEGAL4res) XdrValue() interface{} { return v }
func (v *ILLEGAL4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *ILLEGAL4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_ILLEGAL4res(v *ILLEGAL4res) *ILLEGAL4res { return v }
var _XdrNames_Nfs_opnum4 = map[int32]string{
	int32(OP_ACCESS): "OP_ACCESS",
	int32(OP_CLOSE): "OP_CLOSE",
	int32(OP_COMMIT): "OP_COMMIT",
	int32(OP_CREATE): "OP_CREATE",
	int32(OP_DELEGPURGE): "OP_DELEGPURGE",
	int32(OP_DELEGRETURN): "OP_DELEGRETURN",
	int32(OP_GETATTR): "OP_GETATTR",
	int32(OP_GETFH): "OP_GETFH",
	int32(OP_LINK): "OP_LINK",
	int32(OP_LOCK): "OP_LOCK",
	int32(OP_LOCKT): "OP_LOCKT",
	int32(OP_LOCKU): "OP_LOCKU",
	int32(OP_LOOKUP): "OP_LOOKUP",
	int32(OP_LOOKUPP): "OP_LOOKUPP",
	int32(OP_NVERIFY): "OP_NVERIFY",
	int32(OP_OPEN): "OP_OPEN",
	int32(OP_OPENATTR): "OP_OPENATTR",
	int32(OP_OPEN_CONFIRM): "OP_OPEN_CONFIRM",
	int32(OP_OPEN_DOWNGRADE): "OP_OPEN_DOWNGRADE",
	int32(OP_PUTFH): "OP_PUTFH",
	int32(OP_PUTPUBFH): "OP_PUTPUBFH",
	int32(OP_PUTROOTFH): "OP_PUTROOTFH",
	int32(OP_READ): "OP_READ",
	int32(OP_READDIR): "OP_READDIR",
	int32(OP_READLINK): "OP_READLINK",
	int32(OP_REMOVE): "OP_REMOVE",
	int32(OP_RENAME): "OP_RENAME",
	int32(OP_RENEW): "OP_RENEW",
	int32(OP_RESTOREFH): "OP_RESTOREFH",
	int32(OP_SAVEFH): "OP_SAVEFH",
	int32(OP_SECINFO): "OP_SECINFO",
	int32(OP_SETATTR): "OP_SETATTR",
	int32(OP_SETCLIENTID): "OP_SETCLIENTID",
	int32(OP_SETCLIENTID_CONFIRM): "OP_SETCLIENTID_CONFIRM",
	int32(OP_VERIFY): "OP_VERIFY",
	int32(OP_WRITE): "OP_WRITE",
	int32(OP_RELEASE_LOCKOWNER): "OP_RELEASE_LOCKOWNER",
	int32(OP_CREATE_SESSION): "OP_CREATE_SESSION",
	int32(OP_DESTROY_SESSION): "OP_DESTROY_SESSION",
	int32(OP_FREE_STATEID): "OP_FREE_STATEID",
	int32(OP_GET_DIR_DELEGATION): "OP_GET_DIR_DELEGATION",
	int32(OP_GETDEVICEINFO): "OP_GETDEVICEINFO",
	int32(OP_GETDEVICELIST): "OP_GETDEVICELIST",
	int32(OP_LAYOUTCOMMIT): "OP_LAYOUTCOMMIT",
	int32(OP_LAYOUTGET): "OP_LAYOUTGET",
	int32(OP_LAYOUTRETURN): "OP_LAYOUTRETURN",
	int32(OP_SECINFO_NO_NAME): "OP_SECINFO_NO_NAME",
	int32(OP_SEQUENCE): "OP_SEQUENCE",
	int32(OP_SET_SSV): "OP_SET_SSV",
	int32(OP_TEST_STATEID): "OP_TEST_STATEID",
	int32(OP_WANT_DELEGATION): "OP_WANT_DELEGATION",
	int32(OP_DESTROY_CLIENTID): "OP_DESTROY_CLIENTID",
	int32(OP_RECLAIM_COMPLETE): "OP_RECLAIM_COMPLETE",
	int32(OP_ILLEGAL): "OP_ILLEGAL",
}
var _XdrValues_Nfs_opnum4 = map[string]int32{
	"OP_ACCESS": int32(OP_ACCESS),
	"OP_CLOSE": int32(OP_CLOSE),
	"OP_COMMIT": int32(OP_COMMIT),
	"OP_CREATE": int32(OP_CREATE),
	"OP_DELEGPURGE": int32(OP_DELEGPURGE),
	"OP_DELEGRETURN": int32(OP_DELEGRETURN),
	"OP_GETATTR": int32(OP_GETATTR),
	"OP_GETFH": int32(OP_GETFH),
	"OP_LINK": int32(OP_LINK),
	"OP_LOCK": int32(OP_LOCK),
	"OP_LOCKT": int32(OP_LOCKT),
	"OP_LOCKU": int32(OP_LOCKU),
	"OP_LOOKUP": int32(OP_LOOKUP),
	"OP_LOOKUPP": int32(OP_LOOKUPP),
	"OP_NVERIFY": int32(OP_NVERIFY),
	"OP_OPEN": int32(OP_OPEN),
	"OP_OPENATTR": int32(OP_OPENATTR),
	"OP_OPEN_CONFIRM": int32(OP_OPEN_CONFIRM),
	"OP_OPEN_DOWNGRADE": int32(OP_OPEN_DOWNGRADE),
	"OP_PUTFH": int32(OP_PUTFH),
	"OP_PUTPUBFH": int32(OP_PUTPUBFH),
	"OP_PUTROOTFH": int32(OP_PUTROOTFH),
	"OP_READ": int32(OP_READ),
	"OP_READDIR": int32(OP_READDIR),
	"OP_READLINK": int32(OP_READLINK),
	"OP_REMOVE": int32(OP_REMOVE),
	"OP_RENAME": int32(OP_RENAME),
	"OP_RENEW": int32(OP_RENEW),
	"OP_RESTOREFH": int32(OP_RESTOREFH),
	"OP_SAVEFH": int32(OP_SAVEFH),
	"OP_SECINFO": int32(OP_SECINFO),
	"OP_SETATTR": int32(OP_SETATTR),
	"OP_SETCLIENTID": int32(OP_SETCLIENTID),
	"OP_SETCLIENTID_CONFIRM": int32(OP_SETCLIENTID_CONFIRM),
	"OP_VERIFY": int32(OP_VERIFY),
	"OP_WRITE": int32(OP_WRITE),
	"OP_RELEASE_LOCKOWNER": int32(OP_RELEASE_LOCKOWNER),
	"OP_CREATE_SESSION": int32(OP_CREATE_SESSION),
	"OP_DESTROY_SESSION": int32(OP_DESTROY_SESSION),
	"OP_FREE_STATEID": int32(OP_FREE_STATEID),
	"OP_GET_DIR_DELEGATION": int32(OP_GET_DIR_DELEGATION),
	"OP_GETDEVICEINFO": int32(OP_GETDEVICEINFO),
	"OP_GETDEVICELIST": int32(OP_GETDEVICELIST),
	"OP_LAYOUTCOMMIT": int32(OP_LAYOUTCOMMIT),
	"OP_LAYOUTGET": int32(OP_LAYOUTGET),
	"OP_LAYOUTRETURN": int32(OP_LAYOUTRETURN),
	"OP_SECINFO_NO_NAME": int32(OP_SECINFO_NO_NAME),
	"OP_SEQUENCE": int32(OP_SEQUENCE),
	"OP_SET_SSV": int32(OP_SET_SSV),
	"OP_TEST_STATEID": int32(OP_TEST_STATEID),
	"OP_WANT_DELEGATION": int32(OP_WANT_DELEGATION),
	"OP_DESTROY_CLIENTID": int32(OP_DESTROY_CLIENTID),
	"OP_RECLAIM_COMPLETE": int32(OP_RECLAIM_COMPLETE),
	"OP_ILLEGAL": int32(OP_ILLEGAL),
}
func (Nfs_opnum4) XdrEnumNames() map[int32]string {
	return _XdrNames_Nfs_opnum4
}
func (v Nfs_opnum4) String() string {
	if s, ok := _XdrNames_Nfs_opnum4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Nfs_opnum4#%d", v)
}
func (v *Nfs_opnum4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Nfs_opnum4[stok]; ok {
			*v = Nfs_opnum4(val)
			return nil
		} else if stok == "Nfs_opnum4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Nfs_opnum4.", stok))
	}
}
func (v Nfs_opnum4) GetU32() uint32 { return uint32(v) }
func (v *Nfs_opnum4) SetU32(n uint32) { *v = Nfs_opnum4(n) }
func (v *Nfs_opnum4) XdrPointer() interface{} { return v }
func (Nfs_opnum4) XdrTypeName() string { return "Nfs_opnum4" }
func (v Nfs_opnum4) XdrValue() interface{} { return v }
func (v *Nfs_opnum4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Nfs_opnum4 = *Nfs_opnum4
func XDR_Nfs_opnum4(v *Nfs_opnum4) *Nfs_opnum4 { return v }
func (v *Nfs_opnum4) XdrInitialize() {
	switch Nfs_opnum4(0) {
	case OP_ACCESS, OP_CLOSE, OP_COMMIT, OP_CREATE, OP_DELEGPURGE, OP_DELEGRETURN, OP_GETATTR, OP_GETFH, OP_LINK, OP_LOCK, OP_LOCKT, OP_LOCKU, OP_LOOKUP, OP_LOOKUPP, OP_NVERIFY, OP_OPEN, OP_OPENATTR, OP_OPEN_CONFIRM, OP_OPEN_DOWNGRADE, OP_PUTFH, OP_PUTPUBFH, OP_PUTROOTFH, OP_READ, OP_READDIR, OP_READLINK, OP_REMOVE, OP_RENAME, OP_RENEW, OP_RESTOREFH, OP_SAVEFH, OP_SECINFO, OP_SETATTR, OP_SETCLIENTID, OP_SETCLIENTID_CONFIRM, OP_VERIFY, OP_WRITE, OP_RELEASE_LOCKOWNER, OP_CREATE_SESSION, OP_DESTROY_SESSION, OP_FREE_STATEID, OP_GET_DIR_DELEGATION, OP_GETDEVICEINFO, OP_GETDEVICELIST, OP_LAYOUTCOMMIT, OP_LAYOUTGET, OP_LAYOUTRETURN, OP_SECINFO_NO_NAME, OP_SEQUENCE, OP_SET_SSV, OP_TEST_STATEID, OP_WANT_DELEGATION, OP_DESTROY_CLIENTID, OP_RECLAIM_COMPLETE, OP_ILLEGAL:
	default:
		if *v == Nfs_opnum4(0) { *v = OP_ACCESS }
	}
}
var _XdrTags_Nfs_argop4 = map[int32]bool{
	XdrToI32(OP_ACCESS): true,
	XdrToI32(OP_CLOSE): true,
	XdrToI32(OP_COMMIT): true,
	XdrToI32(OP_CREATE): true,
	XdrToI32(OP_DELEGPURGE): true,
	XdrToI32(OP_DELEGRETURN): true,
	XdrToI32(OP_GETATTR): true,
	XdrToI32(OP_GETFH): true,
	XdrToI32(OP_LINK): true,
	XdrToI32(OP_LOCK): true,
	XdrToI32(OP_LOCKT): true,
	XdrToI32(OP_LOCKU): true,
	XdrToI32(OP_LOOKUP): true,
	XdrToI32(OP_LOOKUPP): true,
	XdrToI32(OP_NVERIFY): true,
	XdrToI32(OP_OPEN): true,
	XdrToI32(OP_OPENATTR): true,
	XdrToI32(OP_OPEN_CONFIRM): true,
	XdrToI32(OP_OPEN_DOWNGRADE): true,
	XdrToI32(OP_PUTFH): true,
	XdrToI32(OP_PUTPUBFH): true,
	XdrToI32(OP_PUTROOTFH): true,
	XdrToI32(OP_READ): true,
	XdrToI32(OP_READDIR): true,
	XdrToI32(OP_READLINK): true,
	XdrToI32(OP_REMOVE): true,
	XdrToI32(OP_RENAME): true,
	XdrToI32(OP_RENEW): true,
	XdrToI32(OP_RESTOREFH): true,
	XdrToI32(OP_SAVEFH): true,
	XdrToI32(OP_SECINFO): true,
	XdrToI32(OP_SETATTR): true,
	XdrToI32(OP_SETCLIENTID): true,
	XdrToI32(OP_SETCLIENTID_CONFIRM): true,
	XdrToI32(OP_VERIFY): true,
	XdrToI32(OP_WRITE): true,
	XdrToI32(OP_RELEASE_LOCKOWNER): true,
	XdrToI32(OP_CREATE_SESSION): true,
	XdrToI32(OP_DESTROY_SESSION): true,
	XdrToI32(OP_FREE_STATEID): true,
	XdrToI32(OP_GET_DIR_DELEGATION): true,
	XdrToI32(OP_GETDEVICEINFO): true,
	XdrToI32(OP_GETDEVICELIST): true,
	XdrToI32(OP_LAYOUTCOMMIT): true,
	XdrToI32(OP_LAYOUTGET): true,
	XdrToI32(OP_LAYOUTRETURN): true,
	XdrToI32(OP_SECINFO_NO_NAME): true,
	XdrToI32(OP_SEQUENCE): true,
	XdrToI32(OP_SET_SSV): true,
	XdrToI32(OP_TEST_STATEID): true,
	XdrToI32(OP_WANT_DELEGATION): true,
	XdrToI32(OP_DESTROY_CLIENTID): true,
	XdrToI32(OP_RECLAIM_COMPLETE): true,
	XdrToI32(OP_ILLEGAL): true,
}
func (_ Nfs_argop4) XdrValidTags() map[int32]bool {
	return _XdrTags_Nfs_argop4
}
func (u *Nfs_argop4) Opaccess() *ACCESS4args {
	switch u.Argop {
	case OP_ACCESS:
		if v, ok := u.U.(*ACCESS4args); ok {
			return v
		} else {
			var zero ACCESS4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opaccess accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opclose() *CLOSE4args {
	switch u.Argop {
	case OP_CLOSE:
		if v, ok := u.U.(*CLOSE4args); ok {
			return v
		} else {
			var zero CLOSE4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opclose accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opcommit() *COMMIT4args {
	switch u.Argop {
	case OP_COMMIT:
		if v, ok := u.U.(*COMMIT4args); ok {
			return v
		} else {
			var zero COMMIT4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opcommit accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opcreate() *CREATE4args {
	switch u.Argop {
	case OP_CREATE:
		if v, ok := u.U.(*CREATE4args); ok {
			return v
		} else {
			var zero CREATE4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opcreate accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opdelegpurge() *DELEGPURGE4args {
	switch u.Argop {
	case OP_DELEGPURGE:
		if v, ok := u.U.(*DELEGPURGE4args); ok {
			return v
		} else {
			var zero DELEGPURGE4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opdelegpurge accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opdelegreturn() *DELEGRETURN4args {
	switch u.Argop {
	case OP_DELEGRETURN:
		if v, ok := u.U.(*DELEGRETURN4args); ok {
			return v
		} else {
			var zero DELEGRETURN4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opdelegreturn accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opgetattr() *GETATTR4args {
	switch u.Argop {
	case OP_GETATTR:
		if v, ok := u.U.(*GETATTR4args); ok {
			return v
		} else {
			var zero GETATTR4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opgetattr accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Oplink() *LINK4args {
	switch u.Argop {
	case OP_LINK:
		if v, ok := u.U.(*LINK4args); ok {
			return v
		} else {
			var zero LINK4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Oplink accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Oplock() *LOCK4args {
	switch u.Argop {
	case OP_LOCK:
		if v, ok := u.U.(*LOCK4args); ok {
			return v
		} else {
			var zero LOCK4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Oplock accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Oplockt() *LOCKT4args {
	switch u.Argop {
	case OP_LOCKT:
		if v, ok := u.U.(*LOCKT4args); ok {
			return v
		} else {
			var zero LOCKT4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Oplockt accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Oplocku() *LOCKU4args {
	switch u.Argop {
	case OP_LOCKU:
		if v, ok := u.U.(*LOCKU4args); ok {
			return v
		} else {
			var zero LOCKU4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Oplocku accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Oplookup() *LOOKUP4args {
	switch u.Argop {
	case OP_LOOKUP:
		if v, ok := u.U.(*LOOKUP4args); ok {
			return v
		} else {
			var zero LOOKUP4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Oplookup accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opnverify() *NVERIFY4args {
	switch u.Argop {
	case OP_NVERIFY:
		if v, ok := u.U.(*NVERIFY4args); ok {
			return v
		} else {
			var zero NVERIFY4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opnverify accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opopen() *OPEN4args {
	switch u.Argop {
	case OP_OPEN:
		if v, ok := u.U.(*OPEN4args); ok {
			return v
		} else {
			var zero OPEN4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opopen accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opopenattr() *OPENATTR4args {
	switch u.Argop {
	case OP_OPENATTR:
		if v, ok := u.U.(*OPENATTR4args); ok {
			return v
		} else {
			var zero OPENATTR4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opopenattr accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opopen_confirm() *OPEN_CONFIRM4args {
	switch u.Argop {
	case OP_OPEN_CONFIRM:
		if v, ok := u.U.(*OPEN_CONFIRM4args); ok {
			return v
		} else {
			var zero OPEN_CONFIRM4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opopen_confirm accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opopen_downgrade() *OPEN_DOWNGRADE4args {
	switch u.Argop {
	case OP_OPEN_DOWNGRADE:
		if v, ok := u.U.(*OPEN_DOWNGRADE4args); ok {
			return v
		} else {
			var zero OPEN_DOWNGRADE4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opopen_downgrade accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opputfh() *PUTFH4args {
	switch u.Argop {
	case OP_PUTFH:
		if v, ok := u.U.(*PUTFH4args); ok {
			return v
		} else {
			var zero PUTFH4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opputfh accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opread() *READ4args {
	switch u.Argop {
	case OP_READ:
		if v, ok := u.U.(*READ4args); ok {
			return v
		} else {
			var zero READ4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opread accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opreaddir() *READDIR4args {
	switch u.Argop {
	case OP_READDIR:
		if v, ok := u.U.(*READDIR4args); ok {
			return v
		} else {
			var zero READDIR4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opreaddir accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opremove() *REMOVE4args {
	switch u.Argop {
	case OP_REMOVE:
		if v, ok := u.U.(*REMOVE4args); ok {
			return v
		} else {
			var zero REMOVE4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opremove accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Oprename() *RENAME4args {
	switch u.Argop {
	case OP_RENAME:
		if v, ok := u.U.(*RENAME4args); ok {
			return v
		} else {
			var zero RENAME4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Oprename accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Oprenew() *RENEW4args {
	switch u.Argop {
	case OP_RENEW:
		if v, ok := u.U.(*RENEW4args); ok {
			return v
		} else {
			var zero RENEW4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Oprenew accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opsecinfo() *SECINFO4args {
	switch u.Argop {
	case OP_SECINFO:
		if v, ok := u.U.(*SECINFO4args); ok {
			return v
		} else {
			var zero SECINFO4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opsecinfo accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opsetattr() *SETATTR4args {
	switch u.Argop {
	case OP_SETATTR:
		if v, ok := u.U.(*SETATTR4args); ok {
			return v
		} else {
			var zero SETATTR4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opsetattr accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opsetclientid() *SETCLIENTID4args {
	switch u.Argop {
	case OP_SETCLIENTID:
		if v, ok := u.U.(*SETCLIENTID4args); ok {
			return v
		} else {
			var zero SETCLIENTID4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opsetclientid accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opsetclientid_confirm() *SETCLIENTID_CONFIRM4args {
	switch u.Argop {
	case OP_SETCLIENTID_CONFIRM:
		if v, ok := u.U.(*SETCLIENTID_CONFIRM4args); ok {
			return v
		} else {
			var zero SETCLIENTID_CONFIRM4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opsetclientid_confirm accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opverify() *VERIFY4args {
	switch u.Argop {
	case OP_VERIFY:
		if v, ok := u.U.(*VERIFY4args); ok {
			return v
		} else {
			var zero VERIFY4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opverify accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opwrite() *WRITE4args {
	switch u.Argop {
	case OP_WRITE:
		if v, ok := u.U.(*WRITE4args); ok {
			return v
		} else {
			var zero WRITE4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opwrite accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Oprelease_lockowner() *RELEASE_LOCKOWNER4args {
	switch u.Argop {
	case OP_RELEASE_LOCKOWNER:
		if v, ok := u.U.(*RELEASE_LOCKOWNER4args); ok {
			return v
		} else {
			var zero RELEASE_LOCKOWNER4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Oprelease_lockowner accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opcreatesession() *CREATE_SESSION4args {
	switch u.Argop {
	case OP_CREATE_SESSION:
		if v, ok := u.U.(*CREATE_SESSION4args); ok {
			return v
		} else {
			var zero CREATE_SESSION4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opcreatesession accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opdestroysession() *DESTROY_SESSION4args {
	switch u.Argop {
	case OP_DESTROY_SESSION:
		if v, ok := u.U.(*DESTROY_SESSION4args); ok {
			return v
		} else {
			var zero DESTROY_SESSION4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opdestroysession accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opfreestateid() *FREE_STATEID4args {
	switch u.Argop {
	case OP_FREE_STATEID:
		if v, ok := u.U.(*FREE_STATEID4args); ok {
			return v
		} else {
			var zero FREE_STATEID4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opfreestateid accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opgetdirdelegation() *GET_DIR_DELEGATION4args {
	switch u.Argop {
	case OP_GET_DIR_DELEGATION:
		if v, ok := u.U.(*GET_DIR_DELEGATION4args); ok {
			return v
		} else {
			var zero GET_DIR_DELEGATION4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opgetdirdelegation accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opgetdeviceinfo() *GETDEVICEINFO4args {
	switch u.Argop {
	case OP_GETDEVICEINFO:
		if v, ok := u.U.(*GETDEVICEINFO4args); ok {
			return v
		} else {
			var zero GETDEVICEINFO4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opgetdeviceinfo accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opgetdevicelist() *GETDEVICELIST4args {
	switch u.Argop {
	case OP_GETDEVICELIST:
		if v, ok := u.U.(*GETDEVICELIST4args); ok {
			return v
		} else {
			var zero GETDEVICELIST4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opgetdevicelist accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Oplayoutcommit() *LAYOUTCOMMIT4args {
	switch u.Argop {
	case OP_LAYOUTCOMMIT:
		if v, ok := u.U.(*LAYOUTCOMMIT4args); ok {
			return v
		} else {
			var zero LAYOUTCOMMIT4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Oplayoutcommit accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Oplayoutget() *LAYOUTGET4args {
	switch u.Argop {
	case OP_LAYOUTGET:
		if v, ok := u.U.(*LAYOUTGET4args); ok {
			return v
		} else {
			var zero LAYOUTGET4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Oplayoutget accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Oplayoutreturn() *LAYOUTRETURN4args {
	switch u.Argop {
	case OP_LAYOUTRETURN:
		if v, ok := u.U.(*LAYOUTRETURN4args); ok {
			return v
		} else {
			var zero LAYOUTRETURN4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Oplayoutreturn accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opsecinfononame() *SECINFO_NO_NAME4args {
	switch u.Argop {
	case OP_SECINFO_NO_NAME:
		if v, ok := u.U.(*SECINFO_NO_NAME4args); ok {
			return v
		} else {
			var zero SECINFO_NO_NAME4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opsecinfononame accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opsequence() *SEQUENCE4args {
	switch u.Argop {
	case OP_SEQUENCE:
		if v, ok := u.U.(*SEQUENCE4args); ok {
			return v
		} else {
			var zero SEQUENCE4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opsequence accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opsetssv() *SET_SSV4args {
	switch u.Argop {
	case OP_SET_SSV:
		if v, ok := u.U.(*SET_SSV4args); ok {
			return v
		} else {
			var zero SET_SSV4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opsetssv accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opteststateid() *TEST_STATEID4args {
	switch u.Argop {
	case OP_TEST_STATEID:
		if v, ok := u.U.(*TEST_STATEID4args); ok {
			return v
		} else {
			var zero TEST_STATEID4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opteststateid accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opwantdelegation() *WANT_DELEGATION4args {
	switch u.Argop {
	case OP_WANT_DELEGATION:
		if v, ok := u.U.(*WANT_DELEGATION4args); ok {
			return v
		} else {
			var zero WANT_DELEGATION4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opwantdelegation accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opdestroyclientid() *DESTROY_CLIENTID4args {
	switch u.Argop {
	case OP_DESTROY_CLIENTID:
		if v, ok := u.U.(*DESTROY_CLIENTID4args); ok {
			return v
		} else {
			var zero DESTROY_CLIENTID4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opdestroyclientid accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_argop4) Opreclaimcomplete() *RECLAIM_COMPLETE4args {
	switch u.Argop {
	case OP_RECLAIM_COMPLETE:
		if v, ok := u.U.(*RECLAIM_COMPLETE4args); ok {
			return v
		} else {
			var zero RECLAIM_COMPLETE4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_argop4.Opreclaimcomplete accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u Nfs_argop4) XdrValid() bool {
	switch u.Argop {
	case OP_ACCESS,OP_CLOSE,OP_COMMIT,OP_CREATE,OP_DELEGPURGE,OP_DELEGRETURN,OP_GETATTR,OP_GETFH,OP_LINK,OP_LOCK,OP_LOCKT,OP_LOCKU,OP_LOOKUP,OP_LOOKUPP,OP_NVERIFY,OP_OPEN,OP_OPENATTR,OP_OPEN_CONFIRM,OP_OPEN_DOWNGRADE,OP_PUTFH,OP_PUTPUBFH,OP_PUTROOTFH,OP_READ,OP_READDIR,OP_READLINK,OP_REMOVE,OP_RENAME,OP_RENEW,OP_RESTOREFH,OP_SAVEFH,OP_SECINFO,OP_SETATTR,OP_SETCLIENTID,OP_SETCLIENTID_CONFIRM,OP_VERIFY,OP_WRITE,OP_RELEASE_LOCKOWNER,OP_CREATE_SESSION,OP_DESTROY_SESSION,OP_FREE_STATEID,OP_GET_DIR_DELEGATION,OP_GETDEVICEINFO,OP_GETDEVICELIST,OP_LAYOUTCOMMIT,OP_LAYOUTGET,OP_LAYOUTRETURN,OP_SECINFO_NO_NAME,OP_SEQUENCE,OP_SET_SSV,OP_TEST_STATEID,OP_WANT_DELEGATION,OP_DESTROY_CLIENTID,OP_RECLAIM_COMPLETE,OP_ILLEGAL:
		return true
	}
	return false
}
func (u *Nfs_argop4) XdrUnionTag() XdrNum32 {
	return XDR_Nfs_opnum4(&u.Argop)
}
func (u *Nfs_argop4) XdrUnionTagName() string {
	return "Argop"
}
func (u *Nfs_argop4) XdrUnionBody() XdrType {
	switch u.Argop {
	case OP_ACCESS:
		return XDR_ACCESS4args(u.Opaccess())
	case OP_CLOSE:
		return XDR_CLOSE4args(u.Opclose())
	case OP_COMMIT:
		return XDR_COMMIT4args(u.Opcommit())
	case OP_CREATE:
		return XDR_CREATE4args(u.Opcreate())
	case OP_DELEGPURGE:
		return XDR_DELEGPURGE4args(u.Opdelegpurge())
	case OP_DELEGRETURN:
		return XDR_DELEGRETURN4args(u.Opdelegreturn())
	case OP_GETATTR:
		return XDR_GETATTR4args(u.Opgetattr())
	case OP_GETFH:
		return nil
	case OP_LINK:
		return XDR_LINK4args(u.Oplink())
	case OP_LOCK:
		return XDR_LOCK4args(u.Oplock())
	case OP_LOCKT:
		return XDR_LOCKT4args(u.Oplockt())
	case OP_LOCKU:
		return XDR_LOCKU4args(u.Oplocku())
	case OP_LOOKUP:
		return XDR_LOOKUP4args(u.Oplookup())
	case OP_LOOKUPP:
		return nil
	case OP_NVERIFY:
		return XDR_NVERIFY4args(u.Opnverify())
	case OP_OPEN:
		return XDR_OPEN4args(u.Opopen())
	case OP_OPENATTR:
		return XDR_OPENATTR4args(u.Opopenattr())
	case OP_OPEN_CONFIRM:
		return XDR_OPEN_CONFIRM4args(u.Opopen_confirm())
	case OP_OPEN_DOWNGRADE:
		return XDR_OPEN_DOWNGRADE4args(u.Opopen_downgrade())
	case OP_PUTFH:
		return XDR_PUTFH4args(u.Opputfh())
	case OP_PUTPUBFH:
		return nil
	case OP_PUTROOTFH:
		return nil
	case OP_READ:
		return XDR_READ4args(u.Opread())
	case OP_READDIR:
		return XDR_READDIR4args(u.Opreaddir())
	case OP_READLINK:
		return nil
	case OP_REMOVE:
		return XDR_REMOVE4args(u.Opremove())
	case OP_RENAME:
		return XDR_RENAME4args(u.Oprename())
	case OP_RENEW:
		return XDR_RENEW4args(u.Oprenew())
	case OP_RESTOREFH:
		return nil
	case OP_SAVEFH:
		return nil
	case OP_SECINFO:
		return XDR_SECINFO4args(u.Opsecinfo())
	case OP_SETATTR:
		return XDR_SETATTR4args(u.Opsetattr())
	case OP_SETCLIENTID:
		return XDR_SETCLIENTID4args(u.Opsetclientid())
	case OP_SETCLIENTID_CONFIRM:
		return XDR_SETCLIENTID_CONFIRM4args(u.Opsetclientid_confirm())
	case OP_VERIFY:
		return XDR_VERIFY4args(u.Opverify())
	case OP_WRITE:
		return XDR_WRITE4args(u.Opwrite())
	case OP_RELEASE_LOCKOWNER:
		return XDR_RELEASE_LOCKOWNER4args(u.Oprelease_lockowner())
	case OP_CREATE_SESSION:
		return XDR_CREATE_SESSION4args(u.Opcreatesession())
	case OP_DESTROY_SESSION:
		return XDR_DESTROY_SESSION4args(u.Opdestroysession())
	case OP_FREE_STATEID:
		return XDR_FREE_STATEID4args(u.Opfreestateid())
	case OP_GET_DIR_DELEGATION:
		return XDR_GET_DIR_DELEGATION4args(u.Opgetdirdelegation())
	case OP_GETDEVICEINFO:
		return XDR_GETDEVICEINFO4args(u.Opgetdeviceinfo())
	case OP_GETDEVICELIST:
		return XDR_GETDEVICELIST4args(u.Opgetdevicelist())
	case OP_LAYOUTCOMMIT:
		return XDR_LAYOUTCOMMIT4args(u.Oplayoutcommit())
	case OP_LAYOUTGET:
		return XDR_LAYOUTGET4args(u.Oplayoutget())
	case OP_LAYOUTRETURN:
		return XDR_LAYOUTRETURN4args(u.Oplayoutreturn())
	case OP_SECINFO_NO_NAME:
		return XDR_SECINFO_NO_NAME4args(u.Opsecinfononame())
	case OP_SEQUENCE:
		return XDR_SEQUENCE4args(u.Opsequence())
	case OP_SET_SSV:
		return XDR_SET_SSV4args(u.Opsetssv())
	case OP_TEST_STATEID:
		return XDR_TEST_STATEID4args(u.Opteststateid())
	case OP_WANT_DELEGATION:
		return XDR_WANT_DELEGATION4args(u.Opwantdelegation())
	case OP_DESTROY_CLIENTID:
		return XDR_DESTROY_CLIENTID4args(u.Opdestroyclientid())
	case OP_RECLAIM_COMPLETE:
		return XDR_RECLAIM_COMPLETE4args(u.Opreclaimcomplete())
	case OP_ILLEGAL:
		return nil
	}
	return nil
}
func (u *Nfs_argop4) XdrUnionBodyName() string {
	switch u.Argop {
	case OP_ACCESS:
		return "Opaccess"
	case OP_CLOSE:
		return "Opclose"
	case OP_COMMIT:
		return "Opcommit"
	case OP_CREATE:
		return "Opcreate"
	case OP_DELEGPURGE:
		return "Opdelegpurge"
	case OP_DELEGRETURN:
		return "Opdelegreturn"
	case OP_GETATTR:
		return "Opgetattr"
	case OP_GETFH:
		return ""
	case OP_LINK:
		return "Oplink"
	case OP_LOCK:
		return "Oplock"
	case OP_LOCKT:
		return "Oplockt"
	case OP_LOCKU:
		return "Oplocku"
	case OP_LOOKUP:
		return "Oplookup"
	case OP_LOOKUPP:
		return ""
	case OP_NVERIFY:
		return "Opnverify"
	case OP_OPEN:
		return "Opopen"
	case OP_OPENATTR:
		return "Opopenattr"
	case OP_OPEN_CONFIRM:
		return "Opopen_confirm"
	case OP_OPEN_DOWNGRADE:
		return "Opopen_downgrade"
	case OP_PUTFH:
		return "Opputfh"
	case OP_PUTPUBFH:
		return ""
	case OP_PUTROOTFH:
		return ""
	case OP_READ:
		return "Opread"
	case OP_READDIR:
		return "Opreaddir"
	case OP_READLINK:
		return ""
	case OP_REMOVE:
		return "Opremove"
	case OP_RENAME:
		return "Oprename"
	case OP_RENEW:
		return "Oprenew"
	case OP_RESTOREFH:
		return ""
	case OP_SAVEFH:
		return ""
	case OP_SECINFO:
		return "Opsecinfo"
	case OP_SETATTR:
		return "Opsetattr"
	case OP_SETCLIENTID:
		return "Opsetclientid"
	case OP_SETCLIENTID_CONFIRM:
		return "Opsetclientid_confirm"
	case OP_VERIFY:
		return "Opverify"
	case OP_WRITE:
		return "Opwrite"
	case OP_RELEASE_LOCKOWNER:
		return "Oprelease_lockowner"
	case OP_CREATE_SESSION:
		return "Opcreatesession"
	case OP_DESTROY_SESSION:
		return "Opdestroysession"
	case OP_FREE_STATEID:
		return "Opfreestateid"
	case OP_GET_DIR_DELEGATION:
		return "Opgetdirdelegation"
	case OP_GETDEVICEINFO:
		return "Opgetdeviceinfo"
	case OP_GETDEVICELIST:
		return "Opgetdevicelist"
	case OP_LAYOUTCOMMIT:
		return "Oplayoutcommit"
	case OP_LAYOUTGET:
		return "Oplayoutget"
	case OP_LAYOUTRETURN:
		return "Oplayoutreturn"
	case OP_SECINFO_NO_NAME:
		return "Opsecinfononame"
	case OP_SEQUENCE:
		return "Opsequence"
	case OP_SET_SSV:
		return "Opsetssv"
	case OP_TEST_STATEID:
		return "Opteststateid"
	case OP_WANT_DELEGATION:
		return "Opwantdelegation"
	case OP_DESTROY_CLIENTID:
		return "Opdestroyclientid"
	case OP_RECLAIM_COMPLETE:
		return "Opreclaimcomplete"
	case OP_ILLEGAL:
		return ""
	}
	return ""
}
type XdrType_Nfs_argop4 = *Nfs_argop4
func (v *Nfs_argop4) XdrPointer() interface{} { return v }
func (Nfs_argop4) XdrTypeName() string { return "Nfs_argop4" }
func (v Nfs_argop4) XdrValue() interface{} { return v }
func (v *Nfs_argop4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Nfs_argop4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfs_opnum4(&u.Argop).XdrMarshal(x, x.Sprintf("%sargop", name))
	switch u.Argop {
	case OP_ACCESS:
		x.Marshal(x.Sprintf("%sopaccess", name), XDR_ACCESS4args(u.Opaccess()))
		return
	case OP_CLOSE:
		x.Marshal(x.Sprintf("%sopclose", name), XDR_CLOSE4args(u.Opclose()))
		return
	case OP_COMMIT:
		x.Marshal(x.Sprintf("%sopcommit", name), XDR_COMMIT4args(u.Opcommit()))
		return
	case OP_CREATE:
		x.Marshal(x.Sprintf("%sopcreate", name), XDR_CREATE4args(u.Opcreate()))
		return
	case OP_DELEGPURGE:
		x.Marshal(x.Sprintf("%sopdelegpurge", name), XDR_DELEGPURGE4args(u.Opdelegpurge()))
		return
	case OP_DELEGRETURN:
		x.Marshal(x.Sprintf("%sopdelegreturn", name), XDR_DELEGRETURN4args(u.Opdelegreturn()))
		return
	case OP_GETATTR:
		x.Marshal(x.Sprintf("%sopgetattr", name), XDR_GETATTR4args(u.Opgetattr()))
		return
	case OP_GETFH:
		return
	case OP_LINK:
		x.Marshal(x.Sprintf("%soplink", name), XDR_LINK4args(u.Oplink()))
		return
	case OP_LOCK:
		x.Marshal(x.Sprintf("%soplock", name), XDR_LOCK4args(u.Oplock()))
		return
	case OP_LOCKT:
		x.Marshal(x.Sprintf("%soplockt", name), XDR_LOCKT4args(u.Oplockt()))
		return
	case OP_LOCKU:
		x.Marshal(x.Sprintf("%soplocku", name), XDR_LOCKU4args(u.Oplocku()))
		return
	case OP_LOOKUP:
		x.Marshal(x.Sprintf("%soplookup", name), XDR_LOOKUP4args(u.Oplookup()))
		return
	case OP_LOOKUPP:
		return
	case OP_NVERIFY:
		x.Marshal(x.Sprintf("%sopnverify", name), XDR_NVERIFY4args(u.Opnverify()))
		return
	case OP_OPEN:
		x.Marshal(x.Sprintf("%sopopen", name), XDR_OPEN4args(u.Opopen()))
		return
	case OP_OPENATTR:
		x.Marshal(x.Sprintf("%sopopenattr", name), XDR_OPENATTR4args(u.Opopenattr()))
		return
	case OP_OPEN_CONFIRM:
		x.Marshal(x.Sprintf("%sopopen_confirm", name), XDR_OPEN_CONFIRM4args(u.Opopen_confirm()))
		return
	case OP_OPEN_DOWNGRADE:
		x.Marshal(x.Sprintf("%sopopen_downgrade", name), XDR_OPEN_DOWNGRADE4args(u.Opopen_downgrade()))
		return
	case OP_PUTFH:
		x.Marshal(x.Sprintf("%sopputfh", name), XDR_PUTFH4args(u.Opputfh()))
		return
	case OP_PUTPUBFH:
		return
	case OP_PUTROOTFH:
		return
	case OP_READ:
		x.Marshal(x.Sprintf("%sopread", name), XDR_READ4args(u.Opread()))
		return
	case OP_READDIR:
		x.Marshal(x.Sprintf("%sopreaddir", name), XDR_READDIR4args(u.Opreaddir()))
		return
	case OP_READLINK:
		return
	case OP_REMOVE:
		x.Marshal(x.Sprintf("%sopremove", name), XDR_REMOVE4args(u.Opremove()))
		return
	case OP_RENAME:
		x.Marshal(x.Sprintf("%soprename", name), XDR_RENAME4args(u.Oprename()))
		return
	case OP_RENEW:
		x.Marshal(x.Sprintf("%soprenew", name), XDR_RENEW4args(u.Oprenew()))
		return
	case OP_RESTOREFH:
		return
	case OP_SAVEFH:
		return
	case OP_SECINFO:
		x.Marshal(x.Sprintf("%sopsecinfo", name), XDR_SECINFO4args(u.Opsecinfo()))
		return
	case OP_SETATTR:
		x.Marshal(x.Sprintf("%sopsetattr", name), XDR_SETATTR4args(u.Opsetattr()))
		return
	case OP_SETCLIENTID:
		x.Marshal(x.Sprintf("%sopsetclientid", name), XDR_SETCLIENTID4args(u.Opsetclientid()))
		return
	case OP_SETCLIENTID_CONFIRM:
		x.Marshal(x.Sprintf("%sopsetclientid_confirm", name), XDR_SETCLIENTID_CONFIRM4args(u.Opsetclientid_confirm()))
		return
	case OP_VERIFY:
		x.Marshal(x.Sprintf("%sopverify", name), XDR_VERIFY4args(u.Opverify()))
		return
	case OP_WRITE:
		x.Marshal(x.Sprintf("%sopwrite", name), XDR_WRITE4args(u.Opwrite()))
		return
	case OP_RELEASE_LOCKOWNER:
		x.Marshal(x.Sprintf("%soprelease_lockowner", name), XDR_RELEASE_LOCKOWNER4args(u.Oprelease_lockowner()))
		return
	case OP_CREATE_SESSION:
		x.Marshal(x.Sprintf("%sopcreatesession", name), XDR_CREATE_SESSION4args(u.Opcreatesession()))
		return
	case OP_DESTROY_SESSION:
		x.Marshal(x.Sprintf("%sopdestroysession", name), XDR_DESTROY_SESSION4args(u.Opdestroysession()))
		return
	case OP_FREE_STATEID:
		x.Marshal(x.Sprintf("%sopfreestateid", name), XDR_FREE_STATEID4args(u.Opfreestateid()))
		return
	case OP_GET_DIR_DELEGATION:
		x.Marshal(x.Sprintf("%sopgetdirdelegation", name), XDR_GET_DIR_DELEGATION4args(u.Opgetdirdelegation()))
		return
	case OP_GETDEVICEINFO:
		x.Marshal(x.Sprintf("%sopgetdeviceinfo", name), XDR_GETDEVICEINFO4args(u.Opgetdeviceinfo()))
		return
	case OP_GETDEVICELIST:
		x.Marshal(x.Sprintf("%sopgetdevicelist", name), XDR_GETDEVICELIST4args(u.Opgetdevicelist()))
		return
	case OP_LAYOUTCOMMIT:
		x.Marshal(x.Sprintf("%soplayoutcommit", name), XDR_LAYOUTCOMMIT4args(u.Oplayoutcommit()))
		return
	case OP_LAYOUTGET:
		x.Marshal(x.Sprintf("%soplayoutget", name), XDR_LAYOUTGET4args(u.Oplayoutget()))
		return
	case OP_LAYOUTRETURN:
		x.Marshal(x.Sprintf("%soplayoutreturn", name), XDR_LAYOUTRETURN4args(u.Oplayoutreturn()))
		return
	case OP_SECINFO_NO_NAME:
		x.Marshal(x.Sprintf("%sopsecinfononame", name), XDR_SECINFO_NO_NAME4args(u.Opsecinfononame()))
		return
	case OP_SEQUENCE:
		x.Marshal(x.Sprintf("%sopsequence", name), XDR_SEQUENCE4args(u.Opsequence()))
		return
	case OP_SET_SSV:
		x.Marshal(x.Sprintf("%sopsetssv", name), XDR_SET_SSV4args(u.Opsetssv()))
		return
	case OP_TEST_STATEID:
		x.Marshal(x.Sprintf("%sopteststateid", name), XDR_TEST_STATEID4args(u.Opteststateid()))
		return
	case OP_WANT_DELEGATION:
		x.Marshal(x.Sprintf("%sopwantdelegation", name), XDR_WANT_DELEGATION4args(u.Opwantdelegation()))
		return
	case OP_DESTROY_CLIENTID:
		x.Marshal(x.Sprintf("%sopdestroyclientid", name), XDR_DESTROY_CLIENTID4args(u.Opdestroyclientid()))
		return
	case OP_RECLAIM_COMPLETE:
		x.Marshal(x.Sprintf("%sopreclaimcomplete", name), XDR_RECLAIM_COMPLETE4args(u.Opreclaimcomplete()))
		return
	case OP_ILLEGAL:
		return
	}
	XdrPanic("invalid Argop (%v) in Nfs_argop4", u.Argop)
}
func (v *Nfs_argop4) XdrInitialize() {
	var zero Nfs_opnum4
	switch zero {
	case OP_ACCESS, OP_CLOSE, OP_COMMIT, OP_CREATE, OP_DELEGPURGE, OP_DELEGRETURN, OP_GETATTR, OP_GETFH, OP_LINK, OP_LOCK, OP_LOCKT, OP_LOCKU, OP_LOOKUP, OP_LOOKUPP, OP_NVERIFY, OP_OPEN, OP_OPENATTR, OP_OPEN_CONFIRM, OP_OPEN_DOWNGRADE, OP_PUTFH, OP_PUTPUBFH, OP_PUTROOTFH, OP_READ, OP_READDIR, OP_READLINK, OP_REMOVE, OP_RENAME, OP_RENEW, OP_RESTOREFH, OP_SAVEFH, OP_SECINFO, OP_SETATTR, OP_SETCLIENTID, OP_SETCLIENTID_CONFIRM, OP_VERIFY, OP_WRITE, OP_RELEASE_LOCKOWNER, OP_CREATE_SESSION, OP_DESTROY_SESSION, OP_FREE_STATEID, OP_GET_DIR_DELEGATION, OP_GETDEVICEINFO, OP_GETDEVICELIST, OP_LAYOUTCOMMIT, OP_LAYOUTGET, OP_LAYOUTRETURN, OP_SECINFO_NO_NAME, OP_SEQUENCE, OP_SET_SSV, OP_TEST_STATEID, OP_WANT_DELEGATION, OP_DESTROY_CLIENTID, OP_RECLAIM_COMPLETE, OP_ILLEGAL:
	default:
		if v.Argop == zero { v.Argop = OP_ACCESS }
	}
}
func XDR_Nfs_argop4(v *Nfs_argop4) *Nfs_argop4 { return v}
var _XdrTags_Nfs_resop4 = map[int32]bool{
	XdrToI32(OP_ACCESS): true,
	XdrToI32(OP_CLOSE): true,
	XdrToI32(OP_COMMIT): true,
	XdrToI32(OP_CREATE): true,
	XdrToI32(OP_DELEGPURGE): true,
	XdrToI32(OP_DELEGRETURN): true,
	XdrToI32(OP_GETATTR): true,
	XdrToI32(OP_GETFH): true,
	XdrToI32(OP_LINK): true,
	XdrToI32(OP_LOCK): true,
	XdrToI32(OP_LOCKT): true,
	XdrToI32(OP_LOCKU): true,
	XdrToI32(OP_LOOKUP): true,
	XdrToI32(OP_LOOKUPP): true,
	XdrToI32(OP_NVERIFY): true,
	XdrToI32(OP_OPEN): true,
	XdrToI32(OP_OPENATTR): true,
	XdrToI32(OP_OPEN_CONFIRM): true,
	XdrToI32(OP_OPEN_DOWNGRADE): true,
	XdrToI32(OP_PUTFH): true,
	XdrToI32(OP_PUTPUBFH): true,
	XdrToI32(OP_PUTROOTFH): true,
	XdrToI32(OP_READ): true,
	XdrToI32(OP_READDIR): true,
	XdrToI32(OP_READLINK): true,
	XdrToI32(OP_REMOVE): true,
	XdrToI32(OP_RENAME): true,
	XdrToI32(OP_RENEW): true,
	XdrToI32(OP_RESTOREFH): true,
	XdrToI32(OP_SAVEFH): true,
	XdrToI32(OP_SECINFO): true,
	XdrToI32(OP_SETATTR): true,
	XdrToI32(OP_SETCLIENTID): true,
	XdrToI32(OP_SETCLIENTID_CONFIRM): true,
	XdrToI32(OP_VERIFY): true,
	XdrToI32(OP_WRITE): true,
	XdrToI32(OP_RELEASE_LOCKOWNER): true,
	XdrToI32(OP_CREATE_SESSION): true,
	XdrToI32(OP_DESTROY_SESSION): true,
	XdrToI32(OP_FREE_STATEID): true,
	XdrToI32(OP_GET_DIR_DELEGATION): true,
	XdrToI32(OP_GETDEVICEINFO): true,
	XdrToI32(OP_GETDEVICELIST): true,
	XdrToI32(OP_LAYOUTCOMMIT): true,
	XdrToI32(OP_LAYOUTGET): true,
	XdrToI32(OP_LAYOUTRETURN): true,
	XdrToI32(OP_SECINFO_NO_NAME): true,
	XdrToI32(OP_SEQUENCE): true,
	XdrToI32(OP_SET_SSV): true,
	XdrToI32(OP_TEST_STATEID): true,
	XdrToI32(OP_WANT_DELEGATION): true,
	XdrToI32(OP_DESTROY_CLIENTID): true,
	XdrToI32(OP_RECLAIM_COMPLETE): true,
	XdrToI32(OP_ILLEGAL): true,
}
func (_ Nfs_resop4) XdrValidTags() map[int32]bool {
	return _XdrTags_Nfs_resop4
}
func (u *Nfs_resop4) Opaccess() *ACCESS4res {
	switch u.Resop {
	case OP_ACCESS:
		if v, ok := u.U.(*ACCESS4res); ok {
			return v
		} else {
			var zero ACCESS4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opaccess accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opclose() *CLOSE4res {
	switch u.Resop {
	case OP_CLOSE:
		if v, ok := u.U.(*CLOSE4res); ok {
			return v
		} else {
			var zero CLOSE4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opclose accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opcommit() *COMMIT4res {
	switch u.Resop {
	case OP_COMMIT:
		if v, ok := u.U.(*COMMIT4res); ok {
			return v
		} else {
			var zero COMMIT4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opcommit accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opcreate() *CREATE4res {
	switch u.Resop {
	case OP_CREATE:
		if v, ok := u.U.(*CREATE4res); ok {
			return v
		} else {
			var zero CREATE4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opcreate accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opdelegpurge() *DELEGPURGE4res {
	switch u.Resop {
	case OP_DELEGPURGE:
		if v, ok := u.U.(*DELEGPURGE4res); ok {
			return v
		} else {
			var zero DELEGPURGE4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opdelegpurge accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opdelegreturn() *DELEGRETURN4res {
	switch u.Resop {
	case OP_DELEGRETURN:
		if v, ok := u.U.(*DELEGRETURN4res); ok {
			return v
		} else {
			var zero DELEGRETURN4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opdelegreturn accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opgetattr() *GETATTR4res {
	switch u.Resop {
	case OP_GETATTR:
		if v, ok := u.U.(*GETATTR4res); ok {
			return v
		} else {
			var zero GETATTR4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opgetattr accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opgetfh() *GETFH4res {
	switch u.Resop {
	case OP_GETFH:
		if v, ok := u.U.(*GETFH4res); ok {
			return v
		} else {
			var zero GETFH4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opgetfh accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Oplink() *LINK4res {
	switch u.Resop {
	case OP_LINK:
		if v, ok := u.U.(*LINK4res); ok {
			return v
		} else {
			var zero LINK4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Oplink accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Oplock() *LOCK4res {
	switch u.Resop {
	case OP_LOCK:
		if v, ok := u.U.(*LOCK4res); ok {
			return v
		} else {
			var zero LOCK4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Oplock accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Oplockt() *LOCKT4res {
	switch u.Resop {
	case OP_LOCKT:
		if v, ok := u.U.(*LOCKT4res); ok {
			return v
		} else {
			var zero LOCKT4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Oplockt accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Oplocku() *LOCKU4res {
	switch u.Resop {
	case OP_LOCKU:
		if v, ok := u.U.(*LOCKU4res); ok {
			return v
		} else {
			var zero LOCKU4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Oplocku accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Oplookup() *LOOKUP4res {
	switch u.Resop {
	case OP_LOOKUP:
		if v, ok := u.U.(*LOOKUP4res); ok {
			return v
		} else {
			var zero LOOKUP4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Oplookup accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Oplookupp() *LOOKUPP4res {
	switch u.Resop {
	case OP_LOOKUPP:
		if v, ok := u.U.(*LOOKUPP4res); ok {
			return v
		} else {
			var zero LOOKUPP4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Oplookupp accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opnverify() *NVERIFY4res {
	switch u.Resop {
	case OP_NVERIFY:
		if v, ok := u.U.(*NVERIFY4res); ok {
			return v
		} else {
			var zero NVERIFY4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opnverify accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opopen() *OPEN4res {
	switch u.Resop {
	case OP_OPEN:
		if v, ok := u.U.(*OPEN4res); ok {
			return v
		} else {
			var zero OPEN4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opopen accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opopenattr() *OPENATTR4res {
	switch u.Resop {
	case OP_OPENATTR:
		if v, ok := u.U.(*OPENATTR4res); ok {
			return v
		} else {
			var zero OPENATTR4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opopenattr accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opopen_confirm() *OPEN_CONFIRM4res {
	switch u.Resop {
	case OP_OPEN_CONFIRM:
		if v, ok := u.U.(*OPEN_CONFIRM4res); ok {
			return v
		} else {
			var zero OPEN_CONFIRM4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opopen_confirm accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opopen_downgrade() *OPEN_DOWNGRADE4res {
	switch u.Resop {
	case OP_OPEN_DOWNGRADE:
		if v, ok := u.U.(*OPEN_DOWNGRADE4res); ok {
			return v
		} else {
			var zero OPEN_DOWNGRADE4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opopen_downgrade accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opputfh() *PUTFH4res {
	switch u.Resop {
	case OP_PUTFH:
		if v, ok := u.U.(*PUTFH4res); ok {
			return v
		} else {
			var zero PUTFH4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opputfh accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opputpubfh() *PUTPUBFH4res {
	switch u.Resop {
	case OP_PUTPUBFH:
		if v, ok := u.U.(*PUTPUBFH4res); ok {
			return v
		} else {
			var zero PUTPUBFH4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opputpubfh accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opputrootfh() *PUTROOTFH4res {
	switch u.Resop {
	case OP_PUTROOTFH:
		if v, ok := u.U.(*PUTROOTFH4res); ok {
			return v
		} else {
			var zero PUTROOTFH4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opputrootfh accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opread() *READ4res {
	switch u.Resop {
	case OP_READ:
		if v, ok := u.U.(*READ4res); ok {
			return v
		} else {
			var zero READ4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opread accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opreaddir() *READDIR4res {
	switch u.Resop {
	case OP_READDIR:
		if v, ok := u.U.(*READDIR4res); ok {
			return v
		} else {
			var zero READDIR4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opreaddir accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opreadlink() *READLINK4res {
	switch u.Resop {
	case OP_READLINK:
		if v, ok := u.U.(*READLINK4res); ok {
			return v
		} else {
			var zero READLINK4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opreadlink accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opremove() *REMOVE4res {
	switch u.Resop {
	case OP_REMOVE:
		if v, ok := u.U.(*REMOVE4res); ok {
			return v
		} else {
			var zero REMOVE4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opremove accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Oprename() *RENAME4res {
	switch u.Resop {
	case OP_RENAME:
		if v, ok := u.U.(*RENAME4res); ok {
			return v
		} else {
			var zero RENAME4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Oprename accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Oprenew() *RENEW4res {
	switch u.Resop {
	case OP_RENEW:
		if v, ok := u.U.(*RENEW4res); ok {
			return v
		} else {
			var zero RENEW4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Oprenew accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Oprestorefh() *RESTOREFH4res {
	switch u.Resop {
	case OP_RESTOREFH:
		if v, ok := u.U.(*RESTOREFH4res); ok {
			return v
		} else {
			var zero RESTOREFH4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Oprestorefh accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opsavefh() *SAVEFH4res {
	switch u.Resop {
	case OP_SAVEFH:
		if v, ok := u.U.(*SAVEFH4res); ok {
			return v
		} else {
			var zero SAVEFH4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opsavefh accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opsecinfo() *SECINFO4res {
	switch u.Resop {
	case OP_SECINFO:
		if v, ok := u.U.(*SECINFO4res); ok {
			return v
		} else {
			var zero SECINFO4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opsecinfo accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opsetattr() *SETATTR4res {
	switch u.Resop {
	case OP_SETATTR:
		if v, ok := u.U.(*SETATTR4res); ok {
			return v
		} else {
			var zero SETATTR4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opsetattr accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opsetclientid() *SETCLIENTID4res {
	switch u.Resop {
	case OP_SETCLIENTID:
		if v, ok := u.U.(*SETCLIENTID4res); ok {
			return v
		} else {
			var zero SETCLIENTID4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opsetclientid accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opsetclientid_confirm() *SETCLIENTID_CONFIRM4res {
	switch u.Resop {
	case OP_SETCLIENTID_CONFIRM:
		if v, ok := u.U.(*SETCLIENTID_CONFIRM4res); ok {
			return v
		} else {
			var zero SETCLIENTID_CONFIRM4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opsetclientid_confirm accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opverify() *VERIFY4res {
	switch u.Resop {
	case OP_VERIFY:
		if v, ok := u.U.(*VERIFY4res); ok {
			return v
		} else {
			var zero VERIFY4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opverify accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opwrite() *WRITE4res {
	switch u.Resop {
	case OP_WRITE:
		if v, ok := u.U.(*WRITE4res); ok {
			return v
		} else {
			var zero WRITE4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opwrite accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Oprelease_lockowner() *RELEASE_LOCKOWNER4res {
	switch u.Resop {
	case OP_RELEASE_LOCKOWNER:
		if v, ok := u.U.(*RELEASE_LOCKOWNER4res); ok {
			return v
		} else {
			var zero RELEASE_LOCKOWNER4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Oprelease_lockowner accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opcreatesession() *CREATE_SESSION4res {
	switch u.Resop {
	case OP_CREATE_SESSION:
		if v, ok := u.U.(*CREATE_SESSION4res); ok {
			return v
		} else {
			var zero CREATE_SESSION4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opcreatesession accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opdestroysession() *DESTROY_SESSION4res {
	switch u.Resop {
	case OP_DESTROY_SESSION:
		if v, ok := u.U.(*DESTROY_SESSION4res); ok {
			return v
		} else {
			var zero DESTROY_SESSION4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opdestroysession accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opfreestateid() *FREE_STATEID4res {
	switch u.Resop {
	case OP_FREE_STATEID:
		if v, ok := u.U.(*FREE_STATEID4res); ok {
			return v
		} else {
			var zero FREE_STATEID4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opfreestateid accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opgetdirdelegation() *GET_DIR_DELEGATION4res {
	switch u.Resop {
	case OP_GET_DIR_DELEGATION:
		if v, ok := u.U.(*GET_DIR_DELEGATION4res); ok {
			return v
		} else {
			var zero GET_DIR_DELEGATION4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opgetdirdelegation accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opgetdeviceinfo() *GETDEVICEINFO4res {
	switch u.Resop {
	case OP_GETDEVICEINFO:
		if v, ok := u.U.(*GETDEVICEINFO4res); ok {
			return v
		} else {
			var zero GETDEVICEINFO4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opgetdeviceinfo accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opgetdevicelist() *GETDEVICELIST4res {
	switch u.Resop {
	case OP_GETDEVICELIST:
		if v, ok := u.U.(*GETDEVICELIST4res); ok {
			return v
		} else {
			var zero GETDEVICELIST4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opgetdevicelist accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Oplayoutcommit() *LAYOUTCOMMIT4res {
	switch u.Resop {
	case OP_LAYOUTCOMMIT:
		if v, ok := u.U.(*LAYOUTCOMMIT4res); ok {
			return v
		} else {
			var zero LAYOUTCOMMIT4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Oplayoutcommit accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Oplayoutget() *LAYOUTGET4res {
	switch u.Resop {
	case OP_LAYOUTGET:
		if v, ok := u.U.(*LAYOUTGET4res); ok {
			return v
		} else {
			var zero LAYOUTGET4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Oplayoutget accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Oplayoutreturn() *LAYOUTRETURN4res {
	switch u.Resop {
	case OP_LAYOUTRETURN:
		if v, ok := u.U.(*LAYOUTRETURN4res); ok {
			return v
		} else {
			var zero LAYOUTRETURN4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Oplayoutreturn accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opsecinfononame() *SECINFO_NO_NAME4res {
	switch u.Resop {
	case OP_SECINFO_NO_NAME:
		if v, ok := u.U.(*SECINFO_NO_NAME4res); ok {
			return v
		} else {
			var zero SECINFO_NO_NAME4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opsecinfononame accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opsequence() *SEQUENCE4res {
	switch u.Resop {
	case OP_SEQUENCE:
		if v, ok := u.U.(*SEQUENCE4res); ok {
			return v
		} else {
			var zero SEQUENCE4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opsequence accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opsetssv() *SET_SSV4res {
	switch u.Resop {
	case OP_SET_SSV:
		if v, ok := u.U.(*SET_SSV4res); ok {
			return v
		} else {
			var zero SET_SSV4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opsetssv accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opteststateid() *TEST_STATEID4res {
	switch u.Resop {
	case OP_TEST_STATEID:
		if v, ok := u.U.(*TEST_STATEID4res); ok {
			return v
		} else {
			var zero TEST_STATEID4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opteststateid accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opwantdelegation() *WANT_DELEGATION4res {
	switch u.Resop {
	case OP_WANT_DELEGATION:
		if v, ok := u.U.(*WANT_DELEGATION4res); ok {
			return v
		} else {
			var zero WANT_DELEGATION4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opwantdelegation accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opdestroyclientid() *DESTROY_CLIENTID4res {
	switch u.Resop {
	case OP_DESTROY_CLIENTID:
		if v, ok := u.U.(*DESTROY_CLIENTID4res); ok {
			return v
		} else {
			var zero DESTROY_CLIENTID4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opdestroyclientid accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opreclaimcomplete() *RECLAIM_COMPLETE4res {
	switch u.Resop {
	case OP_RECLAIM_COMPLETE:
		if v, ok := u.U.(*RECLAIM_COMPLETE4res); ok {
			return v
		} else {
			var zero RECLAIM_COMPLETE4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opreclaimcomplete accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_resop4) Opillegal() *ILLEGAL4res {
	switch u.Resop {
	case OP_ILLEGAL:
		if v, ok := u.U.(*ILLEGAL4res); ok {
			return v
		} else {
			var zero ILLEGAL4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_resop4.Opillegal accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u Nfs_resop4) XdrValid() bool {
	switch u.Resop {
	case OP_ACCESS,OP_CLOSE,OP_COMMIT,OP_CREATE,OP_DELEGPURGE,OP_DELEGRETURN,OP_GETATTR,OP_GETFH,OP_LINK,OP_LOCK,OP_LOCKT,OP_LOCKU,OP_LOOKUP,OP_LOOKUPP,OP_NVERIFY,OP_OPEN,OP_OPENATTR,OP_OPEN_CONFIRM,OP_OPEN_DOWNGRADE,OP_PUTFH,OP_PUTPUBFH,OP_PUTROOTFH,OP_READ,OP_READDIR,OP_READLINK,OP_REMOVE,OP_RENAME,OP_RENEW,OP_RESTOREFH,OP_SAVEFH,OP_SECINFO,OP_SETATTR,OP_SETCLIENTID,OP_SETCLIENTID_CONFIRM,OP_VERIFY,OP_WRITE,OP_RELEASE_LOCKOWNER,OP_CREATE_SESSION,OP_DESTROY_SESSION,OP_FREE_STATEID,OP_GET_DIR_DELEGATION,OP_GETDEVICEINFO,OP_GETDEVICELIST,OP_LAYOUTCOMMIT,OP_LAYOUTGET,OP_LAYOUTRETURN,OP_SECINFO_NO_NAME,OP_SEQUENCE,OP_SET_SSV,OP_TEST_STATEID,OP_WANT_DELEGATION,OP_DESTROY_CLIENTID,OP_RECLAIM_COMPLETE,OP_ILLEGAL:
		return true
	}
	return false
}
func (u *Nfs_resop4) XdrUnionTag() XdrNum32 {
	return XDR_Nfs_opnum4(&u.Resop)
}
func (u *Nfs_resop4) XdrUnionTagName() string {
	return "Resop"
}
func (u *Nfs_resop4) XdrUnionBody() XdrType {
	switch u.Resop {
	case OP_ACCESS:
		return XDR_ACCESS4res(u.Opaccess())
	case OP_CLOSE:
		return XDR_CLOSE4res(u.Opclose())
	case OP_COMMIT:
		return XDR_COMMIT4res(u.Opcommit())
	case OP_CREATE:
		return XDR_CREATE4res(u.Opcreate())
	case OP_DELEGPURGE:
		return XDR_DELEGPURGE4res(u.Opdelegpurge())
	case OP_DELEGRETURN:
		return XDR_DELEGRETURN4res(u.Opdelegreturn())
	case OP_GETATTR:
		return XDR_GETATTR4res(u.Opgetattr())
	case OP_GETFH:
		return XDR_GETFH4res(u.Opgetfh())
	case OP_LINK:
		return XDR_LINK4res(u.Oplink())
	case OP_LOCK:
		return XDR_LOCK4res(u.Oplock())
	case OP_LOCKT:
		return XDR_LOCKT4res(u.Oplockt())
	case OP_LOCKU:
		return XDR_LOCKU4res(u.Oplocku())
	case OP_LOOKUP:
		return XDR_LOOKUP4res(u.Oplookup())
	case OP_LOOKUPP:
		return XDR_LOOKUPP4res(u.Oplookupp())
	case OP_NVERIFY:
		return XDR_NVERIFY4res(u.Opnverify())
	case OP_OPEN:
		return XDR_OPEN4res(u.Opopen())
	case OP_OPENATTR:
		return XDR_OPENATTR4res(u.Opopenattr())
	case OP_OPEN_CONFIRM:
		return XDR_OPEN_CONFIRM4res(u.Opopen_confirm())
	case OP_OPEN_DOWNGRADE:
		return XDR_OPEN_DOWNGRADE4res(u.Opopen_downgrade())
	case OP_PUTFH:
		return XDR_PUTFH4res(u.Opputfh())
	case OP_PUTPUBFH:
		return XDR_PUTPUBFH4res(u.Opputpubfh())
	case OP_PUTROOTFH:
		return XDR_PUTROOTFH4res(u.Opputrootfh())
	case OP_READ:
		return XDR_READ4res(u.Opread())
	case OP_READDIR:
		return XDR_READDIR4res(u.Opreaddir())
	case OP_READLINK:
		return XDR_READLINK4res(u.Opreadlink())
	case OP_REMOVE:
		return XDR_REMOVE4res(u.Opremove())
	case OP_RENAME:
		return XDR_RENAME4res(u.Oprename())
	case OP_RENEW:
		return XDR_RENEW4res(u.Oprenew())
	case OP_RESTOREFH:
		return XDR_RESTOREFH4res(u.Oprestorefh())
	case OP_SAVEFH:
		return XDR_SAVEFH4res(u.Opsavefh())
	case OP_SECINFO:
		return XDR_SECINFO4res(u.Opsecinfo())
	case OP_SETATTR:
		return XDR_SETATTR4res(u.Opsetattr())
	case OP_SETCLIENTID:
		return XDR_SETCLIENTID4res(u.Opsetclientid())
	case OP_SETCLIENTID_CONFIRM:
		return XDR_SETCLIENTID_CONFIRM4res(u.Opsetclientid_confirm())
	case OP_VERIFY:
		return XDR_VERIFY4res(u.Opverify())
	case OP_WRITE:
		return XDR_WRITE4res(u.Opwrite())
	case OP_RELEASE_LOCKOWNER:
		return XDR_RELEASE_LOCKOWNER4res(u.Oprelease_lockowner())
	case OP_CREATE_SESSION:
		return XDR_CREATE_SESSION4res(u.Opcreatesession())
	case OP_DESTROY_SESSION:
		return XDR_DESTROY_SESSION4res(u.Opdestroysession())
	case OP_FREE_STATEID:
		return XDR_FREE_STATEID4res(u.Opfreestateid())
	case OP_GET_DIR_DELEGATION:
		return XDR_GET_DIR_DELEGATION4res(u.Opgetdirdelegation())
	case OP_GETDEVICEINFO:
		return XDR_GETDEVICEINFO4res(u.Opgetdeviceinfo())
	case OP_GETDEVICELIST:
		return XDR_GETDEVICELIST4res(u.Opgetdevicelist())
	case OP_LAYOUTCOMMIT:
		return XDR_LAYOUTCOMMIT4res(u.Oplayoutcommit())
	case OP_LAYOUTGET:
		return XDR_LAYOUTGET4res(u.Oplayoutget())
	case OP_LAYOUTRETURN:
		return XDR_LAYOUTRETURN4res(u.Oplayoutreturn())
	case OP_SECINFO_NO_NAME:
		return XDR_SECINFO_NO_NAME4res(u.Opsecinfononame())
	case OP_SEQUENCE:
		return XDR_SEQUENCE4res(u.Opsequence())
	case OP_SET_SSV:
		return XDR_SET_SSV4res(u.Opsetssv())
	case OP_TEST_STATEID:
		return XDR_TEST_STATEID4res(u.Opteststateid())
	case OP_WANT_DELEGATION:
		return XDR_WANT_DELEGATION4res(u.Opwantdelegation())
	case OP_DESTROY_CLIENTID:
		return XDR_DESTROY_CLIENTID4res(u.Opdestroyclientid())
	case OP_RECLAIM_COMPLETE:
		return XDR_RECLAIM_COMPLETE4res(u.Opreclaimcomplete())
	case OP_ILLEGAL:
		return XDR_ILLEGAL4res(u.Opillegal())
	}
	return nil
}
func (u *Nfs_resop4) XdrUnionBodyName() string {
	switch u.Resop {
	case OP_ACCESS:
		return "Opaccess"
	case OP_CLOSE:
		return "Opclose"
	case OP_COMMIT:
		return "Opcommit"
	case OP_CREATE:
		return "Opcreate"
	case OP_DELEGPURGE:
		return "Opdelegpurge"
	case OP_DELEGRETURN:
		return "Opdelegreturn"
	case OP_GETATTR:
		return "Opgetattr"
	case OP_GETFH:
		return "Opgetfh"
	case OP_LINK:
		return "Oplink"
	case OP_LOCK:
		return "Oplock"
	case OP_LOCKT:
		return "Oplockt"
	case OP_LOCKU:
		return "Oplocku"
	case OP_LOOKUP:
		return "Oplookup"
	case OP_LOOKUPP:
		return "Oplookupp"
	case OP_NVERIFY:
		return "Opnverify"
	case OP_OPEN:
		return "Opopen"
	case OP_OPENATTR:
		return "Opopenattr"
	case OP_OPEN_CONFIRM:
		return "Opopen_confirm"
	case OP_OPEN_DOWNGRADE:
		return "Opopen_downgrade"
	case OP_PUTFH:
		return "Opputfh"
	case OP_PUTPUBFH:
		return "Opputpubfh"
	case OP_PUTROOTFH:
		return "Opputrootfh"
	case OP_READ:
		return "Opread"
	case OP_READDIR:
		return "Opreaddir"
	case OP_READLINK:
		return "Opreadlink"
	case OP_REMOVE:
		return "Opremove"
	case OP_RENAME:
		return "Oprename"
	case OP_RENEW:
		return "Oprenew"
	case OP_RESTOREFH:
		return "Oprestorefh"
	case OP_SAVEFH:
		return "Opsavefh"
	case OP_SECINFO:
		return "Opsecinfo"
	case OP_SETATTR:
		return "Opsetattr"
	case OP_SETCLIENTID:
		return "Opsetclientid"
	case OP_SETCLIENTID_CONFIRM:
		return "Opsetclientid_confirm"
	case OP_VERIFY:
		return "Opverify"
	case OP_WRITE:
		return "Opwrite"
	case OP_RELEASE_LOCKOWNER:
		return "Oprelease_lockowner"
	case OP_CREATE_SESSION:
		return "Opcreatesession"
	case OP_DESTROY_SESSION:
		return "Opdestroysession"
	case OP_FREE_STATEID:
		return "Opfreestateid"
	case OP_GET_DIR_DELEGATION:
		return "Opgetdirdelegation"
	case OP_GETDEVICEINFO:
		return "Opgetdeviceinfo"
	case OP_GETDEVICELIST:
		return "Opgetdevicelist"
	case OP_LAYOUTCOMMIT:
		return "Oplayoutcommit"
	case OP_LAYOUTGET:
		return "Oplayoutget"
	case OP_LAYOUTRETURN:
		return "Oplayoutreturn"
	case OP_SECINFO_NO_NAME:
		return "Opsecinfononame"
	case OP_SEQUENCE:
		return "Opsequence"
	case OP_SET_SSV:
		return "Opsetssv"
	case OP_TEST_STATEID:
		return "Opteststateid"
	case OP_WANT_DELEGATION:
		return "Opwantdelegation"
	case OP_DESTROY_CLIENTID:
		return "Opdestroyclientid"
	case OP_RECLAIM_COMPLETE:
		return "Opreclaimcomplete"
	case OP_ILLEGAL:
		return "Opillegal"
	}
	return ""
}
type XdrType_Nfs_resop4 = *Nfs_resop4
func (v *Nfs_resop4) XdrPointer() interface{} { return v }
func (Nfs_resop4) XdrTypeName() string { return "Nfs_resop4" }
func (v Nfs_resop4) XdrValue() interface{} { return v }
func (v *Nfs_resop4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Nfs_resop4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfs_opnum4(&u.Resop).XdrMarshal(x, x.Sprintf("%sresop", name))
	switch u.Resop {
	case OP_ACCESS:
		x.Marshal(x.Sprintf("%sopaccess", name), XDR_ACCESS4res(u.Opaccess()))
		return
	case OP_CLOSE:
		x.Marshal(x.Sprintf("%sopclose", name), XDR_CLOSE4res(u.Opclose()))
		return
	case OP_COMMIT:
		x.Marshal(x.Sprintf("%sopcommit", name), XDR_COMMIT4res(u.Opcommit()))
		return
	case OP_CREATE:
		x.Marshal(x.Sprintf("%sopcreate", name), XDR_CREATE4res(u.Opcreate()))
		return
	case OP_DELEGPURGE:
		x.Marshal(x.Sprintf("%sopdelegpurge", name), XDR_DELEGPURGE4res(u.Opdelegpurge()))
		return
	case OP_DELEGRETURN:
		x.Marshal(x.Sprintf("%sopdelegreturn", name), XDR_DELEGRETURN4res(u.Opdelegreturn()))
		return
	case OP_GETATTR:
		x.Marshal(x.Sprintf("%sopgetattr", name), XDR_GETATTR4res(u.Opgetattr()))
		return
	case OP_GETFH:
		x.Marshal(x.Sprintf("%sopgetfh", name), XDR_GETFH4res(u.Opgetfh()))
		return
	case OP_LINK:
		x.Marshal(x.Sprintf("%soplink", name), XDR_LINK4res(u.Oplink()))
		return
	case OP_LOCK:
		x.Marshal(x.Sprintf("%soplock", name), XDR_LOCK4res(u.Oplock()))
		return
	case OP_LOCKT:
		x.Marshal(x.Sprintf("%soplockt", name), XDR_LOCKT4res(u.Oplockt()))
		return
	case OP_LOCKU:
		x.Marshal(x.Sprintf("%soplocku", name), XDR_LOCKU4res(u.Oplocku()))
		return
	case OP_LOOKUP:
		x.Marshal(x.Sprintf("%soplookup", name), XDR_LOOKUP4res(u.Oplookup()))
		return
	case OP_LOOKUPP:
		x.Marshal(x.Sprintf("%soplookupp", name), XDR_LOOKUPP4res(u.Oplookupp()))
		return
	case OP_NVERIFY:
		x.Marshal(x.Sprintf("%sopnverify", name), XDR_NVERIFY4res(u.Opnverify()))
		return
	case OP_OPEN:
		x.Marshal(x.Sprintf("%sopopen", name), XDR_OPEN4res(u.Opopen()))
		return
	case OP_OPENATTR:
		x.Marshal(x.Sprintf("%sopopenattr", name), XDR_OPENATTR4res(u.Opopenattr()))
		return
	case OP_OPEN_CONFIRM:
		x.Marshal(x.Sprintf("%sopopen_confirm", name), XDR_OPEN_CONFIRM4res(u.Opopen_confirm()))
		return
	case OP_OPEN_DOWNGRADE:
		x.Marshal(x.Sprintf("%sopopen_downgrade", name), XDR_OPEN_DOWNGRADE4res(u.Opopen_downgrade()))
		return
	case OP_PUTFH:
		x.Marshal(x.Sprintf("%sopputfh", name), XDR_PUTFH4res(u.Opputfh()))
		return
	case OP_PUTPUBFH:
		x.Marshal(x.Sprintf("%sopputpubfh", name), XDR_PUTPUBFH4res(u.Opputpubfh()))
		return
	case OP_PUTROOTFH:
		x.Marshal(x.Sprintf("%sopputrootfh", name), XDR_PUTROOTFH4res(u.Opputrootfh()))
		return
	case OP_READ:
		x.Marshal(x.Sprintf("%sopread", name), XDR_READ4res(u.Opread()))
		return
	case OP_READDIR:
		x.Marshal(x.Sprintf("%sopreaddir", name), XDR_READDIR4res(u.Opreaddir()))
		return
	case OP_READLINK:
		x.Marshal(x.Sprintf("%sopreadlink", name), XDR_READLINK4res(u.Opreadlink()))
		return
	case OP_REMOVE:
		x.Marshal(x.Sprintf("%sopremove", name), XDR_REMOVE4res(u.Opremove()))
		return
	case OP_RENAME:
		x.Marshal(x.Sprintf("%soprename", name), XDR_RENAME4res(u.Oprename()))
		return
	case OP_RENEW:
		x.Marshal(x.Sprintf("%soprenew", name), XDR_RENEW4res(u.Oprenew()))
		return
	case OP_RESTOREFH:
		x.Marshal(x.Sprintf("%soprestorefh", name), XDR_RESTOREFH4res(u.Oprestorefh()))
		return
	case OP_SAVEFH:
		x.Marshal(x.Sprintf("%sopsavefh", name), XDR_SAVEFH4res(u.Opsavefh()))
		return
	case OP_SECINFO:
		x.Marshal(x.Sprintf("%sopsecinfo", name), XDR_SECINFO4res(u.Opsecinfo()))
		return
	case OP_SETATTR:
		x.Marshal(x.Sprintf("%sopsetattr", name), XDR_SETATTR4res(u.Opsetattr()))
		return
	case OP_SETCLIENTID:
		x.Marshal(x.Sprintf("%sopsetclientid", name), XDR_SETCLIENTID4res(u.Opsetclientid()))
		return
	case OP_SETCLIENTID_CONFIRM:
		x.Marshal(x.Sprintf("%sopsetclientid_confirm", name), XDR_SETCLIENTID_CONFIRM4res(u.Opsetclientid_confirm()))
		return
	case OP_VERIFY:
		x.Marshal(x.Sprintf("%sopverify", name), XDR_VERIFY4res(u.Opverify()))
		return
	case OP_WRITE:
		x.Marshal(x.Sprintf("%sopwrite", name), XDR_WRITE4res(u.Opwrite()))
		return
	case OP_RELEASE_LOCKOWNER:
		x.Marshal(x.Sprintf("%soprelease_lockowner", name), XDR_RELEASE_LOCKOWNER4res(u.Oprelease_lockowner()))
		return
	case OP_CREATE_SESSION:
		x.Marshal(x.Sprintf("%sopcreatesession", name), XDR_CREATE_SESSION4res(u.Opcreatesession()))
		return
	case OP_DESTROY_SESSION:
		x.Marshal(x.Sprintf("%sopdestroysession", name), XDR_DESTROY_SESSION4res(u.Opdestroysession()))
		return
	case OP_FREE_STATEID:
		x.Marshal(x.Sprintf("%sopfreestateid", name), XDR_FREE_STATEID4res(u.Opfreestateid()))
		return
	case OP_GET_DIR_DELEGATION:
		x.Marshal(x.Sprintf("%sopgetdirdelegation", name), XDR_GET_DIR_DELEGATION4res(u.Opgetdirdelegation()))
		return
	case OP_GETDEVICEINFO:
		x.Marshal(x.Sprintf("%sopgetdeviceinfo", name), XDR_GETDEVICEINFO4res(u.Opgetdeviceinfo()))
		return
	case OP_GETDEVICELIST:
		x.Marshal(x.Sprintf("%sopgetdevicelist", name), XDR_GETDEVICELIST4res(u.Opgetdevicelist()))
		return
	case OP_LAYOUTCOMMIT:
		x.Marshal(x.Sprintf("%soplayoutcommit", name), XDR_LAYOUTCOMMIT4res(u.Oplayoutcommit()))
		return
	case OP_LAYOUTGET:
		x.Marshal(x.Sprintf("%soplayoutget", name), XDR_LAYOUTGET4res(u.Oplayoutget()))
		return
	case OP_LAYOUTRETURN:
		x.Marshal(x.Sprintf("%soplayoutreturn", name), XDR_LAYOUTRETURN4res(u.Oplayoutreturn()))
		return
	case OP_SECINFO_NO_NAME:
		x.Marshal(x.Sprintf("%sopsecinfononame", name), XDR_SECINFO_NO_NAME4res(u.Opsecinfononame()))
		return
	case OP_SEQUENCE:
		x.Marshal(x.Sprintf("%sopsequence", name), XDR_SEQUENCE4res(u.Opsequence()))
		return
	case OP_SET_SSV:
		x.Marshal(x.Sprintf("%sopsetssv", name), XDR_SET_SSV4res(u.Opsetssv()))
		return
	case OP_TEST_STATEID:
		x.Marshal(x.Sprintf("%sopteststateid", name), XDR_TEST_STATEID4res(u.Opteststateid()))
		return
	case OP_WANT_DELEGATION:
		x.Marshal(x.Sprintf("%sopwantdelegation", name), XDR_WANT_DELEGATION4res(u.Opwantdelegation()))
		return
	case OP_DESTROY_CLIENTID:
		x.Marshal(x.Sprintf("%sopdestroyclientid", name), XDR_DESTROY_CLIENTID4res(u.Opdestroyclientid()))
		return
	case OP_RECLAIM_COMPLETE:
		x.Marshal(x.Sprintf("%sopreclaimcomplete", name), XDR_RECLAIM_COMPLETE4res(u.Opreclaimcomplete()))
		return
	case OP_ILLEGAL:
		x.Marshal(x.Sprintf("%sopillegal", name), XDR_ILLEGAL4res(u.Opillegal()))
		return
	}
	XdrPanic("invalid Resop (%v) in Nfs_resop4", u.Resop)
}
func (v *Nfs_resop4) XdrInitialize() {
	var zero Nfs_opnum4
	switch zero {
	case OP_ACCESS, OP_CLOSE, OP_COMMIT, OP_CREATE, OP_DELEGPURGE, OP_DELEGRETURN, OP_GETATTR, OP_GETFH, OP_LINK, OP_LOCK, OP_LOCKT, OP_LOCKU, OP_LOOKUP, OP_LOOKUPP, OP_NVERIFY, OP_OPEN, OP_OPENATTR, OP_OPEN_CONFIRM, OP_OPEN_DOWNGRADE, OP_PUTFH, OP_PUTPUBFH, OP_PUTROOTFH, OP_READ, OP_READDIR, OP_READLINK, OP_REMOVE, OP_RENAME, OP_RENEW, OP_RESTOREFH, OP_SAVEFH, OP_SECINFO, OP_SETATTR, OP_SETCLIENTID, OP_SETCLIENTID_CONFIRM, OP_VERIFY, OP_WRITE, OP_RELEASE_LOCKOWNER, OP_CREATE_SESSION, OP_DESTROY_SESSION, OP_FREE_STATEID, OP_GET_DIR_DELEGATION, OP_GETDEVICEINFO, OP_GETDEVICELIST, OP_LAYOUTCOMMIT, OP_LAYOUTGET, OP_LAYOUTRETURN, OP_SECINFO_NO_NAME, OP_SEQUENCE, OP_SET_SSV, OP_TEST_STATEID, OP_WANT_DELEGATION, OP_DESTROY_CLIENTID, OP_RECLAIM_COMPLETE, OP_ILLEGAL:
	default:
		if v.Resop == zero { v.Resop = OP_ACCESS }
	}
}
func XDR_Nfs_resop4(v *Nfs_resop4) *Nfs_resop4 { return v}
type _XdrVec_unbounded_Nfs_argop4 []Nfs_argop4
func (_XdrVec_unbounded_Nfs_argop4) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Nfs_argop4) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Nfs_argop4 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Nfs_argop4 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Nfs_argop4) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Nfs_argop4) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Nfs_argop4, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Nfs_argop4) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Nfs_argop4(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Nfs_argop4) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Nfs_argop4) XdrTypeName() string { return "Nfs_argop4<>" }
func (v *_XdrVec_unbounded_Nfs_argop4) XdrPointer() interface{} { return (*[]Nfs_argop4)(v) }
func (v _XdrVec_unbounded_Nfs_argop4) XdrValue() interface{} { return ([]Nfs_argop4)(v) }
func (v *_XdrVec_unbounded_Nfs_argop4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_COMPOUND4args = *COMPOUND4args
func (v *COMPOUND4args) XdrPointer() interface{} { return v }
func (COMPOUND4args) XdrTypeName() string { return "COMPOUND4args" }
func (v COMPOUND4args) XdrValue() interface{} { return v }
func (v *COMPOUND4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *COMPOUND4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stag", name), XDR_Utf8str_cs(&v.Tag))
	x.Marshal(x.Sprintf("%sminorversion", name), XDR_Uint32_t(&v.Minorversion))
	x.Marshal(x.Sprintf("%sargarray", name), (*_XdrVec_unbounded_Nfs_argop4)(&v.Argarray))
}
func XDR_COMPOUND4args(v *COMPOUND4args) *COMPOUND4args { return v }
type _XdrVec_unbounded_Nfs_resop4 []Nfs_resop4
func (_XdrVec_unbounded_Nfs_resop4) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Nfs_resop4) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Nfs_resop4 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Nfs_resop4 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Nfs_resop4) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Nfs_resop4) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Nfs_resop4, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Nfs_resop4) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Nfs_resop4(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Nfs_resop4) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Nfs_resop4) XdrTypeName() string { return "Nfs_resop4<>" }
func (v *_XdrVec_unbounded_Nfs_resop4) XdrPointer() interface{} { return (*[]Nfs_resop4)(v) }
func (v _XdrVec_unbounded_Nfs_resop4) XdrValue() interface{} { return ([]Nfs_resop4)(v) }
func (v *_XdrVec_unbounded_Nfs_resop4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_COMPOUND4res = *COMPOUND4res
func (v *COMPOUND4res) XdrPointer() interface{} { return v }
func (COMPOUND4res) XdrTypeName() string { return "COMPOUND4res" }
func (v COMPOUND4res) XdrValue() interface{} { return v }
func (v *COMPOUND4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *COMPOUND4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
	x.Marshal(x.Sprintf("%stag", name), XDR_Utf8str_cs(&v.Tag))
	x.Marshal(x.Sprintf("%sresarray", name), (*_XdrVec_unbounded_Nfs_resop4)(&v.Resarray))
}
func XDR_COMPOUND4res(v *COMPOUND4res) *COMPOUND4res { return v }

type XdrProc_NFSPROC4_NULL struct {
	Arg *XdrVoid
	Res *XdrVoid
}
func (XdrProc_NFSPROC4_NULL) Prog() uint32     { return 100003 }
func (XdrProc_NFSPROC4_NULL) Vers() uint32     { return 4 }
func (XdrProc_NFSPROC4_NULL) Proc() uint32     { return 0 }
func (XdrProc_NFSPROC4_NULL) ProgName() string { return "NFS4_PROGRAM" }
func (XdrProc_NFSPROC4_NULL) VersName() string { return "NFS_V4" }
func (XdrProc_NFSPROC4_NULL) ProcName() string { return "NFSPROC4_NULL" }
func (p *XdrProc_NFSPROC4_NULL) GetArg() XdrType {
	if p.Arg == nil {
		p.Arg = new(XdrVoid)
	}
	return XDR_XdrVoid(p.Arg)
}
func (p *XdrProc_NFSPROC4_NULL) GetRes() XdrType {
	if p.Res == nil {
		p.Res = new(XdrVoid)
	}
	return XDR_XdrVoid(p.Res)
}
var _ XdrProc = &XdrProc_NFSPROC4_NULL{} // XXX

type xdrSrvProc_NFSPROC4_NULL struct {
	XdrProc_NFSPROC4_NULL
	Srv NFS_V4
}
func (p *xdrSrvProc_NFSPROC4_NULL) SetContext(ctx context.Context) {
	if wc, ok := p.Srv.(interface {
		WithContext(context.Context) NFS_V4
	}); ok {
		p.Srv = wc.WithContext(ctx)
	}
}
func (p *xdrSrvProc_NFSPROC4_NULL) Do() {
	p.Srv.NFSPROC4_NULL()
}
var _ XdrSrvProc = &xdrSrvProc_NFSPROC4_NULL{} // XXX

type XdrProc_NFSPROC4_COMPOUND struct {
	Arg *COMPOUND4args
	Res *COMPOUND4res
}
func (XdrProc_NFSPROC4_COMPOUND) Prog() uint32 { return 100003 }
func (XdrProc_NFSPROC4_COMPOUND) Vers() uint32 { return 4 }
func (XdrProc_NFSPROC4_COMPOUND) Proc() uint32 { return 1 }
func (XdrProc_NFSPROC4_COMPOUND) ProgName() string { return "NFS4_PROGRAM" }
func (XdrProc_NFSPROC4_COMPOUND) VersName() string { return "NFS_V4" }
func (XdrProc_NFSPROC4_COMPOUND) ProcName() string { return "NFSPROC4_COMPOUND" }
func (p *XdrProc_NFSPROC4_COMPOUND) GetArg() XdrType {
	if p.Arg == nil {
		p.Arg = new(COMPOUND4args)
	}
	return XDR_COMPOUND4args(p.Arg)
}
func (p *XdrProc_NFSPROC4_COMPOUND) GetRes() XdrType {
	if p.Res == nil {
		p.Res = new(COMPOUND4res)
	}
	return XDR_COMPOUND4res(p.Res)
}
var _ XdrProc = &XdrProc_NFSPROC4_COMPOUND{} // XXX

type xdrSrvProc_NFSPROC4_COMPOUND struct {
	XdrProc_NFSPROC4_COMPOUND
	Srv NFS_V4
}
func (p *xdrSrvProc_NFSPROC4_COMPOUND) SetContext(ctx context.Context) {
	if wc, ok := p.Srv.(interface {
		WithContext(context.Context) NFS_V4
	}); ok {
		p.Srv = wc.WithContext(ctx)
	}
}
func (p *xdrSrvProc_NFSPROC4_COMPOUND) Do() {
	r := p.Srv.NFSPROC4_COMPOUND(*p.Arg)
	p.Res = &r

}
var _ XdrSrvProc = &xdrSrvProc_NFSPROC4_COMPOUND{} // XXX

func init() {
	XdrCatalog[100003<<32|4] = func(p uint32) XdrProc {
		switch(p) {
		case 0:
			return &XdrProc_NFSPROC4_NULL{}
		case 1:
			return &XdrProc_NFSPROC4_COMPOUND{}
		}
		return nil
	}
}

type NFS_V4_Server struct {
	Srv NFS_V4
}
func (NFS_V4_Server) Prog() uint32 { return 100003 }
func (NFS_V4_Server) Vers() uint32 { return 4 }
func (NFS_V4_Server) ProgName() string { return "NFS4_PROGRAM" }
func (NFS_V4_Server) VersName() string { return "NFS_V4" }
func (s NFS_V4_Server) GetProc(p uint32) XdrSrvProc {
	switch p {
	case 0:  // NFSPROC4_NULL
		return &xdrSrvProc_NFSPROC4_NULL{ Srv: s.Srv }
	case 1:  // NFSPROC4_COMPOUND
		return &xdrSrvProc_NFSPROC4_COMPOUND{ Srv: s.Srv }
	default:
		return nil
	}
}
var _ XdrSrv = NFS_V4_Server{} // XXX

type NFS_V4_Client struct {
	Send XdrSendCall
	Ctx context.Context
}
var _ NFS_V4 = NFS_V4_Client{} // XXX
func (c NFS_V4_Client) WithContext(ctx context.Context) NFS_V4 {
	c.Ctx = ctx
	return c
}
func (c NFS_V4_Client) NFSPROC4_NULL() {
	var proc XdrProc_NFSPROC4_NULL
	if err := c.Send.SendCall(c.Ctx, &proc); err != nil {
		panic(err)
	}
}
func (c NFS_V4_Client) NFSPROC4_COMPOUND(a1 COMPOUND4args) COMPOUND4res {
	var proc XdrProc_NFSPROC4_COMPOUND
	proc.Arg = &a1
	if err := c.Send.SendCall(c.Ctx, &proc); err != nil {
		panic(err)
	}
	return *proc.Res
}
type XdrType_CB_GETATTR4args = *CB_GETATTR4args
func (v *CB_GETATTR4args) XdrPointer() interface{} { return v }
func (CB_GETATTR4args) XdrTypeName() string { return "CB_GETATTR4args" }
func (v CB_GETATTR4args) XdrValue() interface{} { return v }
func (v *CB_GETATTR4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CB_GETATTR4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sfh", name), XDR_Nfs_fh4(&v.Fh))
	x.Marshal(x.Sprintf("%sattr_request", name), XDR_Bitmap4(&v.Attr_request))
}
func XDR_CB_GETATTR4args(v *CB_GETATTR4args) *CB_GETATTR4args { return v }
type XdrType_CB_GETATTR4resok = *CB_GETATTR4resok
func (v *CB_GETATTR4resok) XdrPointer() interface{} { return v }
func (CB_GETATTR4resok) XdrTypeName() string { return "CB_GETATTR4resok" }
func (v CB_GETATTR4resok) XdrValue() interface{} { return v }
func (v *CB_GETATTR4resok) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CB_GETATTR4resok) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sobj_attributes", name), XDR_Fattr4(&v.Obj_attributes))
}
func XDR_CB_GETATTR4resok(v *CB_GETATTR4resok) *CB_GETATTR4resok { return v }
func (u *CB_GETATTR4res) Resok4() *CB_GETATTR4resok {
	switch u.Status {
	case NFS4_OK:
		if v, ok := u.U.(*CB_GETATTR4resok); ok {
			return v
		} else {
			var zero CB_GETATTR4resok
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("CB_GETATTR4res.Resok4 accessed when Status == %v", u.Status)
		return nil
	}
}
func (u CB_GETATTR4res) XdrValid() bool {
	return true
}
func (u *CB_GETATTR4res) XdrUnionTag() XdrNum32 {
	return XDR_Nfsstat4(&u.Status)
}
func (u *CB_GETATTR4res) XdrUnionTagName() string {
	return "Status"
}
func (u *CB_GETATTR4res) XdrUnionBody() XdrType {
	switch u.Status {
	case NFS4_OK:
		return XDR_CB_GETATTR4resok(u.Resok4())
	default:
		return nil
	}
}
func (u *CB_GETATTR4res) XdrUnionBodyName() string {
	switch u.Status {
	case NFS4_OK:
		return "Resok4"
	default:
		return ""
	}
}
type XdrType_CB_GETATTR4res = *CB_GETATTR4res
func (v *CB_GETATTR4res) XdrPointer() interface{} { return v }
func (CB_GETATTR4res) XdrTypeName() string { return "CB_GETATTR4res" }
func (v CB_GETATTR4res) XdrValue() interface{} { return v }
func (v *CB_GETATTR4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *CB_GETATTR4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_Nfsstat4(&u.Status).XdrMarshal(x, x.Sprintf("%sstatus", name))
	switch u.Status {
	case NFS4_OK:
		x.Marshal(x.Sprintf("%sresok4", name), XDR_CB_GETATTR4resok(u.Resok4()))
		return
	default:
		return
	}
}
func XDR_CB_GETATTR4res(v *CB_GETATTR4res) *CB_GETATTR4res { return v}
type XdrType_CB_RECALL4args = *CB_RECALL4args
func (v *CB_RECALL4args) XdrPointer() interface{} { return v }
func (CB_RECALL4args) XdrTypeName() string { return "CB_RECALL4args" }
func (v CB_RECALL4args) XdrValue() interface{} { return v }
func (v *CB_RECALL4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CB_RECALL4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstateid", name), XDR_Stateid4(&v.Stateid))
	x.Marshal(x.Sprintf("%struncate", name), XDR_bool(&v.Truncate))
	x.Marshal(x.Sprintf("%sfh", name), XDR_Nfs_fh4(&v.Fh))
}
func XDR_CB_RECALL4args(v *CB_RECALL4args) *CB_RECALL4args { return v }
type XdrType_CB_RECALL4res = *CB_RECALL4res
func (v *CB_RECALL4res) XdrPointer() interface{} { return v }
func (CB_RECALL4res) XdrTypeName() string { return "CB_RECALL4res" }
func (v CB_RECALL4res) XdrValue() interface{} { return v }
func (v *CB_RECALL4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CB_RECALL4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_CB_RECALL4res(v *CB_RECALL4res) *CB_RECALL4res { return v }
type XdrType_CB_ILLEGAL4res = *CB_ILLEGAL4res
func (v *CB_ILLEGAL4res) XdrPointer() interface{} { return v }
func (CB_ILLEGAL4res) XdrTypeName() string { return "CB_ILLEGAL4res" }
func (v CB_ILLEGAL4res) XdrValue() interface{} { return v }
func (v *CB_ILLEGAL4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CB_ILLEGAL4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
}
func XDR_CB_ILLEGAL4res(v *CB_ILLEGAL4res) *CB_ILLEGAL4res { return v }
var _XdrNames_Nfs_cb_opnum4 = map[int32]string{
	int32(OP_CB_GETATTR): "OP_CB_GETATTR",
	int32(OP_CB_RECALL): "OP_CB_RECALL",
	int32(OP_CB_ILLEGAL): "OP_CB_ILLEGAL",
}
var _XdrValues_Nfs_cb_opnum4 = map[string]int32{
	"OP_CB_GETATTR": int32(OP_CB_GETATTR),
	"OP_CB_RECALL": int32(OP_CB_RECALL),
	"OP_CB_ILLEGAL": int32(OP_CB_ILLEGAL),
}
func (Nfs_cb_opnum4) XdrEnumNames() map[int32]string {
	return _XdrNames_Nfs_cb_opnum4
}
func (v Nfs_cb_opnum4) String() string {
	if s, ok := _XdrNames_Nfs_cb_opnum4[int32(v)]; ok {
		return s
	}
	return fmt.Sprintf("Nfs_cb_opnum4#%d", v)
}
func (v *Nfs_cb_opnum4) Scan(ss fmt.ScanState, _ rune) error {
	if tok, err := ss.Token(true, XdrSymChar); err != nil {
		return err
	} else {
		stok := string(tok)
		if val, ok := _XdrValues_Nfs_cb_opnum4[stok]; ok {
			*v = Nfs_cb_opnum4(val)
			return nil
		} else if stok == "Nfs_cb_opnum4" {
			if n, err := fmt.Fscanf(ss, "#%d", (*int32)(v));
				n == 1 && err == nil {
				return nil
			}
		}
		return XdrError(fmt.Sprintf("%s is not a valid Nfs_cb_opnum4.", stok))
	}
}
func (v Nfs_cb_opnum4) GetU32() uint32 { return uint32(v) }
func (v *Nfs_cb_opnum4) SetU32(n uint32) { *v = Nfs_cb_opnum4(n) }
func (v *Nfs_cb_opnum4) XdrPointer() interface{} { return v }
func (Nfs_cb_opnum4) XdrTypeName() string { return "Nfs_cb_opnum4" }
func (v Nfs_cb_opnum4) XdrValue() interface{} { return v }
func (v *Nfs_cb_opnum4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_Nfs_cb_opnum4 = *Nfs_cb_opnum4
func XDR_Nfs_cb_opnum4(v *Nfs_cb_opnum4) *Nfs_cb_opnum4 { return v }
func (v *Nfs_cb_opnum4) XdrInitialize() {
	switch Nfs_cb_opnum4(0) {
	case OP_CB_GETATTR, OP_CB_RECALL, OP_CB_ILLEGAL:
	default:
		if *v == Nfs_cb_opnum4(0) { *v = OP_CB_GETATTR }
	}
}
var _XdrTags_Nfs_cb_argop4 = map[int32]bool{
	XdrToI32(OP_CB_GETATTR): true,
	XdrToI32(OP_CB_RECALL): true,
	XdrToI32(OP_CB_ILLEGAL): true,
}
func (_ Nfs_cb_argop4) XdrValidTags() map[int32]bool {
	return _XdrTags_Nfs_cb_argop4
}
func (u *Nfs_cb_argop4) Opcbgetattr() *CB_GETATTR4args {
	switch Nfs_cb_opnum4(u.Argop) {
	case OP_CB_GETATTR:
		if v, ok := u.U.(*CB_GETATTR4args); ok {
			return v
		} else {
			var zero CB_GETATTR4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_cb_argop4.Opcbgetattr accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u *Nfs_cb_argop4) Opcbrecall() *CB_RECALL4args {
	switch Nfs_cb_opnum4(u.Argop) {
	case OP_CB_RECALL:
		if v, ok := u.U.(*CB_RECALL4args); ok {
			return v
		} else {
			var zero CB_RECALL4args
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_cb_argop4.Opcbrecall accessed when Argop == %v", u.Argop)
		return nil
	}
}
func (u Nfs_cb_argop4) XdrValid() bool {
	switch Nfs_cb_opnum4(u.Argop) {
	case OP_CB_GETATTR,OP_CB_RECALL,OP_CB_ILLEGAL:
		return true
	}
	return false
}
func (u *Nfs_cb_argop4) XdrUnionTag() XdrNum32 {
	return XDR_uint32(&u.Argop)
}
func (u *Nfs_cb_argop4) XdrUnionTagName() string {
	return "Argop"
}
func (u *Nfs_cb_argop4) XdrUnionBody() XdrType {
	switch Nfs_cb_opnum4(u.Argop) {
	case OP_CB_GETATTR:
		return XDR_CB_GETATTR4args(u.Opcbgetattr())
	case OP_CB_RECALL:
		return XDR_CB_RECALL4args(u.Opcbrecall())
	case OP_CB_ILLEGAL:
		return nil
	}
	return nil
}
func (u *Nfs_cb_argop4) XdrUnionBodyName() string {
	switch Nfs_cb_opnum4(u.Argop) {
	case OP_CB_GETATTR:
		return "Opcbgetattr"
	case OP_CB_RECALL:
		return "Opcbrecall"
	case OP_CB_ILLEGAL:
		return ""
	}
	return ""
}
type XdrType_Nfs_cb_argop4 = *Nfs_cb_argop4
func (v *Nfs_cb_argop4) XdrPointer() interface{} { return v }
func (Nfs_cb_argop4) XdrTypeName() string { return "Nfs_cb_argop4" }
func (v Nfs_cb_argop4) XdrValue() interface{} { return v }
func (v *Nfs_cb_argop4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Nfs_cb_argop4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_uint32(&u.Argop).XdrMarshal(x, x.Sprintf("%sargop", name))
	switch Nfs_cb_opnum4(u.Argop) {
	case OP_CB_GETATTR:
		x.Marshal(x.Sprintf("%sopcbgetattr", name), XDR_CB_GETATTR4args(u.Opcbgetattr()))
		return
	case OP_CB_RECALL:
		x.Marshal(x.Sprintf("%sopcbrecall", name), XDR_CB_RECALL4args(u.Opcbrecall()))
		return
	case OP_CB_ILLEGAL:
		return
	}
	XdrPanic("invalid Argop (%v) in Nfs_cb_argop4", u.Argop)
}
func (v *Nfs_cb_argop4) XdrInitialize() {
	var zero uint32
	switch Nfs_cb_opnum4(zero) {
	case OP_CB_GETATTR, OP_CB_RECALL, OP_CB_ILLEGAL:
	default:
		if v.Argop == zero { v.Argop = uint32(OP_CB_GETATTR) }
	}
}
func XDR_Nfs_cb_argop4(v *Nfs_cb_argop4) *Nfs_cb_argop4 { return v}
var _XdrTags_Nfs_cb_resop4 = map[int32]bool{
	XdrToI32(OP_CB_GETATTR): true,
	XdrToI32(OP_CB_RECALL): true,
	XdrToI32(OP_CB_ILLEGAL): true,
}
func (_ Nfs_cb_resop4) XdrValidTags() map[int32]bool {
	return _XdrTags_Nfs_cb_resop4
}
func (u *Nfs_cb_resop4) Opcbgetattr() *CB_GETATTR4res {
	switch Nfs_cb_opnum4(u.Resop) {
	case OP_CB_GETATTR:
		if v, ok := u.U.(*CB_GETATTR4res); ok {
			return v
		} else {
			var zero CB_GETATTR4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_cb_resop4.Opcbgetattr accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_cb_resop4) Opcbrecall() *CB_RECALL4res {
	switch Nfs_cb_opnum4(u.Resop) {
	case OP_CB_RECALL:
		if v, ok := u.U.(*CB_RECALL4res); ok {
			return v
		} else {
			var zero CB_RECALL4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_cb_resop4.Opcbrecall accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u *Nfs_cb_resop4) Opcbillegal() *CB_ILLEGAL4res {
	switch Nfs_cb_opnum4(u.Resop) {
	case OP_CB_ILLEGAL:
		if v, ok := u.U.(*CB_ILLEGAL4res); ok {
			return v
		} else {
			var zero CB_ILLEGAL4res
			u.U = &zero
			return &zero
		}
	default:
		XdrPanic("Nfs_cb_resop4.Opcbillegal accessed when Resop == %v", u.Resop)
		return nil
	}
}
func (u Nfs_cb_resop4) XdrValid() bool {
	switch Nfs_cb_opnum4(u.Resop) {
	case OP_CB_GETATTR,OP_CB_RECALL,OP_CB_ILLEGAL:
		return true
	}
	return false
}
func (u *Nfs_cb_resop4) XdrUnionTag() XdrNum32 {
	return XDR_uint32(&u.Resop)
}
func (u *Nfs_cb_resop4) XdrUnionTagName() string {
	return "Resop"
}
func (u *Nfs_cb_resop4) XdrUnionBody() XdrType {
	switch Nfs_cb_opnum4(u.Resop) {
	case OP_CB_GETATTR:
		return XDR_CB_GETATTR4res(u.Opcbgetattr())
	case OP_CB_RECALL:
		return XDR_CB_RECALL4res(u.Opcbrecall())
	case OP_CB_ILLEGAL:
		return XDR_CB_ILLEGAL4res(u.Opcbillegal())
	}
	return nil
}
func (u *Nfs_cb_resop4) XdrUnionBodyName() string {
	switch Nfs_cb_opnum4(u.Resop) {
	case OP_CB_GETATTR:
		return "Opcbgetattr"
	case OP_CB_RECALL:
		return "Opcbrecall"
	case OP_CB_ILLEGAL:
		return "Opcbillegal"
	}
	return ""
}
type XdrType_Nfs_cb_resop4 = *Nfs_cb_resop4
func (v *Nfs_cb_resop4) XdrPointer() interface{} { return v }
func (Nfs_cb_resop4) XdrTypeName() string { return "Nfs_cb_resop4" }
func (v Nfs_cb_resop4) XdrValue() interface{} { return v }
func (v *Nfs_cb_resop4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (u *Nfs_cb_resop4) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	XDR_uint32(&u.Resop).XdrMarshal(x, x.Sprintf("%sresop", name))
	switch Nfs_cb_opnum4(u.Resop) {
	case OP_CB_GETATTR:
		x.Marshal(x.Sprintf("%sopcbgetattr", name), XDR_CB_GETATTR4res(u.Opcbgetattr()))
		return
	case OP_CB_RECALL:
		x.Marshal(x.Sprintf("%sopcbrecall", name), XDR_CB_RECALL4res(u.Opcbrecall()))
		return
	case OP_CB_ILLEGAL:
		x.Marshal(x.Sprintf("%sopcbillegal", name), XDR_CB_ILLEGAL4res(u.Opcbillegal()))
		return
	}
	XdrPanic("invalid Resop (%v) in Nfs_cb_resop4", u.Resop)
}
func (v *Nfs_cb_resop4) XdrInitialize() {
	var zero uint32
	switch Nfs_cb_opnum4(zero) {
	case OP_CB_GETATTR, OP_CB_RECALL, OP_CB_ILLEGAL:
	default:
		if v.Resop == zero { v.Resop = uint32(OP_CB_GETATTR) }
	}
}
func XDR_Nfs_cb_resop4(v *Nfs_cb_resop4) *Nfs_cb_resop4 { return v}
type _XdrVec_unbounded_Nfs_cb_argop4 []Nfs_cb_argop4
func (_XdrVec_unbounded_Nfs_cb_argop4) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Nfs_cb_argop4) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Nfs_cb_argop4 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Nfs_cb_argop4 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Nfs_cb_argop4) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Nfs_cb_argop4) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Nfs_cb_argop4, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Nfs_cb_argop4) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Nfs_cb_argop4(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Nfs_cb_argop4) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Nfs_cb_argop4) XdrTypeName() string { return "Nfs_cb_argop4<>" }
func (v *_XdrVec_unbounded_Nfs_cb_argop4) XdrPointer() interface{} { return (*[]Nfs_cb_argop4)(v) }
func (v _XdrVec_unbounded_Nfs_cb_argop4) XdrValue() interface{} { return ([]Nfs_cb_argop4)(v) }
func (v *_XdrVec_unbounded_Nfs_cb_argop4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_CB_COMPOUND4args = *CB_COMPOUND4args
func (v *CB_COMPOUND4args) XdrPointer() interface{} { return v }
func (CB_COMPOUND4args) XdrTypeName() string { return "CB_COMPOUND4args" }
func (v CB_COMPOUND4args) XdrValue() interface{} { return v }
func (v *CB_COMPOUND4args) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CB_COMPOUND4args) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%stag", name), XDR_Utf8str_cs(&v.Tag))
	x.Marshal(x.Sprintf("%sminorversion", name), XDR_Uint32_t(&v.Minorversion))
	x.Marshal(x.Sprintf("%scallback_ident", name), XDR_Uint32_t(&v.Callback_ident))
	x.Marshal(x.Sprintf("%sargarray", name), (*_XdrVec_unbounded_Nfs_cb_argop4)(&v.Argarray))
}
func XDR_CB_COMPOUND4args(v *CB_COMPOUND4args) *CB_COMPOUND4args { return v }
type _XdrVec_unbounded_Nfs_cb_resop4 []Nfs_cb_resop4
func (_XdrVec_unbounded_Nfs_cb_resop4) XdrBound() uint32 {
	const bound uint32 = 4294967295 // Force error if not const or doesn't fit
	return bound
}
func (_XdrVec_unbounded_Nfs_cb_resop4) XdrCheckLen(length uint32) {
	if length > uint32(4294967295) {
		XdrPanic("_XdrVec_unbounded_Nfs_cb_resop4 length %d exceeds bound 4294967295", length)
	} else if int(length) < 0 {
		XdrPanic("_XdrVec_unbounded_Nfs_cb_resop4 length %d exceeds max int", length)
	}
}
func (v _XdrVec_unbounded_Nfs_cb_resop4) GetVecLen() uint32 { return uint32(len(v)) }
func (v *_XdrVec_unbounded_Nfs_cb_resop4) SetVecLen(length uint32) {
	v.XdrCheckLen(length)
	if int(length) <= cap(*v) {
		if int(length) != len(*v) {
			*v = (*v)[:int(length)]
		}
		return
	}
	newcap := 2*cap(*v)
	if newcap < int(length) { // also catches overflow where 2*cap < 0
		newcap = int(length)
	} else if bound := uint(4294967295); uint(newcap) > bound {
		if int(bound) < 0 {
			bound = ^uint(0) >> 1
		}
		newcap = int(bound)
	}
	nv := make([]Nfs_cb_resop4, int(length), newcap)
	copy(nv, *v)
	*v = nv
}
func (v *_XdrVec_unbounded_Nfs_cb_resop4) XdrMarshalN(x XDR, name string, n uint32) {
	v.XdrCheckLen(n)
	for i := 0; i < int(n); i++ {
		if (i >= len(*v)) {
			v.SetVecLen(uint32(i+1))
		}
		XDR_Nfs_cb_resop4(&(*v)[i]).XdrMarshal(x, x.Sprintf("%s[%d]", name, i))
	}
	if int(n) < len(*v) {
		*v = (*v)[:int(n)]
	}
}
func (v *_XdrVec_unbounded_Nfs_cb_resop4) XdrRecurse(x XDR, name string) {
	size := XdrSize{ Size: uint32(len(*v)), Bound: 4294967295 }
	x.Marshal(name, &size)
	v.XdrMarshalN(x, name, size.Size)
}
func (_XdrVec_unbounded_Nfs_cb_resop4) XdrTypeName() string { return "Nfs_cb_resop4<>" }
func (v *_XdrVec_unbounded_Nfs_cb_resop4) XdrPointer() interface{} { return (*[]Nfs_cb_resop4)(v) }
func (v _XdrVec_unbounded_Nfs_cb_resop4) XdrValue() interface{} { return ([]Nfs_cb_resop4)(v) }
func (v *_XdrVec_unbounded_Nfs_cb_resop4) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
type XdrType_CB_COMPOUND4res = *CB_COMPOUND4res
func (v *CB_COMPOUND4res) XdrPointer() interface{} { return v }
func (CB_COMPOUND4res) XdrTypeName() string { return "CB_COMPOUND4res" }
func (v CB_COMPOUND4res) XdrValue() interface{} { return v }
func (v *CB_COMPOUND4res) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v *CB_COMPOUND4res) XdrRecurse(x XDR, name string) {
	if name != "" {
		name = x.Sprintf("%s.", name)
	}
	x.Marshal(x.Sprintf("%sstatus", name), XDR_Nfsstat4(&v.Status))
	x.Marshal(x.Sprintf("%stag", name), XDR_Utf8str_cs(&v.Tag))
	x.Marshal(x.Sprintf("%sresarray", name), (*_XdrVec_unbounded_Nfs_cb_resop4)(&v.Resarray))
}
func XDR_CB_COMPOUND4res(v *CB_COMPOUND4res) *CB_COMPOUND4res { return v }

type xdrProc_CB_NULL struct {
	Arg *XdrVoid
	Res *XdrVoid
}
func (xdrProc_CB_NULL) Prog() uint32 { return 1073741824 }
func (xdrProc_CB_NULL) Vers() uint32 { return 1 }
func (xdrProc_CB_NULL) Proc() uint32 { return 0 }
func (xdrProc_CB_NULL) ProgName() string { return "NFS4_CALLBACK" }
func (xdrProc_CB_NULL) VersName() string { return "NFS_CB" }
func (xdrProc_CB_NULL) ProcName() string { return "CB_NULL" }
func (p *xdrProc_CB_NULL) GetArg() XdrType {
	if p.Arg == nil {
		p.Arg = new(XdrVoid)
	}
	return XDR_XdrVoid(p.Arg)
}
func (p *xdrProc_CB_NULL) GetRes() XdrType {
	if p.Res == nil {
		p.Res = new(XdrVoid)
	}
	return XDR_XdrVoid(p.Res)
}
var _ XdrProc = &xdrProc_CB_NULL{} // XXX

type xdrSrvProc_CB_NULL struct {
	xdrProc_CB_NULL
	Srv NFS_CB
}
func (p *xdrSrvProc_CB_NULL) SetContext(ctx context.Context) {
	if wc, ok := p.Srv.(interface {
		WithContext(context.Context) NFS_CB
	}); ok {
		p.Srv = wc.WithContext(ctx)
	}
}
func (p *xdrSrvProc_CB_NULL) Do() {
	p.Srv.CB_NULL()
}
var _ XdrSrvProc = &xdrSrvProc_CB_NULL{} // XXX

type xdrProc_CB_COMPOUND struct {
	Arg *CB_COMPOUND4args
	Res *CB_COMPOUND4res
}
func (xdrProc_CB_COMPOUND) Prog() uint32 { return 1073741824 }
func (xdrProc_CB_COMPOUND) Vers() uint32 { return 1 }
func (xdrProc_CB_COMPOUND) Proc() uint32 { return 1 }
func (xdrProc_CB_COMPOUND) ProgName() string { return "NFS4_CALLBACK" }
func (xdrProc_CB_COMPOUND) VersName() string { return "NFS_CB" }
func (xdrProc_CB_COMPOUND) ProcName() string { return "CB_COMPOUND" }
func (p *xdrProc_CB_COMPOUND) GetArg() XdrType {
	if p.Arg == nil {
		p.Arg = new(CB_COMPOUND4args)
	}
	return XDR_CB_COMPOUND4args(p.Arg)
}
func (p *xdrProc_CB_COMPOUND) GetRes() XdrType {
	if p.Res == nil {
		p.Res = new(CB_COMPOUND4res)
	}
	return XDR_CB_COMPOUND4res(p.Res)
}
var _ XdrProc = &xdrProc_CB_COMPOUND{} // XXX

type xdrSrvProc_CB_COMPOUND struct {
	xdrProc_CB_COMPOUND
	Srv NFS_CB
}
func (p *xdrSrvProc_CB_COMPOUND) SetContext(ctx context.Context) {
	if wc, ok := p.Srv.(interface {
		WithContext(context.Context) NFS_CB
	}); ok {
		p.Srv = wc.WithContext(ctx)
	}
}
func (p *xdrSrvProc_CB_COMPOUND) Do() {
	r := p.Srv.CB_COMPOUND(*p.Arg)
	p.Res = &r

}
var _ XdrSrvProc = &xdrSrvProc_CB_COMPOUND{} // XXX

func init() {
	XdrCatalog[1073741824<<32|1] = func(p uint32) XdrProc {
		switch(p) {
		case 0:
			return &xdrProc_CB_NULL{}
		case 1:
			return &xdrProc_CB_COMPOUND{}
		}
		return nil
	}
}

type NFS_CB_Server struct {
	Srv NFS_CB
}
func (NFS_CB_Server) Prog() uint32 { return 1073741824 }
func (NFS_CB_Server) Vers() uint32 { return 1 }
func (NFS_CB_Server) ProgName() string { return "NFS4_CALLBACK" }
func (NFS_CB_Server) VersName() string { return "NFS_CB" }
func (s NFS_CB_Server) GetProc(p uint32) XdrSrvProc {
	switch p {
	case 0:  // CB_NULL
		return &xdrSrvProc_CB_NULL{ Srv: s.Srv }
	case 1:  // CB_COMPOUND
		return &xdrSrvProc_CB_COMPOUND{ Srv: s.Srv }
	default:
		return nil
	}
}
var _ XdrSrv = NFS_CB_Server{} // XXX

type NFS_CB_Client struct {
	Send XdrSendCall
	Ctx context.Context
}
var _ NFS_CB = NFS_CB_Client{} // XXX
func (c NFS_CB_Client) WithContext(ctx context.Context) NFS_CB {
	c.Ctx = ctx
	return c
}
func (c NFS_CB_Client) CB_NULL() {
	var proc xdrProc_CB_NULL
	if err := c.Send.SendCall(c.Ctx, &proc); err != nil {
		panic(err)
	}
}
func (c NFS_CB_Client) CB_COMPOUND(a1 CB_COMPOUND4args) CB_COMPOUND4res {
	var proc xdrProc_CB_COMPOUND
	proc.Arg = &a1
	if err := c.Send.SendCall(c.Ctx, &proc); err != nil {
		panic(err)
	}
	return *proc.Res
}

//
// begin boilerplate
//

// Types passed to the XDR Marshal method implementing the XdrType
// interface.  Pointers to some generated types T already implement
// the interface.  However, since built-in types such as string and
// int32 cannot implement interfaces, each type T has a function
// XDR_T(*T) that returns some type implementing XdrType.  These
// XdrType interfaces also encode limits on string and vector sizes
// and simplify code by collapsing similar cases (e.g., all 32-bit
// numbers are cast to a pointer implementing XdrNum32).
//
// For most XdrType instances, XdrPointer() and XdrValue() provide
// access to the underlying type (which might not implement XdrType),
// with the following exceptions:
//
// * opaque[] (fixed-length arrays of bytes) are returned as
// XdrArrayOpaque (by XdrValue()) or nil (by XdrPointer()).  This is
// because XdrArrayOpaque wraps a byte slice rather than an actual
// array.  One generally doesn't want to pass arrays around; moreover,
// getting a pointer to the actual array provides less information,
// because one can't test for arrays in a type switch without knowing
// the exact length of the array, while one can always dynamically
// test the length of a slice.
//
// * Pointer types, in their XdrRecurse methods, marshal a special
// XdrNum32 type of 0 or 1 to record whether the pointer is nil or the
// value is present.  Since this bool does not exist, XdrPointer()
// returns nil (while XdrValue returns a bool).
//
// * For arrays, XdrValue() passes a slice, rather than the full
// array, so as to avoid copying the array.
type XdrType interface {
	// Return a string describing the name of the type (which will
	// reflect the name of a typedef).
	XdrTypeName() string

	// Return the underlying native representation of an XdrType
	// (e.g., int32 for an XdrInt32).
	XdrValue() interface{}

	// Return a pointer to the underlying native representation of an
	// XdrType (often just the same type as the XdrType, but sometimes
	// not, e.g., for primitive types that can't have methods
	// defined).
	XdrPointer() interface{}

	// Calls x.Marshal(name, v).
	XdrMarshal(XDR, string)
}

// The interface through which values are serialized, printed, etc.
type XDR interface {
	// A function that gets called for each value to be marshalled.
	// The val XdrType argument will be one of the following:
	//
	// * A pointer type implementing XdrNum32 for bool, int, unsigned
	//   int, float, the size of variable-length arrays except string
	//   and opaque, and enums.  In the case of enums, that instance
	//   will just be a pointer to the enum.  In the case of the other
	//   types, it will be a pointer to a defined type that implements
	//   the XdrNum32 interface (since plain go types cannot implement
	//   methods)--e.g., *XdrUint32 for unsigned int.  Variable array
	//   sizes are passed as *XdrSize, which enforces the bound.
	//
	// * A pointer type implementing XdrNum64 for hyper, unsigned
	//   hyper, and double.  These are user-defined versions of int64,
	//   uint64, and float64, called XdrInt64, XdrUint64, and
	//   XdrFloat64, respectively.
	//
	// * An instance of XdrBytes for strings and opaque.
	//   Specifically, strings are passed as XdrString, and
	//   variable-length opaque<> vectors are passed as XdrVecOpaque,
	//   both of which implement XdrVarBytes.
	//
	// * An XdrArrayOpaque containing a slice referencing a byte array
	//   for fixed-length opaque[].  XdrArrayOpaque implements
	//   XdrBytes, but not XdrVarBytes.
	//
	// * An instance of XdrAggregate for structs, unions, and
	//   pointers.  Note that structs and unions are just passed as
	//   pointers to the underlying structures (which all implement
	//   XdrAggregate).  Pointers are passed as an XdrPtr interface
	//   implemented by a defined pointer type (since plain pointers
	//   cannot have methods).
	//
	// Note that the Marshal method is responsible for recursing into
	// XdrAggregate instance by calling the XdrRecurse method.
	// Requiring the Marshal method to recurse manually allows it to
	// refrain from recursing in cases where it needs to special-case
	// the handling of specific types.
	Marshal(name string, val XdrType)

	// This method should just be fmt.Sprintf for XDRs that use name.
	// Those that don't use name can use a trivial method returning ""
	Sprintf(string, ...interface{}) string
}

// The error thrown by marshaling functions when data has a bad value.
type XdrError string
func (v XdrError) Error() string { return string(v) }

// Throws an XdrError.
func XdrPanic(s string, args ...interface{}) {
	panic(XdrError(fmt.Sprintf(s, args...)))
}

// RFC4506 defines bool as equivalent to an enum with values all-caps
// TRUE and FALSE.  For convenience, we represent an XDR bool as a Go
// bool instead, and so define these constants for use in union cases.
// (XDR source files should not use lower-case true and false, as
// these will not work in other languages or with other XDR
// compilers.)
const (
	TRUE = true
	FALSE = false
)

// Unfortunately, you can't cast a bool to an int.  Hence, in
// situations like a union discriminant where we don't know if a type
// is equivalent to bool or not, then, short of using reflection, this
// is how we have to convert to an integer.  Note that this expects
// types int, [u]int32, enum, and bool, rather than pointers to these
// types.
func XdrToI32(i interface{}) int32 {
	switch v := i.(type) {
	case interface{ GetU32() uint32 }:
		return int32(v.GetU32())
	case int32:
		return v
	case uint32:
		return int32(v)
	case int:
		return int32(v)
	case bool:
		if v {
			return 1
		}
		return 0
	}
	panic(XdrError(fmt.Sprintf("XdrToI32: bad type %T", i)))
}

//
// User-defined types used to place methods on basic types
//

// All quantities that should be serialized as 32-bit numbers
// (including bools, enums, union discriminants, the bit saying
// whether or not a pointer is NULL, floats, and vector lenghts) are
// passed to the XDR.Marshal function as a pointer to a defined type
// implementing the XdrNum32 interface.  The one exception is string<>
// and opaque<>, for which it is the job of XDR.Marshal to serialize
// the 32-bit length.
type XdrNum32 interface {
	XdrType
	fmt.Stringer
	fmt.Scanner
	GetU32() uint32
	SetU32(uint32)
}

// Enums additionally provide access to a map of values to names.  You
// generally don't need to invoke the XdrEnumNames() method (since the
// String and Scan methods already access the underlying maps), but
// the presence of this method can be useful to differentiate enums
// from other XdrNum32 types.
type XdrEnum interface {
	XdrNum32
	XdrEnumNames() map[int32]string
}

// All 64-bit numbers (hyper, unsigned hyper, and double) are passed
// to XDR.Marshal as a pointer to a defined type implementing
// XdrNum64.
type XdrNum64 interface {
	XdrType
	fmt.Stringer
	fmt.Scanner
	GetU64() uint64
	SetU64(uint64)
}

// A common interface implemented by XdrString, XdrVecOpaque, and
// XdrArrayOpaque (and hence used to operate on the XdrTypes
// corresponding to value os ftype string<>, opaque<>, and opaque[]).
type XdrBytes interface {
	XdrType
	GetByteSlice() []byte
}

// A common interface implemented by XdrString and XdrVecOpaque, the
// XdrTypes for opaque<> and string<>.  Since XdrVarBytes is a subtype
// of XdrBytes, Marshal functions that want to distinguish between
// opaque<> and opaque[] should first try a type assertion for
// XdrVarBytes (to check for opaque<>) and then if that fails try
// XdrBytes (to check for opaque[]).
type XdrVarBytes interface {
	XdrBytes
	XdrBound() uint32
	SetByteSlice([]byte)
}

// Any struct, union, pointer, or variable-length array type (except
// opaque<> and string<>) is passed to XDR.Marshal as a pointer
// implementing the XdrAggregate interface.  It is the responsibility
// of the XDR.Marshal function to call the XdrRecurse method so as to
// recurse into the data structure.  Placing reponsibility on
// XDR.Marshal for recursing allows a custom XDR to prune the
// serialization at particular types (e.g., for pretty-printing a
// partucular struct in a non-standard way).
type XdrAggregate interface {
	XdrType
	XdrRecurse(XDR, string)
}

// A union type is an XdrAggregate with extra methods for individually
// accessing the tag and active branch.
type XdrUnion interface {
	XdrAggregate
	XdrValid() bool
	XdrValidTags() map[int32]bool
	XdrUnionTag() XdrNum32
	XdrUnionTagName() string
	XdrUnionBody() XdrType
	XdrUnionBodyName() string
}

// Any pointer type is converted to an XdrType implementing the XdrPtr
// interface for marshaling.  Note XdrPtr is a subtype of
// XdrAggregate.  When a Marshal function does nothing special for
// XdrPtr and treats the XdrPtr like any other XdrAggregate (calling
// XdrRecurse), the Marshal function will then get called one or two
// more times, first with an XdrSize (implementing XdrNum32) to
// marshal the non-NULL bit, and then again with the underlying value
// if the pointer is non-NULL.  An XDR.Marshal function that wants to
// special case pointers can access the present bit from the
// GetPresent and SetPresent methods, then bypass marshaling of the
// bit by calling XdrMarshalValue instead of XdrRecurse.
type XdrPtr interface {
	// Marshals first the present/not-present bool, then if true, the
	// underlying value.
	XdrAggregate

	GetPresent() bool
	SetPresent(bool)

	// If the present/not-present bool is false, this function does
	// nothing.  Otherwise, it marshals just the value, not the bit.
	XdrMarshalValue(XDR, string)
}

// Any vector type is passed as a pointer to a user-defined slice type
// that implements the XdrVec interface.  XdrVec is a superset of
// XdrAggregate, so calling XdrRecurse will recurse to call
// XDR.Marshal first on the size (of type XdrSize), then on each
// element of the slice.  An XDR.Marshal function can manually marshal
// the size and then call XdrMarshalN to marshal n vector elements.
// (When deserializing, it is advisable *not* to call SetVecLen before
// calling XdrMarshalN in case the length is huge and would exhaust
// memory; XdrMarshalN gradually grows the slice size as needed so as
// to throw a premature EOF error if N is larger than the actual input
// data.)
type XdrVec interface {
	XdrAggregate
	XdrBound() uint32
	GetVecLen() uint32
	SetVecLen(uint32)
	XdrMarshalN(XDR, string, uint32)
}

// Any array type is passed as a pointer to a user-defined array
// supporting the XdrArray interface.  This is a subtype of
// XdrAggregate, and so supports recursing to marshal each individual
// array member.
type XdrArray interface {
	XdrAggregate
	XdrArraySize() uint32
}

type XdrTypedef interface {
	XdrType
	XdrUnwrap() XdrType
}

// Unwrap typedefs to obtain the underlying XdrType.
func XdrBaseType(v XdrType) XdrType {
	for {
		t, ok := v.(XdrTypedef)
		if !ok {
			return v
		}
		v = t.XdrUnwrap()
	}
}

// Returns true for A-Z, a-z, 0-9, and _.  (Used by the generated code
// that implements Scanner for enums.)
func XdrSymChar(r rune) bool {
	return (r|0x20 >= 'a' && r|0x20 <= 'z') ||
		(r >= '0' && r <= '9') || r == '_'
}

// An XdrType that marshals as zero bytes, and hence is used to
// represent void argument and return types of functions.
type XdrVoid struct{}
type XdrType_void = *XdrVoid
func (XdrVoid) XdrTypeName() string { return "void" }
func (XdrVoid) XdrValue() interface{} { return nil }
func (XdrVoid) XdrPointer() interface{} { return nil }
func (XdrVoid) XdrMarshal(XDR, string) {}
func XDR_XdrVoid(v *XdrVoid) XdrType_void { return v }

// The XdrType that bool gets turned into for marshaling.
type XdrBool bool
type XdrType_bool = *XdrBool
func (XdrBool) XdrTypeName() string { return "bool" }
func (v XdrBool) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrBool) Scan(ss fmt.ScanState, r rune) error {
	_, err := fmt.Fscanf(ss, string([]rune{'%', r}), v.XdrPointer())
	return err
}
func (v XdrBool) GetU32() uint32 { if v { return 1 }; return 0 }
func (v *XdrBool) SetU32(nv uint32) {
	switch nv {
	case 0:
		*v = false
	case 1:
		*v = true
	default:
		XdrPanic("bool must be 0 or 1")
	}
}
func (v *XdrBool) XdrPointer() interface{} { return (*bool)(v) }
func (v XdrBool) XdrValue() interface{} { return bool(v) }
func (v *XdrBool) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_bool(v *bool) *XdrBool { return (*XdrBool)(v) }

// The XdrType that int gets converted to for marshaling.
type XdrInt32 int32
type XdrType_int32 = *XdrInt32
func (XdrInt32) XdrTypeName() string { return "int32" }
func (v XdrInt32) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrInt32) Scan(ss fmt.ScanState, r rune) error {
	_, err := fmt.Fscanf(ss, string([]rune{'%', r}), v.XdrPointer())
	return err
}
func (v XdrInt32) GetU32() uint32 { return uint32(v) }
func (v *XdrInt32) SetU32(nv uint32) { *v = XdrInt32(nv) }
func (v *XdrInt32) XdrPointer() interface{} { return (*int32)(v) }
func (v XdrInt32) XdrValue() interface{} { return int32(v) }
func (v *XdrInt32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_int32(v *int32) *XdrInt32 { return (*XdrInt32)(v) }

// The XdrType that unsigned int gets converted to for marshaling.
type XdrUint32 uint32
type XdrType_uint32 = *XdrUint32
func (XdrUint32) XdrTypeName() string { return "uint32" }
func (v XdrUint32) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrUint32) Scan(ss fmt.ScanState, r rune) error {
	_, err := fmt.Fscanf(ss, string([]rune{'%', r}), v.XdrPointer())
	return err
}
func (v XdrUint32) GetU32() uint32 { return uint32(v) }
func (v *XdrUint32) SetU32(nv uint32) { *v = XdrUint32(nv) }
func (v *XdrUint32) XdrPointer() interface{} { return (*uint32)(v) }
func (v XdrUint32) XdrValue() interface{} { return uint32(v) }
func (v *XdrUint32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_uint32(v *uint32) *XdrUint32 { return (*XdrUint32)(v) }

// The XdrType that float gets converted to for marshaling.
type XdrFloat32 float32
type XdrType_float32 = *XdrFloat32
func (XdrFloat32) XdrTypeName() string { return "float32" }
func (v XdrFloat32) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrFloat32) Scan(ss fmt.ScanState, r rune) error {
	_, err := fmt.Fscanf(ss, string([]rune{'%', r}), v.XdrPointer())
	return err
}
func (v XdrFloat32) GetU32() uint32 { return math.Float32bits(float32(v)) }
func (v *XdrFloat32) SetU32(nv uint32) {
	*v = XdrFloat32(math.Float32frombits(nv))
}
func (v *XdrFloat32) XdrPointer() interface{} { return (*float32)(v) }
func (v XdrFloat32) XdrValue() interface{} { return float32(v) }
func (v *XdrFloat32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_float32(v *float32) *XdrFloat32 { return (*XdrFloat32)(v) }

// This XdrType is used to marshal the length of vectors and the
// present/not-present value of pointers.
type XdrSize struct {
	Size uint32
	Bound uint32
}
func (v XdrSize) String() string { return fmt.Sprintf("%v", v.Size) }
func (v *XdrSize) Scan(ss fmt.ScanState, r rune) (err error) {
	defer func() {
		if err == nil {
			err = recover().(error)
		}
	}()
	var nv uint32
	if _, err := fmt.Fscanf(ss, string([]rune{'%', r}), &nv); err != nil {
		return err
	}
	v.SetU32(nv)
	return
}
func (v XdrSize) GetU32() uint32 { return v.Size }
func (v *XdrSize) SetU32(nv uint32) {
	if nv > v.Bound {
		XdrPanic("size %d greater than bound %d", nv, v.Bound)
	} else if int(nv) < 0 {
		XdrPanic("size %d greater than max slice len", nv)
	}
	v.Size = nv
}
func (XdrSize) XdrTypeName() string { return "len" }
func (v *XdrSize) XdrPointer() interface{} { return &v.Size }
func (v XdrSize) XdrValue() interface{} { return v.Size }
func (v *XdrSize) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func (v XdrSize) XdrBound() uint32 { return v.Bound }

// The XdrType that hyper gets converted to for marshaling.
type XdrInt64 int64
type XdrType_int64 = *XdrInt64
func (XdrInt64) XdrTypeName() string { return "int64" }
func (v XdrInt64) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrInt64) Scan(ss fmt.ScanState, r rune) error {
	_, err := fmt.Fscanf(ss, string([]rune{'%', r}), v.XdrPointer())
	return err
}
func (v XdrInt64) GetU64() uint64 { return uint64(v) }
func (v *XdrInt64) SetU64(nv uint64) { *v = XdrInt64(nv) }
func (v *XdrInt64) XdrPointer() interface{} { return (*int64)(v) }
func (v XdrInt64) XdrValue() interface{} { return int64(v) }
func (v *XdrInt64) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_int64(v *int64) *XdrInt64 { return (*XdrInt64)(v) }

// The XdrType that unsigned hyper gets converted to for marshaling.
type XdrUint64 uint64
type XdrType_uint64 = *XdrUint64
func (XdrUint64) XdrTypeName() string { return "uint64" }
func (v XdrUint64) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrUint64) Scan(ss fmt.ScanState, r rune) error {
	_, err := fmt.Fscanf(ss, string([]rune{'%', r}), v.XdrPointer())
	return err
}
func (v XdrUint64) GetU64() uint64 { return uint64(v) }
func (v *XdrUint64) SetU64(nv uint64) { *v = XdrUint64(nv) }
func (v *XdrUint64) XdrPointer() interface{} { return (*uint64)(v) }
func (v XdrUint64) XdrValue() interface{} { return uint64(v) }
func (v *XdrUint64) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_uint64(v *uint64) *XdrUint64 { return (*XdrUint64)(v) }

// The XdrType that double gets converted to for marshaling.
type XdrFloat64 float64
type XdrType_float64 = *XdrFloat64
func (XdrFloat64) XdrTypeName() string { return "float64" }
func (v XdrFloat64) String() string { return fmt.Sprintf("%v", v.XdrValue()) }
func (v *XdrFloat64) Scan(ss fmt.ScanState, r rune) error {
	_, err := fmt.Fscanf(ss, string([]rune{'%', r}), v.XdrPointer())
	return err
}
func (v XdrFloat64) GetU64() uint64 { return math.Float64bits(float64(v)) }
func (v *XdrFloat64) SetU64(nv uint64) {
	*v = XdrFloat64(math.Float64frombits(nv))
}
func (v *XdrFloat64) XdrPointer() interface{} { return (*float64)(v) }
func (v XdrFloat64) XdrValue() interface{} { return float64(v) }
func (v *XdrFloat64) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
func XDR_float64(v *float64) *XdrFloat64 { return (*XdrFloat64)(v) }

// The XdrType that strings get converted to for marshaling.
type XdrString struct {
	Str *string
	Bound uint32
}
func (v XdrString) String() string { return fmt.Sprintf("%q", *v.Str) }
func (v XdrString) Scan(ss fmt.ScanState, _ rune) error {
	var s string
	if _, err := fmt.Fscanf(ss, "%q", &s); err != nil {
		return err
	} else if int64(len(s)) > int64(v.Bound) {
		return XdrError(fmt.Sprintf("Cannot store %d bytes in string<%d>",
			len(s), v.Bound))
	}
	*v.Str = s
	return nil
}
func (v XdrString) XdrBound() uint32 { return v.Bound }
func (v XdrString) GetString() string { return *v.Str }
func (v XdrString) SetString(s string) {
	if uint(len(s)) > uint(v.Bound) {
		XdrPanic("Cannot store %d bytes in string<%d>", len(s), v.Bound)
	}
	*v.Str = s
}
func (v XdrString) GetByteSlice() []byte { return ([]byte)(*v.Str) }
func (v XdrString) SetByteSlice(bs []byte) {
	if uint(len(bs)) > uint(v.Bound) {
		XdrPanic("Cannot store %d bytes in string<%d>", len(bs), v.Bound)
	}
	*v.Str = string(bs)
}
func (XdrString) XdrTypeName() string { return "string" }
func (v XdrString) XdrPointer() interface{} { return v.Str }
func (v XdrString) XdrValue() interface{} { return *v.Str }
func (v XdrString) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

// The XdrType that opaque<> gets converted to for marshaling.
type XdrVecOpaque struct {
	Bytes *[]byte
	Bound uint32
}
func (v XdrVecOpaque) String() string {
	return fmt.Sprintf("%x", []byte(*v.Bytes))
}
func (v XdrVecOpaque) Scan(ss fmt.ScanState, _ rune) error {
	var bs []byte
	_, err := fmt.Fscanf(ss, "%x", &bs)
	if err == nil {
		v.SetByteSlice(bs)
	}
	return err
}
func (v XdrVecOpaque) GetByteSlice() []byte { return *v.Bytes }
func (v XdrVecOpaque) XdrBound() uint32 { return v.Bound }
func (v XdrVecOpaque) SetByteSlice(bs []byte) {
	if uint(len(bs)) > uint(v.Bound) {
		XdrPanic("Cannot store %d bytes in string<%d>", len(bs), v.Bound)
	}
	*v.Bytes = bs
}
func (XdrVecOpaque) XdrTypeName() string { return "opaque<>" }
func (v XdrVecOpaque) XdrPointer() interface{} { return v.Bytes }
func (v XdrVecOpaque) XdrValue() interface{} { return *v.Bytes }
func (v XdrVecOpaque) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }

// Helper function for scanning fix-size opaque arrays.
func XdrArrayOpaqueScan(dest []byte, ss fmt.ScanState, _ rune) error {
	var bs []byte
	_, err := fmt.Fscanf(ss, "%x", &bs)
	if err != nil {
		return err
	} else if len(bs) != len (dest) {
		return XdrError("Wrong number of bytes when scanning opaque[]")
	}
	copy(dest, bs)
	return nil
}

// The interface of XdrTypes of opaque[n] for all n
type XdrArrayOpaque interface {
	XdrBytes
	XdrArraySize() uint32
}


//
// Basic implementations of XDR interface
//

// Back end that renders an XDR data structure as simple text.
// Example:
//
//    XDR_MyType(&myVal).XdrMarshal(&XdrPrint{os.Stdout}, "")
//
type XdrPrint struct {
	Out io.Writer
}

// Generic function that converts any compiled XDR type to a
// multi-line string.  Useful for debugging.
func XdrToString(t XdrType) string {
	out := &strings.Builder{}
	t.XdrMarshal(&XdrPrint{out}, "")
	return out.String()
}

func (xp XdrPrint) Sprintf(f string, args ...interface{}) string {
	return fmt.Sprintf(f, args...)
}

func (xp XdrPrint) Marshal(name string, i XdrType) {
	switch v := i.(type) {
	case fmt.Stringer:
		fmt.Fprintf(xp.Out, "%s: %s\n", name, v.String())
	case XdrPtr:
		fmt.Fprintf(xp.Out, "%s.present: %v\n", name, v.GetPresent())
		v.XdrMarshalValue(xp, fmt.Sprintf("(*%s)", name))
	case XdrVec:
		fmt.Fprintf(xp.Out, "%s.len: %d\n", name, v.GetVecLen())
		v.XdrMarshalN(xp, name, v.GetVecLen())
	case XdrAggregate:
		v.XdrRecurse(xp, name)
	default:
		fmt.Fprintf(xp.Out, "%s: %v\n", name, i)
	}
}

var xdrZerofill [4][]byte = [...][]byte{
	{}, {0,0,0}, {0,0}, {0},
}

func xdrPutBytes(out io.Writer, val []byte) {
	out.Write(val)
	out.Write(xdrZerofill[len(val)&3])
}

func xdrPut32(out io.Writer, val uint32) {
	b := make([]byte, 4)
	binary.BigEndian.PutUint32(b, val)
	out.Write(b)
}

func xdrPut64(out io.Writer, val uint64) {
	b := make([]byte, 8)
	binary.BigEndian.PutUint64(b, val)
	out.Write(b)
}


// XDR that marshals to canonical binary format
type XdrOut struct {
	Out io.Writer
}

func (xp XdrOut) Sprintf(f string, args ...interface{}) string {
	return ""
}

func (xo XdrOut) Marshal(name string, i XdrType) {
	switch v := i.(type) {
	case XdrNum32:
		xdrPut32(xo.Out, v.GetU32())
	case XdrNum64:
		xdrPut64(xo.Out, v.GetU64())
	case XdrString:
		s := v.GetString()
		xdrPut32(xo.Out, uint32(len(s)))
		io.WriteString(xo.Out, s)
		xo.Out.Write(xdrZerofill[len(s)&3])
	case XdrVarBytes:
		xdrPut32(xo.Out, uint32(len(v.GetByteSlice())))
		xdrPutBytes(xo.Out, v.GetByteSlice())
	case XdrBytes:
		xdrPutBytes(xo.Out, v.GetByteSlice())
	case XdrAggregate:
		v.XdrRecurse(xo, name)
	default:
		panic(fmt.Sprintf("XdrOut: unhandled type %T", i))
	}
}

func xdrReadN(in io.Reader, n uint32) []byte {
	var b bytes.Buffer
	if _, err := io.CopyN(&b, in, int64(n)); err != nil {
		XdrPanic(err.Error())
	}
	return b.Bytes()
}

func xdrReadPad(in io.Reader, n uint32) {
	if n & 3 != 0 {
		got := xdrReadN(in, 4-(n&3))
		for _, b := range got {
			if b != 0 {
				XdrPanic("padding contained non-zero bytes")
			}
		}
	}
}

func xdrGet32(in io.Reader) uint32 {
	b := xdrReadN(in, 4)
	return binary.BigEndian.Uint32(b)
}

func xdrGet64(in io.Reader) uint64 {
	b := xdrReadN(in, 8)
	return binary.BigEndian.Uint64(b)
}


// XDR that unmarshals from canonical binary format
type XdrIn struct {
	In io.Reader
}

func (xp XdrIn) Sprintf(f string, args ...interface{}) string {
	return ""
}

func (xi XdrIn) Marshal(name string, i XdrType) {
	switch v := i.(type) {
	case XdrNum32:
		v.SetU32(xdrGet32(xi.In))
	case XdrNum64:
		v.SetU64(xdrGet64(xi.In))
	case XdrVarBytes:
		n := xdrGet32(xi.In)
		v.SetByteSlice(xdrReadN(xi.In, n))
		xdrReadPad(xi.In, n)
	case XdrBytes:
		if _, err := io.ReadFull(xi.In, v.GetByteSlice()); err != nil {
			panic(err)
		}
		xdrReadPad(xi.In, uint32(len(v.GetByteSlice())))
	case XdrAggregate:
		v.XdrRecurse(xi, name)
	}
}


//
// RFC5531 RPC support
//

// Interface for a data structure containing the argument and result
// types of a call.
type XdrProc interface {
	Prog() uint32
	Vers() uint32
	Proc() uint32
	ProgName() string
	VersName() string
	ProcName() string
	GetArg() XdrType
	GetRes() XdrType
}

// Interface for a data structure containing argument and results of a
// procedure plus a way to invoke the procedure on an instance of the
// RPC version.  In other words, Do() actually performs the work of an
// RPC on the server side.
type XdrSrvProc interface {
	XdrProc
	Do()
	SetContext(context.Context)
}

// Interface for an RPC version interface bound to a server
// implementation.  The result of GetProc() can be used to marshal the
// arguments and results as well as actually invoke the function
// (though Do()).
type XdrSrv interface {
	Prog() uint32
	Vers() uint32
	ProgName() string
	VersName() string
	GetProc(uint32) XdrSrvProc
}

// An interface for types that can send remote procedure calls and
// await their reply.
type XdrSendCall interface {
	SendCall(context.Context, XdrProc) error
}

// A catalog of procedures of different RPC programs and versions,
// mostly useful for debugging (e.g., pretty-printing a log of RPC
// messages).  The key to the map is prog<<32|vers.  The function
// returns a new instance of an appropriate XdrProc.
var XdrCatalog = make(map[uint64]func(uint32)XdrProc)

//
// end boilerplate
//
